<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>برنامه‌نویسی ناهمگام :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 11;var sandboxLoadFiles = ["code/crow-tech.js","code/chapter/11_async.js"];</script><script>var clicky_site_ids = clicky_site_ids || []; clicky_site_ids.push(101171577);</script>
  <script async src="//static.getclicky.com/js"></script>

</head>

<article>
<nav><a href="10_modules.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="12_language.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>Chapter 11</span>برنامه‌نویسی ناهمگام</h1>

<blockquote>

<p><a class="p_ident" id="p_2jmj7l5rSw" href="#p_2jmj7l5rSw" tabindex="-1" role="presentation"></a>چه‌کسی می تواند زمانی که گل‌های آب ته‌نشین می‌شوند شکیبا باشد؟ چه‌کسی می تواند تا رسیدن لحظه‌ی عمل مناسب بی‌حرکت باقی‌ بماند؟</p>

<footer>لائودْزی, <cite>دائو ده جینگ</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_11.jpg" alt="Picture of two crows on a branch"></figure>

<p>بخش مرکزی یک کامپیوتر، بخشی که گام‌های اجرای برنامه‌ی ما را بر‌می‌دارد، <em>پردازشگر</em> نامیده می￼ شود. برنامه‌هایی که تا کنون دیده‌ایم از نوعی بوده اند که پردازشگر را تا وقتی که کارشان تمام شود، مشغول نگه می دارند. سرعت اجرا در چیزی مثل یک حلقه که با اعداد سر و کار دارد به میزان زیادی به سرعت پردازشگر ارتباط دارد.</p>

<p>اما خیلی از برنامه‌ها، با چیزهایی غیر از پردازشگر تعامل دارند. به عنوان مثال، ممکن است با کامپیوتری در یک شبکه تعامل داشته باشند یا داده‌ها را از دیسک سخت بخوانند – که خیلی کندتر از گرفتن آن ها از حافظه‌ی اصلی است.</p>

<p>زمانی که اتفاقی این چنینی می افتد، بی کار گذاشتن پردازشگر کار نادرستی است- ممکن است کارهای دیگری وجود داشته باشد که بتوان در آن حین انجام داد. این کار تا حدی توسط سیستم عامل مدیریت می شود که پردازشگر را بین برنامه‌های متعددی که در حال اجرا هستند بکار می گیرد. اما در مواقعی که می‌خواهیم یک برنامه‌ی واحد بتواند در هنگام انتظار برای یک درخواست شبکه به اجرا و پیش‌رفت خود ادامه دهد، از سیستم‌عامل کمکی بر نمی‌آید.</p>

<h2><a class="h_ident" id="h_1leuaMqErl" href="#h_1leuaMqErl" tabindex="-1" role="presentation"></a>ناهمگامی</h2>

<p>در یک مدل برنامه‌نویسی <em>همگام،</em> همه چیز یک به یک اتفاق می افتد. زمانی که تابعی را فراخوانی می کنید که عهده‌دار اجرای کاری طولانی است، تنها بعد از اتمام آن کار و برگرداندن نتیجه‌ی تابع، کنترل به برنامه‌ برمی‌گردد. در حین اجرای تابع، برنامه‌ی شما متوقف خواهد ماند.</p>

<p>در مدل <em>ناهمگام</em> می توان چندین کار را در یک زمان انجام داد. زمانی که کاری را شروع می کنید، برنامه‌ی شما به اجرا ادامه خواهد داد. زمانی که آن کار تمام می شود، برنامه خبردار شده و به نتایج دست خواهد یافت (به عنوان مثال می توان به خواندن اطلاعات از دیسک سخت اشاره کرد).</p>

<p>می توان برنامه نویسی همگام و ناهمگام را با یک مثال کوچک مقایسه کرد: برنامه‌ای که از دو منبع در شبکه، اطلاعاتی دریافت می کند و بعد نتایج را با هم ترکیب می کند.</p>

<p>در یک محیط همگام، جایی که درخواست فقط زمانی برمی گردد که کارش را تمام کرده باشد، آسان ترین روش انجام این کار ارسال درخواست ها یکی پس از دیگری است. مشکل این روش این است که درخواست دوم زمانی شروع می شود که درخواست اول تمام شده باشد. جمع زمانی که صرف می شود حداقل برابر است با مجموع زمان پاسخ‌های درخواست ها.</p>

<p><a class="p_ident" id="p_3SG8LH3yFM" href="#p_3SG8LH3yFM" tabindex="-1" role="presentation"></a>راه حل این مسئله، در یک سیستم همگام، استفاده از نخ‌های (threads) اضافی کنترل است. یک <em>thread</em> یک برنامه‌ی دیگر است که در حال اجرا است که اجرای آن ممکن است توسط سیستم عامل بین برنامه‌های دیگر قرار گیرد – چون بیشتر کامپیوترهای مدرن دارای چندین پردازشگر هستند، چندین thread را می توان در یک آن روی پردازشگرها اجرا کرد. یک thread دیگر می تواند درخواست دوم را شروع کند و سپس هر دوی thread ها￼ منتظر نتیجه‌ی درخواستشان می مانند که بعد از آن دوباره همگام شده و نتایج را باهم ترکیب می کنند.</p>

<p><a class="p_ident" id="p_woPjde2M6/" href="#p_woPjde2M6/" tabindex="-1" role="presentation"></a>در نمودار پیش رو، خطوط درشت نمایانگر زمانی است که برنامه سپری می کند تا در حالت نرمال اجرا شود، و خطوط باریک نشانگر زمانی است که برای پاسخ شبکه صرف می شود. در مدل همگام، زمانی که توسط شبکه گرفته می شود به عنوان بخشی از جدول زمانی برای thread داده شده محسوب می شود. در مدل ناهمگام، شروع یک عملیات مرتبط با شبکه، به طور مفهومی باعث ایجاد یک انشعاب در جدول زمانی می شود. برنامه‌ای که این انشعاب را شروع کرده است به اجرای خود ادامی می دهد، و آن عملیات به موازات آن انجام می شود و وقتی پایان یافت برنامه را باخبر می کند.</p><figure><img src="img/control-io.svg" alt="Control flow for synchronous and asynchronous programming"></figure>

<p>راه دیگری که می توان با آن تفاوت این دو را بیان کرد این است که در مدل همگام، انتظار برای پایان درخواست‌ها به صورت ضمنی است در حالیکه در مدل ناهمگام صریح و تحت کنترل ما می‌باشد.</p>

<p>ناهمگامی مثل چاقوی دولبه است. برای برنامه‌هایی که مناسب اجرای مستقیم خطی نیستند کار را ساده تر می کند اما در عین حال می تواند برای برنامه هایی که به صورت مستقیم خطی اجرا می شوند نامناسب باشد. در ادامه این فصل با راه‌هایی برای حل این ناهمگونی آشنا خواهیم شد.</p>

<p><a class="p_ident" id="p_DJSgOGbrf5" href="#p_DJSgOGbrf5" tabindex="-1" role="presentation"></a>هر دو پلتفرم مهم برنامه نویسی جاوااسکریپت – مرورگرها و <bdo>Node.js</bdo> – عملیاتی که ممکن است زمانگیر باشند را به صورت ناهمگام اجرا می کنند و از نخ‌ها (threads) استفاده نمی کنند. به دلیل اینکه برنامه نویسی روی thread ها کار سختی محسوب می شود (در این نوع برنامه نویسی درک کارکرد برنامه، به دلیل انجام چند کار در آن واحد بسیار سخت‌تر می شود)، روش ناهمگام عموما چیز خوبی محسوب می شود.</p>

<h2><a class="h_ident" id="h_zUZJr7Lzut" href="#h_zUZJr7Lzut" tabindex="-1" role="presentation"></a>فناوری کلاغ‌ها</h2>

<p>خیلی از مردم می‌دانند که کلاغ‌ها پرنده‌هایی بسیار باهوش هستند. آن ها می توانند از ابزار استفاده کنند، برای آینده برنامه ریزی کنند، چیزهایی را به خاطر بسپارند و حتی این موارد را با هم به اشتراک بگذارند.</p>

<p>چیزی که بیشتر مردم از آن آگاه نیستند این است که کلاغ‌ها توانایی های زیادی دارند که از دید ما مخفی می کنند. یک فرد مشهور (و کمی عجیب و غریب) متخصص کلاغ‌ها به من گفت که فناوری کلاغ خیلی از فناوری انسان عقب نیست و آن ها در حال رسیدن به انسان ها هستند.</p>

<p>به عنوان مثال، نهاد‌های زیادی بین کلاغ‌ها وجود دارد که توانایی ساخت وسایل محاسباتی را دارند. این وسایل شبیه وسایل محاسباتی انسان‌ها، الکترونیکی نیستند بلکه از رفتارهای حشراتی کوچک، گونه‌هایی نزدیک به موریانه￼ که یک رابطه‌ی همزیستی با کلاغ ها توسعه داده اند، بهره برداری می کنند. کلاغ‌ها برایشان غذا فراهم می کنند و در عوض حشرات کلنی‌های پیچیده‌ی آن ها را ساخته و بکار می اندازند، که به کمک موجودات زنده‌ای که در درون آن ها زندگی می کنند، محاسبات را انجام می دهند.</p>

<p>این گونه کلنی‌ها معمولا در لانه‌های بزرگ و قدیمی قرار دارند. پرنده‌ها و حشرات با همکاری هم شبکه‌ای از ساختارهای گلی پیازی‌شکل را می‌سازند و بین ترک‌های لانه پنهان می کنند که در آن حشرات زندگی و کار خواهند کرد.</p>

<p>برای تعامل با دیگر وسایل،این ماشین‌ها از سیگنال‌های نور استفاده می کنند. کلاغ‌ها قطعاتی از مواد انعکاسی را در ساقه‌های خاصی که برای ارتباط در نظر گرفته شده اند جاسازی می کنند و حشرات آن ها را هدف قرار می دهند تا نور را به لانه‌ی دیگری بتابانند و داده‌ها را به صورت دنباله‌ای از چشمک‌های کوتاه به رمز در می آورند. این یعنی فقط لانه‌هایی که دارای یک ارتباط متصل بصری هستند می توانند با یکدیگر تعامل کنند.</p>

<p><a class="p_ident" id="p_cCgxPRsF1V" href="#p_cCgxPRsF1V" tabindex="-1" role="presentation"></a>دوست متخصص کلاغ ما نقشه‌ای از شبکه‌ی لانه‌های کلاغ‌ها در روستای <bdo>Hières-sur-Amby</bdo> قرار دارد، کشیده است که در حاشیه‌ی رودخانه‌ی Rhône قرار دارد. آن نقشه نشان می دهد که لانه‌ها و ارتباطاتشان چگونه است:</p><figure><img src="img/Hieres-sur-Amby.png" alt="A network of crow nests in a small village"></figure>

<p>در نمونه‌ای شگفت‌انگیز از تکامل همگرا، کامپیوترهای کلاغ‌ها، جاوااسکریپت را اجرا می کنند. در این فصل قرار است بعضی از قابلیت‌های پایه‌ای شبکه را برایشان برنامه نویسی کنیم.</p>

<h2><a class="h_ident" id="h_LtY0V3+tmI" href="#h_LtY0V3+tmI" tabindex="-1" role="presentation"></a>callbacks - فراخوان برگشتی</h2>

<p><a class="p_ident" id="p_jU9HKeneWd" href="#p_jU9HKeneWd" tabindex="-1" role="presentation"></a>یکی از راه‌های برنامه نویسی ناهمگام این است توابعی که یک کار زمانگیر را انجام می دهند یک آرگومان اضافی دریافت کنند، یک تابع callback. تابع اصلی اجرا شده و پایان می پذیرد بعد تابع callback با نتایج دریافتی از تابع اصلی فراخوانی می گردد.</p>

<p><a class="p_ident" id="p_Kzh6PibMf8" href="#p_Kzh6PibMf8" tabindex="-1" role="presentation"></a>به عنوان یک مثال، تابع <code>setTimeout</code>، که در <bdo>Node.js</bdo> و مرورگرها در دسترس است، به اندازه‌ی هزارم ثانیه‌ ای که مشخص شده است منتظر می ماند و سپس یک تابع را فراخوانی می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_RyFm7Uoiuv" href="#c_RyFm7Uoiuv" tabindex="-1" role="presentation"></a><span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Tick&quot;</span>), <span class="cm-number">500</span>);</pre>

<p>این انتظار معمولا خیلی کاربردهای مهمی ندارد اما در مواقعی می تواند مفید باشد مثل به روز رسانی یک انیمیشن یا بررسی اینکه چیزی بیش از زمان مشخصی طول کشیده باشد.</p>

<p><a class="p_ident" id="p_tNWze/ephs" href="#p_tNWze/ephs" tabindex="-1" role="presentation"></a>اجرای چندین عمل ناهمگام در یک ردیف با استفاده از توابع callback به این معنا است که شما باید به ارسال توابع جدید برای ادامه‌ی محاسبه بعد از هر عمل ادامه دهید.</p>

<p>بیشتر کامپیوترهای لانه‌های کلاغ‌ها، دارای یک بافت ذخیره‌سازی بلند مدت می باشند، جاییکه اطلاعات، درون شاخه‌ها حک می شوند و می توان آن ها را بعدا دوباره خواند. حک کردن یا پیدا کردن یک بخش از اطلاعات زمانگیر است بنابراین رابط سیستم ذخیره‌سازی بلند مدت، ناهمگام خواهد بود و از توابع callback استفاده خواهد شد.</p>

<p><a class="p_ident" id="p_KiwPWHDFBj" href="#p_KiwPWHDFBj" tabindex="-1" role="presentation"></a>بافت‌های ذخیره‌سازی، بخش‌های اطلاعات را که به صورت JSON درآمده اند را تحت نام‌هایی ذخیره می کنند. یک کلاغ ممکن است اطلاعاتی در مورد مخفیگاه‌ غذاها را به عنوان <bdo><code>&quot;food caches&quot;</code></bdo> ذخیره کند، که می تواند دارای آرایه‌ای از نام‌هایی باشد که به دیگر بخش‌های اطلاعات اشاره می نمایند، اطلاعاتی که مخفیگاه واقعی را توصیف می کنند. برای جستجوی یک مخفیگاه غذا در بافت‌های ذخیره‌سازی لانه‌ی <bdo>Big Oak</bdo>، یک کلاغ می تواند کدی مثل زیر را اجرا کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_f7XSZ4G+k8" href="#c_f7XSZ4G+k8" tabindex="-1" role="presentation"></a><span class="cm-keyword">import</span> {<span class="cm-def">bigOak</span>} <span class="cm-keyword">from</span> <span class="cm-string">&quot;./crow-tech&quot;</span>;

<span class="cm-variable">bigOak</span>.<span class="cm-property">readStorage</span>(<span class="cm-string">&quot;food caches&quot;</span>, <span class="cm-def">caches</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">let</span> <span class="cm-def">firstCache</span> <span class="cm-operator">=</span> <span class="cm-variable-2">caches</span>[<span class="cm-number">0</span>];
  <span class="cm-variable">bigOak</span>.<span class="cm-property">readStorage</span>(<span class="cm-variable-2">firstCache</span>, <span class="cm-def">info</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">info</span>);
  });
});</pre>

<p>(تمامی متغیرها و رشته‌ها از زبان کلاغی به زبان انگلیسی ترجمه شده اند.)</p>

<p>این سبک از برنامه نویسی شدنی است اما با هر بار عمل همگام، میزان تورفتگی اضافه می شود ،چرا که به تابع دیگر نیاز خواهید داشت. برای انجام کارهای پیچیده‌تر ، مثل انجام چند عمل در یک زمان واحد، این شیوه‌ی کدنویسی می تواند کمی بدقواره شود.</p>

<p>کامپیوترهای لانه‌ها طوری ساخته شده اند که بتوانند به وسیله‌ی جفت‌های درخواست-پاسخ با هم ارتباط برقرار کنند. این یعنی یک لانه، پیامی را به لانه‌ی دیگری ارسال می کند، که این لانه نیز بلافاصله پیامی را که حاوی تایید دریافت و احتمالا شامل پاسخی به درخواست است برمی‌گرداند.</p>

<p>هر پیغام توسط یک <em>نوع</em>، برچسب گذاری می شود که تعیین کننده‌ی نحوه‌ی مدیریت آن می باشد. کد ما می تواند توابعی را برای رسیدگی به انواع خاص، تعریف کند، و زمانی که درخواستی از آن نوع آمد ، تابع رسیدگی‌کننده فراخوانی شده تا پاسخی را تولید کند.</p>

<p>رابطی که توسط ماژول <bdo><code>&quot;./<wbr>crow-tech&quot;</code></bdo> صادر می شود، تابعی دارای callback برای تعامل فراهم می کند. لانه‌ها دارای متدی به نام <code>send</code> هستند که درخواست‌ها را ارسال می کند. این متد نام لانه‌ی مقصد، نوع درخواست و محتوای درخواست را به عنوان سه آرگومان اول گرفته و آرگومان بعدی یک تابع است که زمانی که یک پاسخ دریافت می شود، فراخوانی می شود.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_qzWIKDLKSP" href="#c_qzWIKDLKSP" tabindex="-1" role="presentation"></a><span class="cm-variable">bigOak</span>.<span class="cm-property">send</span>(<span class="cm-string">&quot;Cow Pasture&quot;</span>, <span class="cm-string">&quot;note&quot;</span>, <span class="cm-string">&quot;Let's caw loudly at 7PM&quot;</span>,
            () <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Note delivered.&quot;</span>));</pre>

<p>اما برای اینکه لانه‌ها را قادر سازیم تا آن درخواست را دریافت کند، می‌بایست ابتدا نوع درخواستی به نام <code>&quot;note&quot;</code> را تعریف کنیم. کدی که به این درخواست‌ها رسیدگی می کند باید نه تنها بر روی کامپیوتر این لانه اجرا شود بلکه باید روی تمامی لانه‌هایی که می توانند پیامی از این نوع را دریافت کنند اجرا شود. ما فرض می کنیم که کلاغی پرواز کرده و کد ما را روی همه‌ی لانه‌ها نصب می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_38THPHvc7d" href="#c_38THPHvc7d" tabindex="-1" role="presentation"></a><span class="cm-keyword">import</span> {<span class="cm-def">defineRequestType</span>} <span class="cm-keyword">from</span> <span class="cm-string">&quot;./crow-tech&quot;</span>;

<span class="cm-variable">defineRequestType</span>(<span class="cm-string">&quot;note&quot;</span>, (<span class="cm-def">nest</span>, <span class="cm-def">content</span>, <span class="cm-def">source</span>, <span class="cm-def">done</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">nest</span>.<span class="cm-property">name</span><span class="cm-string-2">}</span> <span class="cm-string-2">received note: ${</span><span class="cm-variable-2">content</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  <span class="cm-variable-2">done</span>();
});</pre>

<p>تابع <code>defineRequestType</code> یک نوع درخواست جدید را تعریف می کند. در مثال، امکان پشتیبانی از درخواست‌های <code>&quot;note&quot;</code> اضافه می می‌شود که در واقع تنها یک یادداشت را به لانه‌ی داده شده ارسال می کند. پیاده‌سازی ما از <bdo><code>console.log</code></bdo> برای تایید رسیدن درخواست استفاده می کند. لانه‌ها دارای خاصیتی به نام <code>name</code> هستند که نامشان را نگه داری می کند.</p>

<p><a class="p_ident" id="p_lEh6rApDCd" href="#p_lEh6rApDCd" tabindex="-1" role="presentation"></a>آرگومان چهارمی که به تابع رسیدگی کننده داده می شود، <code>done</code>، یک تابع callback است که باید زمانی که درخواست کارش تمام شد فراخوانی شود. اگر از مقدار بازگشتی (توسط return) از تابع رسیدگی کننده به عنوان مقدار پاسخ استفاده کرده بودیم ، در این‌صورت رسیدگی‌کننده‌ی درخواست نمی توانست خودش یک عمل ناهمگام را اجرا کند. تابعی که یک کار ناهمگام را انجام می دهد نوعا قبل از انجام آن کار بر‌می‌گردد و برای اجرای تابع callback پس از انجام کار تنظیم می شود. بنابراین ما نیاز به مکانیزم‌هایی ناهمگام داریم – در این مثال، به یک تابع callback دیگر- تا وقتی که یک پاسخ آماده بود، علامت بدهیم.</p>

<p>به شکلی، ناهمگامی مسری است. هر تابعی که یک تابع را فراخوانی کند که به صورت ناهمگام عمل می کند، خودش باید ناهمگام باشد که می توان با استفاده از یک callback یا مکانیزمی شبیه به آن باشد تا نتیجه‌اش را تحویل دهد. فراخوانی یک callback کمی پیچیده تر و مشکل‌ساز تر است از برگرداندن یک مقدار به شکل ساده، بنابراین استفاده از این روش برای ساختاردهی بخش‌های بزرگی از برنامه‌تان جالب نیست.</p>

<h2><a class="h_ident" id="h_i7gRmvd0TO" href="#h_i7gRmvd0TO" tabindex="-1" role="presentation"></a>Promise ها</h2>

<p>اگر بتوان مفاهیم مجرد را به صورت مقدار‌ها نمایش داد، اغلب ساده تر می شوند. در رابطه با کارهای ناهمگام می توانید به جای تنظیم یک تابع برای فراخوانی در یک نقطه‌ی خاص در آینده، یک شیء را برگردانید که این رخداد آینده را نمایندگی کند.</p>

<p><a class="p_ident" id="p_jC/YRC/GWd" href="#p_jC/YRC/GWd" tabindex="-1" role="presentation"></a>این دقیقا چیزی است که کلاس استاندارد <code>Promise</code> انجام می دهد. یک <em>promise</em> یک عمل ناهمگام است که در زمانی تکمیل می شود و مقداری را تولید می کند. می تواند هرکسی که علاقمند باشد را در زمان آماده شدن مقدارش باخبر کند.</p>

<p><a class="p_ident" id="p_rAjGu7aKrd" href="#p_rAjGu7aKrd" tabindex="-1" role="presentation"></a>آسان ترین روش ایجاد یک promise فراخوانی <bdo><code>Promise.resolve</code></bdo> است. این تابع اطمینان حاصل می کند که مقداری که به آن می دهید درون یک promise قرار می گیرد. اگر خودش از قبل یک promise بود، برگردانده می  شود – در غیر این صورت، شما promise جدیدی دریافت می کنید که با مقدار شما به عنوان نتیجه‌اش بلافاصله پایان می می‌پذیرد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_fzJ7VLwQ/i" href="#c_fzJ7VLwQ/i" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">fifteen</span> <span class="cm-operator">=</span> <span class="cm-variable">Promise</span>.<span class="cm-property">resolve</span>(<span class="cm-number">15</span>);
<span class="cm-variable">fifteen</span>.<span class="cm-property">then</span>(<span class="cm-def">value</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Got ${</span><span class="cm-variable-2">value</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>));
<span class="cm-comment">// → Got 15</span></pre>

<p><a class="p_ident" id="p_Q87nCNSnKu" href="#p_Q87nCNSnKu" tabindex="-1" role="presentation"></a>برای گرفتن نتیجه‌ی یک promise، می توانید از متد <code>then</code> آن استفاده کنید. این متد تابع callbackای را ثبت می کند که در هنگامی که promise به نتیجه رسید و مقداری را تولید کرد، فراخوانی می شود. می توانید چندین تابع callback را به یک promise اضافه کنید، و همه‌ی آن‌ها فراخوانی خواهند شد، حتی اگر آن‌ها را بعد از به نتیجه‌رسیدن promise اضافه کنید.</p>

<p><a class="p_ident" id="p_J2+Ok30Bhh" href="#p_J2+Ok30Bhh" tabindex="-1" role="presentation"></a>اما این همه‌ی آن چیزی نیست که متد <code>then</code> انجام می دهد. این متد promise دیگری را برمی‌گرداند، که مقداری که از تابع رسیدگی کننده برمی گردد را (resolve) را نتیجه‌یابی می کند یا اگر یک promise را برگرداند، برای آن promise منتظر می ماند سپس به حل و فصل نتیجه‌اش می پردازد.</p>

<p><a class="p_ident" id="p_x1wxB3v/ex" href="#p_x1wxB3v/ex" tabindex="-1" role="presentation"></a>خوب است که promiseها را به عنوان وسایلی که مقدارها را به درون فضای ناهمگام انتقال می دهند تصور کنید. یک مقدار نرمال به سادگی وجود دارد. یک مقدار وعده داده شده (promised value) مقداری است که ممکن است از قبل وجود داشته باشد یا در نقطه‌ای در آینده ظاهر شود. محاسباتی که به عنوان promise تعریف می شوند روی این گونه مقدارها عمل می کنند و همزمان با در دسترس قرار گرفتن مقدارها به اجرا در می آیند.</p>

<p><a class="p_ident" id="p_CZ6CO6EnK8" href="#p_CZ6CO6EnK8" tabindex="-1" role="presentation"></a>برای ایجاد یک promise، می‌توانید از <code>Promise</code> به عنوان یک سازنده استفاده کنید. رابط آن کمی متفاوت است – سازنده یک تابع را به عنوان آرگومان می گیرد که آن را بلافاصله فراخوانی می کند ، تابعی که می تواند برای نتیجه‌یابی promise استفاده شود. به این صورت کار می کند، به جای اینکه به عنوان مثال با یک متد <code>resolve</code> کار کند، به طوری که فقط کدی که promise را ایجاد کرده است می تواند آن را نتیجه‌یابی کند.</p>

<p>این روشی است که می توانید برای ایجاد یک رابط مبتنی بر promise برای تابع <code>readStorage</code> ایجاد کنید:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_gYXlRtzMyd" href="#c_gYXlRtzMyd" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">storage</span>(<span class="cm-def">nest</span>, <span class="cm-def">name</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>(<span class="cm-def">resolve</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable-2">nest</span>.<span class="cm-property">readStorage</span>(<span class="cm-variable-2">name</span>, <span class="cm-def">result</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">resolve</span>(<span class="cm-variable-2">result</span>));
  });
}

<span class="cm-variable">storage</span>(<span class="cm-variable">bigOak</span>, <span class="cm-string">&quot;enemies&quot;</span>)
  .<span class="cm-property">then</span>(<span class="cm-def">value</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Got&quot;</span>, <span class="cm-variable-2">value</span>));</pre>

<p><a class="p_ident" id="p_AJNl7eWKVe" href="#p_AJNl7eWKVe" tabindex="-1" role="presentation"></a>این تابع ناهمگام یک مقدار معنادار را تولید می کند. این مزیت اصلی promise ها است – آن ها استفاده از توابع ناهمگام را ساده می کنند. به جای اینکه مجبور باشیم callbackهای متعددی ارسال کنیم، توابع مبتنی بر promise￼ شبیه توابع معمولی به نظر می رسند: ورودی ها را به عنوان آرگومان می گیرند و خروجی شان را تولید می کنند. تنها تفاوت این است که خروجی ممکن است هنوز در دسترس نباشد.</p>

<h2><a class="h_ident" id="h_FlZkkRfkN/" href="#h_FlZkkRfkN/" tabindex="-1" role="presentation"></a>Failure</h2>

<p><a class="p_ident" id="p_3xQ2mMjPI/" href="#p_3xQ2mMjPI/" tabindex="-1" role="presentation"></a>Regular JavaScript computations can fail by throwing an exception. Asynchronous computations often need something like that. A network request may fail, or some code that is part of the asynchronous computation may throw an exception.</p>

<p><a class="p_ident" id="p_U/HpYNT9Y/" href="#p_U/HpYNT9Y/" tabindex="-1" role="presentation"></a>One of the most pressing problems with the callback style of asynchronous programming is that it makes it extremely difficult to make sure failures are properly reported to the callbacks.</p>

<p><a class="p_ident" id="p_o521HDp6Q3" href="#p_o521HDp6Q3" tabindex="-1" role="presentation"></a>A widely used convention is that the first argument to the callback is used to indicate that the action failed, and the second contains the value produced by the action when it was successful. Such callback functions must always check whether they received an exception and make sure that any problems they cause, including exceptions thrown by functions they call, are caught and given to the right function.</p>

<p><a class="p_ident" id="p_sdBQKhfBzG" href="#p_sdBQKhfBzG" tabindex="-1" role="presentation"></a>Promises make this easier. They can be either resolved (the action finished successfully) or rejected (it failed). Resolve handlers (as registered with <code>then</code>) are called only when the action is successful, and rejections are automatically propagated to the new promise that is returned by <code>then</code>. And when a handler throws an exception, this automatically causes the promise produced by its <code>then</code> call to be rejected. So if any element in a chain of asynchronous actions fails, the outcome of the whole chain is marked as rejected, and no success handlers are called beyond the point where it failed.</p>

<p><a class="p_ident" id="p_/Duy2d2EJl" href="#p_/Duy2d2EJl" tabindex="-1" role="presentation"></a>Much like resolving a promise provides a value, rejecting one also provides one, usually called the <em>reason</em> of the rejection. When an exception in a handler function causes the rejection, the exception value is used as the reason. Similarly, when a handler returns a promise that is rejected, that rejection flows into the next promise. There’s a <code>Promise.reject</code> function that creates a new, immediately rejected promise.</p>

<p><a class="p_ident" id="p_n8xS1bRY5C" href="#p_n8xS1bRY5C" tabindex="-1" role="presentation"></a>To explicitly handle such rejections, promises have a <code>catch</code> method that registers a handler to be called when the promise is rejected, similar to how <code>then</code> handlers handle normal resolution. It’s also very much like <code>then</code> in that it returns a new promise, which resolves to the original promise’s value if it resolves normally and to the result of the <code>catch</code> handler otherwise. If a <code>catch</code> handler throws an error, the new promise is also rejected.</p>

<p><a class="p_ident" id="p_M0B+/Jkbg2" href="#p_M0B+/Jkbg2" tabindex="-1" role="presentation"></a>As a shorthand, <code>then</code> also accepts a rejection handler as a second argument, so you can install both types of handlers in a single method call.</p>

<p><a class="p_ident" id="p_JarwEqSrWp" href="#p_JarwEqSrWp" tabindex="-1" role="presentation"></a>A function passed to the <code>Promise</code> constructor receives a second argument, alongside the resolve function, which it can use to reject the new promise.</p>

<p><a class="p_ident" id="p_z3DyjoAwVl" href="#p_z3DyjoAwVl" tabindex="-1" role="presentation"></a>The chains of promise values created by calls to <code>then</code> and <code>catch</code> can be seen as a pipeline through which asynchronous values or failures move. Since such chains are created by registering handlers, each link has a success handler or a rejection handler (or both) associated with it. Handlers that don’t match the type of outcome (success or failure) are ignored. But those that do match are called, and their outcome determines what kind of value comes next—success when it returns a non-promise value, rejection when it throws an exception, and the outcome of a promise when it returns one of those.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_TOwOnoqIIW" href="#c_TOwOnoqIIW" tabindex="-1" role="presentation"></a><span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>((<span class="cm-def">_</span>, <span class="cm-def">reject</span>) <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">reject</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Fail&quot;</span>)))
  .<span class="cm-property">then</span>(<span class="cm-def">value</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Handler 1&quot;</span>))
  .<span class="cm-property">catch</span>(<span class="cm-def">reason</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Caught failure &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">reason</span>);
    <span class="cm-keyword">return</span> <span class="cm-string">&quot;nothing&quot;</span>;
  })
  .<span class="cm-property">then</span>(<span class="cm-def">value</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Handler 2&quot;</span>, <span class="cm-variable-2">value</span>));
<span class="cm-comment">// → Caught failure Error: Fail</span>
<span class="cm-comment">// → Handler 2 nothing</span></pre>

<p><a class="p_ident" id="p_221BynGy7j" href="#p_221BynGy7j" tabindex="-1" role="presentation"></a>Much like an uncaught exception is handled by the environment, JavaScript environments can detect when a promise rejection isn’t handled and will report this as an error.</p>

<h2><a class="h_ident" id="h_o8Vlf60I8f" href="#h_o8Vlf60I8f" tabindex="-1" role="presentation"></a>Networks are hard</h2>

<p><a class="p_ident" id="p_fjvcMK987B" href="#p_fjvcMK987B" tabindex="-1" role="presentation"></a>Occasionally, there isn’t enough light for the crows’ mirror systems to transmit a signal or something is blocking the path of the signal. It is possible for a signal to be sent but never received.</p>

<p><a class="p_ident" id="p_lbPe1lr2o1" href="#p_lbPe1lr2o1" tabindex="-1" role="presentation"></a>As it is, that will just cause the callback given to <code>send</code> to never be called, which will probably cause the program to stop without even noticing there is a problem. It would be nice if, after a given period of not getting a response, a request would <em>time out</em> and report failure.</p>

<p><a class="p_ident" id="p_uW9fnd/IuC" href="#p_uW9fnd/IuC" tabindex="-1" role="presentation"></a>Often, transmission failures are random accidents, like a car’s headlight interfering with the light signals, and simply retrying the request may cause it to succeed. So while we’re at it, let’s make our request function automatically retry the sending of the request a few times before it gives up.</p>

<p><a class="p_ident" id="p_aJq/gxAcrD" href="#p_aJq/gxAcrD" tabindex="-1" role="presentation"></a>And, since we’ve established that promises are a good thing, we’ll also make our request function return a promise. In terms of what they can express, callbacks and promises are equivalent. Callback-based functions can be wrapped to expose a promise-based interface, and vice versa.</p>

<p><a class="p_ident" id="p_5BHxJdJVP6" href="#p_5BHxJdJVP6" tabindex="-1" role="presentation"></a>Even when a request and its response are successfully delivered, the response may indicate failure—for example, if the request tries to use a request type that hasn’t been defined or the handler throws an error. To support this, <code>send</code> and <code>defineRequestType</code> follow the convention mentioned before, where the first argument passed to callbacks is the failure reason, if any, and the second is the actual result.</p>

<p><a class="p_ident" id="p_97bGw9TnRL" href="#p_97bGw9TnRL" tabindex="-1" role="presentation"></a>These can be translated to promise resolution and rejection by our wrapper.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Wg7xZ1po7J" href="#c_Wg7xZ1po7J" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">Timeout</span> <span class="cm-keyword">extends</span> <span class="cm-variable">Error</span> {}

<span class="cm-keyword">function</span> <span class="cm-def">request</span>(<span class="cm-def">nest</span>, <span class="cm-def">target</span>, <span class="cm-def">type</span>, <span class="cm-def">content</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>((<span class="cm-def">resolve</span>, <span class="cm-def">reject</span>) <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">done</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;
    <span class="cm-keyword">function</span> <span class="cm-def">attempt</span>(<span class="cm-def">n</span>) {
      <span class="cm-variable-2">nest</span>.<span class="cm-property">send</span>(<span class="cm-variable-2">target</span>, <span class="cm-variable-2">type</span>, <span class="cm-variable-2">content</span>, (<span class="cm-def">failed</span>, <span class="cm-def">value</span>) <span class="cm-operator">=&gt;</span> {
        <span class="cm-variable-2">done</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;
        <span class="cm-keyword">if</span> (<span class="cm-variable-2">failed</span>) <span class="cm-variable-2">reject</span>(<span class="cm-variable-2">failed</span>);
        <span class="cm-keyword">else</span> <span class="cm-variable-2">resolve</span>(<span class="cm-variable-2">value</span>);
      });
      <span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> {
        <span class="cm-keyword">if</span> (<span class="cm-variable-2">done</span>) <span class="cm-keyword">return</span>;
        <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>) <span class="cm-variable-2">attempt</span>(<span class="cm-variable-2">n</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>);
        <span class="cm-keyword">else</span> <span class="cm-variable-2">reject</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Timeout</span>(<span class="cm-string">&quot;Timed out&quot;</span>));
      }, <span class="cm-number">250</span>);
    }
    <span class="cm-variable-2">attempt</span>(<span class="cm-number">1</span>);
  });
}</pre>

<p><a class="p_ident" id="p_st0GjZl4iZ" href="#p_st0GjZl4iZ" tabindex="-1" role="presentation"></a>Because promises can be resolved (or rejected) only once, this will work. The first time <code>resolve</code> or <code>reject</code> is called determines the outcome of the promise, and any further calls, such as the timeout arriving after the request finishes or a request coming back after another request finished, are ignored.</p>

<p><a class="p_ident" id="p_WbNhsnDMXt" href="#p_WbNhsnDMXt" tabindex="-1" role="presentation"></a>To build an asynchronous loop, for the retries, we need to use a recursive function—a regular loop doesn’t allow us to stop and wait for an asynchronous action. The <code>attempt</code> function makes a single attempt to send a request. It also sets a timeout that, if no response has come back after 250 milliseconds, either starts the next attempt or, if this was the fourth attempt, rejects the promise with an instance of <code>Timeout</code> as the reason.</p>

<p><a class="p_ident" id="p_acM5kja+EL" href="#p_acM5kja+EL" tabindex="-1" role="presentation"></a>Retrying every quarter-second and giving up when no response has come in after a second is definitely somewhat arbitrary. It is even possible, if the request did come through but the handler is just taking a bit longer, for requests to be delivered multiple times. We’ll write our handlers with that problem in mind—duplicate messages should be harmless.</p>

<p><a class="p_ident" id="p_e9iIV/0dqZ" href="#p_e9iIV/0dqZ" tabindex="-1" role="presentation"></a>In general, we will not be building a world-class, robust network today. But that’s okay—crows don’t have very high expectations yet when it comes to computing.</p>

<p><a class="p_ident" id="p_8G2rFK/pFH" href="#p_8G2rFK/pFH" tabindex="-1" role="presentation"></a>To isolate ourselves from callbacks altogether, we’ll go ahead and also define a wrapper for <code>defineRequestType</code> that allows the handler function to return a promise or plain value and wires that up to the callback for us.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_HejJcHo3dj" href="#c_HejJcHo3dj" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">requestType</span>(<span class="cm-def">name</span>, <span class="cm-def">handler</span>) {
  <span class="cm-variable">defineRequestType</span>(<span class="cm-variable-2">name</span>, (<span class="cm-variable">nest</span>, <span class="cm-variable">content</span>, <span class="cm-variable">source</span>,
                           <span class="cm-variable">callback</span>) <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">try</span> {
      <span class="cm-variable">Promise</span>.<span class="cm-property">resolve</span>(<span class="cm-variable-2">handler</span>(<span class="cm-variable">nest</span>, <span class="cm-variable">content</span>, <span class="cm-variable">source</span>))
        .<span class="cm-property">then</span>(<span class="cm-def">response</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">callback</span>(<span class="cm-atom">null</span>, <span class="cm-variable-2">response</span>),
              <span class="cm-def">failure</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">callback</span>(<span class="cm-variable-2">failure</span>));
    } <span class="cm-keyword">catch</span> (<span class="cm-def">exception</span>) {
      <span class="cm-variable">callback</span>(<span class="cm-variable-2">exception</span>);
    }
  });
}</pre>

<p><a class="p_ident" id="p_m5fm86hZW6" href="#p_m5fm86hZW6" tabindex="-1" role="presentation"></a><code>Promise.resolve</code> is used to convert the value returned by <code>handler</code> to a promise if it isn’t already.</p>

<p><a class="p_ident" id="p_CAzmYCfy+I" href="#p_CAzmYCfy+I" tabindex="-1" role="presentation"></a>Note that the call to <code>handler</code> had to be wrapped in a <code>try</code> block to make sure any exception it raises directly is given to the callback. This nicely illustrates the difficulty of properly handling errors with raw callbacks—it is easy to forget to properly route exceptions like that, and if you don’t do it, failures won’t get reported to the right callback. Promises make this mostly automatic and thus less error-prone.</p>

<h2><a class="h_ident" id="h_4rfkjtrFcP" href="#h_4rfkjtrFcP" tabindex="-1" role="presentation"></a>Collections of promises</h2>

<p><a class="p_ident" id="p_aICANM74sI" href="#p_aICANM74sI" tabindex="-1" role="presentation"></a>Each nest computer keeps an array of other nests within transmission distance in its <code>neighbors</code> property. To check which of those are currently reachable, you could write a function that tries to send a <code>&quot;ping&quot;</code> request (a request that simply asks for a response) to each of them and see which ones come back.</p>

<p><a class="p_ident" id="p_fBcfo2czu8" href="#p_fBcfo2czu8" tabindex="-1" role="presentation"></a>When working with collections of promises running at the same time, the <code>Promise.all</code> function can be useful. It returns a promise that waits for all of the promises in the array to resolve and then resolves to an array of the values that these promises produced (in the same order as the original array). If any promise is rejected, the result of <code>Promise.all</code> is itself rejected.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ZtEtR5AsHV" href="#c_ZtEtR5AsHV" tabindex="-1" role="presentation"></a><span class="cm-variable">requestType</span>(<span class="cm-string">&quot;ping&quot;</span>, () <span class="cm-operator">=&gt;</span> <span class="cm-string">&quot;pong&quot;</span>);

<span class="cm-keyword">function</span> <span class="cm-def">availableNeighbors</span>(<span class="cm-def">nest</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">requests</span> <span class="cm-operator">=</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>.<span class="cm-property">map</span>(<span class="cm-def">neighbor</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">return</span> <span class="cm-variable">request</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">neighbor</span>, <span class="cm-string">&quot;ping&quot;</span>)
      .<span class="cm-property">then</span>(() <span class="cm-operator">=&gt;</span> <span class="cm-atom">true</span>, () <span class="cm-operator">=&gt;</span> <span class="cm-atom">false</span>);
  });
  <span class="cm-keyword">return</span> <span class="cm-variable">Promise</span>.<span class="cm-property">all</span>(<span class="cm-variable-2">requests</span>).<span class="cm-property">then</span>(<span class="cm-def">result</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>.<span class="cm-property">filter</span>((<span class="cm-def">_</span>, <span class="cm-def">i</span>) <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">result</span>[<span class="cm-variable-2">i</span>]);
  });
}</pre>

<p><a class="p_ident" id="p_p074kPsd4q" href="#p_p074kPsd4q" tabindex="-1" role="presentation"></a>When a neighbor isn’t available, we don’t want the entire combined promise to fail since then we still wouldn’t know anything. So the function that is mapped over the set of neighbors to turn them into request promises attaches handlers that make successful requests produce <code>true</code> and rejected ones produce <code>false</code>.</p>

<p><a class="p_ident" id="p_xJZvWO1Y4P" href="#p_xJZvWO1Y4P" tabindex="-1" role="presentation"></a>In the handler for the combined promise, <code>filter</code> is used to remove those elements from the <code>neighbors</code> array whose corresponding value is false. This makes use of the fact that <code>filter</code> passes the array index of the current element as a second argument to its filtering function (<code>map</code>, <code>some</code>, and similar higher-order array methods do the same).</p>

<h2><a class="h_ident" id="h_pi4+kiBmAy" href="#h_pi4+kiBmAy" tabindex="-1" role="presentation"></a>Network flooding</h2>

<p><a class="p_ident" id="p_ktVbTscCrR" href="#p_ktVbTscCrR" tabindex="-1" role="presentation"></a>The fact that nests can talk only to their neighbors greatly inhibits the usefulness of this network.</p>

<p><a class="p_ident" id="p_/O0D1BFKEk" href="#p_/O0D1BFKEk" tabindex="-1" role="presentation"></a>For broadcasting information to the whole network, one solution is to set up a type of request that is automatically forwarded to neighbors. These neighbors then in turn forward it to their neighbors, until the whole network has received the message.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_wHo3Wk05Ya" href="#c_wHo3Wk05Ya" tabindex="-1" role="presentation"></a><span class="cm-keyword">import</span> {<span class="cm-def">everywhere</span>} <span class="cm-keyword">from</span> <span class="cm-string">&quot;./crow-tech&quot;</span>;

<span class="cm-variable">everywhere</span>(<span class="cm-def">nest</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">gossip</span> <span class="cm-operator">=</span> [];
});

<span class="cm-keyword">function</span> <span class="cm-def">sendGossip</span>(<span class="cm-def">nest</span>, <span class="cm-def">message</span>, <span class="cm-def">exceptFor</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>) {
  <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">gossip</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">message</span>);
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">neighbor</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">neighbor</span> <span class="cm-operator">==</span> <span class="cm-variable-2">exceptFor</span>) <span class="cm-keyword">continue</span>;
    <span class="cm-variable">request</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">neighbor</span>, <span class="cm-string">&quot;gossip&quot;</span>, <span class="cm-variable-2">message</span>);
  }
}

<span class="cm-variable">requestType</span>(<span class="cm-string">&quot;gossip&quot;</span>, (<span class="cm-def">nest</span>, <span class="cm-def">message</span>, <span class="cm-def">source</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">gossip</span>.<span class="cm-property">includes</span>(<span class="cm-variable-2">message</span>)) <span class="cm-keyword">return</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">nest</span>.<span class="cm-property">name</span><span class="cm-string-2">}</span> <span class="cm-string-2">received gossip '${</span>
               <span class="cm-variable-2">message</span><span class="cm-string-2">}</span><span class="cm-string-2">' from ${</span><span class="cm-variable-2">source</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  <span class="cm-variable">sendGossip</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">message</span>, <span class="cm-variable-2">source</span>);
});</pre>

<p><a class="p_ident" id="p_BxJ3gAVNXY" href="#p_BxJ3gAVNXY" tabindex="-1" role="presentation"></a>To avoid sending the same message around the network forever, each nest keeps an array of gossip strings that it has already seen. To define this array, we use the <code>everywhere</code> function—which runs code on every nest—to add a property to the nest’s <code>state</code> object, which is where we’ll keep nest-local state.</p>

<p><a class="p_ident" id="p_iuIpNkZ6Y1" href="#p_iuIpNkZ6Y1" tabindex="-1" role="presentation"></a>When a nest receives a duplicate gossip message, which is very likely to happen with everybody blindly resending them, it ignores it. But when it receives a new message, it excitedly tells all its neighbors except for the one who sent it the message.</p>

<p><a class="p_ident" id="p_Vf87ZzInCt" href="#p_Vf87ZzInCt" tabindex="-1" role="presentation"></a>This will cause a new piece of gossip to spread through the network like an ink stain in water. Even when some connections aren’t currently working, if there is an alternative route to a given nest, the gossip will reach it through there.</p>

<p><a class="p_ident" id="p_vuq8D4aVHG" href="#p_vuq8D4aVHG" tabindex="-1" role="presentation"></a>This style of network communication is called <em>flooding</em>—it floods the network with a piece of information until all nodes have it.</p>

<p><a class="p_ident" id="p_uA2Fs2G7PW" href="#p_uA2Fs2G7PW" tabindex="-1" role="presentation"></a>We can call <code>sendGossip</code> to see a message flow through the village.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_KWBmLZ/aO7" href="#c_KWBmLZ/aO7" tabindex="-1" role="presentation"></a><span class="cm-variable">sendGossip</span>(<span class="cm-variable">bigOak</span>, <span class="cm-string">&quot;Kids with airgun in the park&quot;</span>);</pre>

<h2><a class="h_ident" id="h_qb23G8H5P9" href="#h_qb23G8H5P9" tabindex="-1" role="presentation"></a>Message routing</h2>

<p><a class="p_ident" id="p_DfGu9P/nDx" href="#p_DfGu9P/nDx" tabindex="-1" role="presentation"></a>If a given node wants to talk to a single other node, flooding is not a very efficient approach. Especially when the network is big, that would lead to a lot of useless data transfers.</p>

<p><a class="p_ident" id="p_+/v2WfaNg2" href="#p_+/v2WfaNg2" tabindex="-1" role="presentation"></a>An alternative approach is to set up a way for messages to hop from node to node until they reach their destination. The difficulty with that is it requires knowledge about the layout of the network. To send a request in the direction of a faraway nest, it is necessary to know which neighboring nest gets it closer to its destination. Sending it in the wrong direction will not do much good.</p>

<p><a class="p_ident" id="p_H9F/PkVSom" href="#p_H9F/PkVSom" tabindex="-1" role="presentation"></a>Since each nest knows only about its direct neighbors, it doesn’t have the information it needs to compute a route. We must somehow spread the information about these connections to all nests, preferably in a way that allows it to change over time, when nests are abandoned or new nests are built.</p>

<p><a class="p_ident" id="p_NNmqy7WOzL" href="#p_NNmqy7WOzL" tabindex="-1" role="presentation"></a>We can use flooding again, but instead of checking whether a given message has already been received, we now check whether the new set of neighbors for a given nest matches the current set we have for it.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_68Z9trrpeS" href="#c_68Z9trrpeS" tabindex="-1" role="presentation"></a><span class="cm-variable">requestType</span>(<span class="cm-string">&quot;connections&quot;</span>, (<span class="cm-variable">nest</span>, {<span class="cm-property">name</span>, <span class="cm-property">neighbors</span>},
                            <span class="cm-variable">source</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">let</span> <span class="cm-def">connections</span> <span class="cm-operator">=</span> <span class="cm-variable">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable">JSON</span>.<span class="cm-property">stringify</span>(<span class="cm-variable-2">connections</span>.<span class="cm-property">get</span>(<span class="cm-variable">name</span>)) <span class="cm-operator">==</span>
      <span class="cm-variable">JSON</span>.<span class="cm-property">stringify</span>(<span class="cm-variable">neighbors</span>)) <span class="cm-keyword">return</span>;
  <span class="cm-variable-2">connections</span>.<span class="cm-property">set</span>(<span class="cm-variable">name</span>, <span class="cm-variable">neighbors</span>);
  <span class="cm-variable">broadcastConnections</span>(<span class="cm-variable">nest</span>, <span class="cm-variable">name</span>, <span class="cm-variable">source</span>);
});

<span class="cm-keyword">function</span> <span class="cm-def">broadcastConnections</span>(<span class="cm-def">nest</span>, <span class="cm-def">name</span>, <span class="cm-def">exceptFor</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">neighbor</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">neighbor</span> <span class="cm-operator">==</span> <span class="cm-variable-2">exceptFor</span>) <span class="cm-keyword">continue</span>;
    <span class="cm-variable">request</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">neighbor</span>, <span class="cm-string">&quot;connections&quot;</span>, {
      <span class="cm-property">name</span>,
      <span class="cm-property">neighbors</span>: <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span>.<span class="cm-property">get</span>(<span class="cm-variable-2">name</span>)
    });
  }
}

<span class="cm-variable">everywhere</span>(<span class="cm-def">nest</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Map</span>;
  <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span>.<span class="cm-property">set</span>(<span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>, <span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>);
  <span class="cm-variable">broadcastConnections</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>);
});</pre>

<p><a class="p_ident" id="p_Dpash2ByBo" href="#p_Dpash2ByBo" tabindex="-1" role="presentation"></a>The comparison uses <code>JSON.stringify</code> because <code>==</code>, on objects or arrays, will return true only when the two are the exact same value, which is not what we need here. Comparing the JSON strings is a crude but effective way to compare their content.</p>

<p><a class="p_ident" id="p_qfljgqkp+v" href="#p_qfljgqkp+v" tabindex="-1" role="presentation"></a>The nodes immediately start broadcasting their connections, which should, unless some nests are completely unreachable, quickly give every nest a map of the current network graph.</p>

<p><a class="p_ident" id="p_hDQVurU6rz" href="#p_hDQVurU6rz" tabindex="-1" role="presentation"></a>A thing you can do with graphs is find routes in them, as we saw in <a href="07_robot.html">Chapter 7</a>. If we have a route toward a message’s destination, we know which direction to send it in.</p>

<p><a class="p_ident" id="p_nLh7irC9fa" href="#p_nLh7irC9fa" tabindex="-1" role="presentation"></a>This <code>findRoute</code> function, which greatly resembles the <code>findRoute</code> from <a href="07_robot.html#findRoute">Chapter 7</a>, searches for a way to reach a given node in the network. But instead of returning the whole route, it just returns the next step. That next nest will itself, using its current information about the network, decide where <em>it</em> sends the message.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_BDriUx0MeG" href="#c_BDriUx0MeG" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">findRoute</span>(<span class="cm-def">from</span>, <span class="cm-def">to</span>, <span class="cm-def">connections</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">work</span> <span class="cm-operator">=</span> [{<span class="cm-property">at</span>: <span class="cm-variable-2">from</span>, <span class="cm-property">via</span>: <span class="cm-atom">null</span>}];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">work</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">let</span> {<span class="cm-def">at</span>, <span class="cm-def">via</span>} <span class="cm-operator">=</span> <span class="cm-variable-2">work</span>[<span class="cm-variable-2">i</span>];
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">next</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">connections</span>.<span class="cm-property">get</span>(<span class="cm-variable-2">at</span>) <span class="cm-operator">|</span><span class="cm-operator">|</span> []) {
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">next</span> <span class="cm-operator">==</span> <span class="cm-variable-2">to</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">via</span>;
      <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">work</span>.<span class="cm-property">some</span>(<span class="cm-def">w</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">w</span>.<span class="cm-property">at</span> <span class="cm-operator">==</span> <span class="cm-variable-2">next</span>)) {
        <span class="cm-variable-2">work</span>.<span class="cm-property">push</span>({<span class="cm-property">at</span>: <span class="cm-variable-2">next</span>, <span class="cm-property">via</span>: <span class="cm-variable-2">via</span> <span class="cm-operator">|</span><span class="cm-operator">|</span> <span class="cm-variable-2">next</span>});
      }
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-atom">null</span>;
}</pre>

<p><a class="p_ident" id="p_khShpBYpjP" href="#p_khShpBYpjP" tabindex="-1" role="presentation"></a>Now we can build a function that can send long-distance messages. If the message is addressed to a direct neighbor, it is delivered as usual. If not, it is packaged in an object and sent to a neighbor that is closer to the target, using the <code>&quot;route&quot;</code> request type, which will cause that neighbor to repeat the same behavior.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_qgwq/4PpOq" href="#c_qgwq/4PpOq" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">routeRequest</span>(<span class="cm-def">nest</span>, <span class="cm-def">target</span>, <span class="cm-def">type</span>, <span class="cm-def">content</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>.<span class="cm-property">includes</span>(<span class="cm-variable-2">target</span>)) {
    <span class="cm-keyword">return</span> <span class="cm-variable">request</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">target</span>, <span class="cm-variable-2">type</span>, <span class="cm-variable-2">content</span>);
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">via</span> <span class="cm-operator">=</span> <span class="cm-variable">findRoute</span>(<span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>, <span class="cm-variable-2">target</span>,
                        <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span>);
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">via</span>) <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string-2">`No route to ${</span><span class="cm-variable-2">target</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
    <span class="cm-keyword">return</span> <span class="cm-variable">request</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">via</span>, <span class="cm-string">&quot;route&quot;</span>,
                   {<span class="cm-property">target</span>, <span class="cm-property">type</span>, <span class="cm-property">content</span>});
  }
}

<span class="cm-variable">requestType</span>(<span class="cm-string">&quot;route&quot;</span>, (<span class="cm-def">nest</span>, {<span class="cm-def">target</span>, <span class="cm-def">type</span>, <span class="cm-def">content</span>}) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">return</span> <span class="cm-variable">routeRequest</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">target</span>, <span class="cm-variable-2">type</span>, <span class="cm-variable-2">content</span>);
});</pre>

<p><a class="p_ident" id="p_2KFj5q8DUa" href="#p_2KFj5q8DUa" tabindex="-1" role="presentation"></a>We can now send a message to the nest in the church tower, which is four network hops removed.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_S73i8jJBHA" href="#c_S73i8jJBHA" tabindex="-1" role="presentation"></a><span class="cm-variable">routeRequest</span>(<span class="cm-variable">bigOak</span>, <span class="cm-string">&quot;Church Tower&quot;</span>, <span class="cm-string">&quot;note&quot;</span>,
             <span class="cm-string">&quot;Incoming jackdaws!&quot;</span>);</pre>

<p><a class="p_ident" id="p_T0OvjpGy1d" href="#p_T0OvjpGy1d" tabindex="-1" role="presentation"></a>We’ve constructed several layers of functionality on top of a primitive communication system to make it convenient to use. This is a nice (though simplified) model of how real computer networks work.</p>

<p><a class="p_ident" id="p_BCiG5DVrmR" href="#p_BCiG5DVrmR" tabindex="-1" role="presentation"></a>A distinguishing property of computer networks is that they aren’t reliable—abstractions built on top of them can help, but you can’t abstract away network failure. So network programming is typically very much about anticipating and dealing with failures.</p>

<h2><a class="h_ident" id="h_XvLsfAhtsE" href="#h_XvLsfAhtsE" tabindex="-1" role="presentation"></a>Async functions</h2>

<p><a class="p_ident" id="p_4FwmFfekYV" href="#p_4FwmFfekYV" tabindex="-1" role="presentation"></a>To store important information, crows are known to duplicate it across nests. That way, when a hawk destroys a nest, the information isn’t lost.</p>

<p><a class="p_ident" id="p_QezI5I8rjm" href="#p_QezI5I8rjm" tabindex="-1" role="presentation"></a>To retrieve a given piece of information that it doesn’t have in its own storage bulb, a nest computer might consult random other nests in the network until it finds one that has it.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_QLKv1tpg1i" href="#c_QLKv1tpg1i" tabindex="-1" role="presentation"></a><span class="cm-variable">requestType</span>(<span class="cm-string">&quot;storage&quot;</span>, (<span class="cm-def">nest</span>, <span class="cm-def">name</span>) <span class="cm-operator">=&gt;</span> <span class="cm-variable">storage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>));

<span class="cm-keyword">function</span> <span class="cm-def">findInStorage</span>(<span class="cm-def">nest</span>, <span class="cm-def">name</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">storage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>).<span class="cm-property">then</span>(<span class="cm-def">found</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">found</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">found</span>;
    <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> <span class="cm-variable">findInRemoteStorage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>);
  });
}

<span class="cm-keyword">function</span> <span class="cm-def">network</span>(<span class="cm-def">nest</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">Array</span>.<span class="cm-property">from</span>(<span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span>.<span class="cm-property">keys</span>());
}

<span class="cm-keyword">function</span> <span class="cm-def">findInRemoteStorage</span>(<span class="cm-def">nest</span>, <span class="cm-def">name</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">sources</span> <span class="cm-operator">=</span> <span class="cm-variable">network</span>(<span class="cm-variable-2">nest</span>).<span class="cm-property">filter</span>(<span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>);
  <span class="cm-keyword">function</span> <span class="cm-def">next</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">sources</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
      <span class="cm-keyword">return</span> <span class="cm-variable">Promise</span>.<span class="cm-property">reject</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Not found&quot;</span>));
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">let</span> <span class="cm-def">source</span> <span class="cm-operator">=</span> <span class="cm-variable-2">sources</span>[<span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span>
                                      <span class="cm-variable-2">sources</span>.<span class="cm-property">length</span>)];
      <span class="cm-variable-2">sources</span> <span class="cm-operator">=</span> <span class="cm-variable-2">sources</span>.<span class="cm-property">filter</span>(<span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">source</span>);
      <span class="cm-keyword">return</span> <span class="cm-variable">routeRequest</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">source</span>, <span class="cm-string">&quot;storage&quot;</span>, <span class="cm-variable-2">name</span>)
        .<span class="cm-property">then</span>(<span class="cm-def">value</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">value</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span> <span class="cm-operator">?</span> <span class="cm-variable-2">value</span> : <span class="cm-variable-2">next</span>(),
              <span class="cm-variable-2">next</span>);
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">next</span>();
}</pre>

<p><a class="p_ident" id="p_9ueI22bqmz" href="#p_9ueI22bqmz" tabindex="-1" role="presentation"></a>Because <code>connections</code> is a <code>Map</code>, <code>Object.keys</code> doesn’t work on it. It has a <code>keys</code> <em>method</em>, but that returns an iterator rather than an array. An iterator (or iterable value) can be converted to an array with the <code>Array.from</code> function.</p>

<p><a class="p_ident" id="p_1yDETF9zmK" href="#p_1yDETF9zmK" tabindex="-1" role="presentation"></a>Even with promises this is some rather awkward code. Multiple asynchronous actions are chained together in non-obvious ways. We again need a recursive function (<code>next</code>) to model looping through the nests.</p>

<p><a class="p_ident" id="p_ZdDrrtYpkB" href="#p_ZdDrrtYpkB" tabindex="-1" role="presentation"></a>And the thing the code actually does is completely linear—it always waits for the previous action to complete before starting the next one. In a synchronous programming model, it’d be simpler to express.</p>

<p><a class="p_ident" id="p_YB91K5v8Ro" href="#p_YB91K5v8Ro" tabindex="-1" role="presentation"></a>The good news is that JavaScript allows you to write pseudo-synchronous code to describe asynchronous computation. An <code>async</code> function is a function that implicitly returns a promise and that can, in its body, <code>await</code> other promises in a way that <em>looks</em> synchronous.</p>

<p><a class="p_ident" id="p_+aWABbtzTM" href="#p_+aWABbtzTM" tabindex="-1" role="presentation"></a>We can rewrite <code>findInStorage</code> like this:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_eDKVOF1oo/" href="#c_eDKVOF1oo/" tabindex="-1" role="presentation"></a><span class="cm-keyword">async</span> <span class="cm-keyword">function</span> <span class="cm-def">findInStorage</span>(<span class="cm-def">nest</span>, <span class="cm-def">name</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">local</span> <span class="cm-operator">=</span> <span class="cm-keyword">await</span> <span class="cm-variable">storage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">local</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">local</span>;

  <span class="cm-keyword">let</span> <span class="cm-def">sources</span> <span class="cm-operator">=</span> <span class="cm-variable">network</span>(<span class="cm-variable-2">nest</span>).<span class="cm-property">filter</span>(<span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">sources</span>.<span class="cm-property">length</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">source</span> <span class="cm-operator">=</span> <span class="cm-variable-2">sources</span>[<span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span>
                                    <span class="cm-variable-2">sources</span>.<span class="cm-property">length</span>)];
    <span class="cm-variable-2">sources</span> <span class="cm-operator">=</span> <span class="cm-variable-2">sources</span>.<span class="cm-property">filter</span>(<span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">source</span>);
    <span class="cm-keyword">try</span> {
      <span class="cm-keyword">let</span> <span class="cm-def">found</span> <span class="cm-operator">=</span> <span class="cm-keyword">await</span> <span class="cm-variable">routeRequest</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">source</span>, <span class="cm-string">&quot;storage&quot;</span>,
                                     <span class="cm-variable-2">name</span>);
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">found</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">found</span>;
    } <span class="cm-keyword">catch</span> (<span class="cm-def">_</span>) {}
  }
  <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Not found&quot;</span>);
}</pre>

<p><a class="p_ident" id="p_yJ9vEuqhm9" href="#p_yJ9vEuqhm9" tabindex="-1" role="presentation"></a>An <code>async</code> function is marked by the word <code>async</code> before the <code>function</code> keyword. Methods can also be made <code>async</code> by writing <code>async</code> before their name. When such a function or method is called, it returns a promise. As soon as the body returns something, that promise is resolved. If it throws an exception, the promise is rejected.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_04MPwtOsw6" href="#c_04MPwtOsw6" tabindex="-1" role="presentation"></a><span class="cm-variable">findInStorage</span>(<span class="cm-variable">bigOak</span>, <span class="cm-string">&quot;events on 2017-12-21&quot;</span>)
  .<span class="cm-property">then</span>(<span class="cm-variable">console</span>.<span class="cm-property">log</span>);</pre>

<p><a class="p_ident" id="p_0PWuoWXaWE" href="#p_0PWuoWXaWE" tabindex="-1" role="presentation"></a>Inside an <code>async</code> function, the word <code>await</code> can be put in front of an expression to wait for a promise to resolve and only then continue the execution of the function.</p>

<p><a class="p_ident" id="p_hTH03GxRLH" href="#p_hTH03GxRLH" tabindex="-1" role="presentation"></a>Such a function no longer, like a regular JavaScript function, runs from start to completion in one go. Instead, it can be <em>frozen</em> at any point that has an <code>await</code>, and can be resumed at a later time.</p>

<p><a class="p_ident" id="p_6JNP8vemlA" href="#p_6JNP8vemlA" tabindex="-1" role="presentation"></a>For non-trivial asynchronous code, this notation is usually more convenient than directly using promises. Even if you need to do something that doesn’t fit the synchronous model, such as perform multiple actions at the same time, it is easy to combine <code>await</code> with the direct use of promises.</p>

<h2><a class="h_ident" id="h_o+cFzGGhnz" href="#h_o+cFzGGhnz" tabindex="-1" role="presentation"></a>Generators</h2>

<p><a class="p_ident" id="p_zFhfm+tYq8" href="#p_zFhfm+tYq8" tabindex="-1" role="presentation"></a>This ability of functions to be paused and then resumed again is not exclusive to <code>async</code> functions. JavaScript also has a feature called <em>generator</em> functions. These are similar, but without the promises.</p>

<p><a class="p_ident" id="p_+0474o2QAY" href="#p_+0474o2QAY" tabindex="-1" role="presentation"></a>When you define a function with <code>function*</code> (placing an asterisk after the word <code>function</code>), it becomes a generator. When you call a generator, it returns an iterator, which we already saw in <a href="06_object.html">Chapter 6</a>.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_B4ek89g871" href="#c_B4ek89g871" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span><span class="cm-keyword">*</span> <span class="cm-def">powers</span>(<span class="cm-def">n</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">current</span> <span class="cm-operator">=</span> <span class="cm-variable-2">n</span>;; <span class="cm-variable-2">current</span> <span class="cm-operator">*=</span> <span class="cm-variable-2">n</span>) {
    <span class="cm-keyword">yield</span> <span class="cm-variable-2">current</span>;
  }
}

<span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">power</span> <span class="cm-keyword">of</span> <span class="cm-variable">powers</span>(<span class="cm-number">3</span>)) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">power</span> <span class="cm-operator">&gt;</span> <span class="cm-number">50</span>) <span class="cm-keyword">break</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>);
}
<span class="cm-comment">// → 3</span>
<span class="cm-comment">// → 9</span>
<span class="cm-comment">// → 27</span></pre>

<p><a class="p_ident" id="p_66VAHXEtbn" href="#p_66VAHXEtbn" tabindex="-1" role="presentation"></a>Initially, when you call <code>powers</code>, the function is frozen at its start. Every time you call <code>next</code> on the iterator, the function runs until it hits a <code>yield</code> expression, which pauses it and causes the yielded value to become the next value produced by the iterator. When the function returns (the one in the example never does), the iterator is done.</p>

<p><a class="p_ident" id="p_ck21A7VgZt" href="#p_ck21A7VgZt" tabindex="-1" role="presentation"></a>Writing iterators is often much easier when you use generator functions. The iterator for the <code>Group</code> class (from the exercise in <a href="06_object.html#group_iterator">Chapter 6</a>) can be written with this generator:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_C6OZWjI9EM" href="#c_C6OZWjI9EM" tabindex="-1" role="presentation"></a><span class="cm-variable">Group</span>.<span class="cm-property">prototype</span>[<span class="cm-variable">Symbol</span>.<span class="cm-property">iterator</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span><span class="cm-keyword">*</span>() {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">members</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">yield</span> <span class="cm-keyword">this</span>.<span class="cm-property">members</span>[<span class="cm-variable-2">i</span>];
  }
};</pre>

<p><a class="p_ident" id="p_oMZiyktu3O" href="#p_oMZiyktu3O" tabindex="-1" role="presentation"></a>There’s no longer a need to create an object to hold the iteration state—generators automatically save their local state every time they yield.</p>

<p><a class="p_ident" id="p_YCNJmBl4aF" href="#p_YCNJmBl4aF" tabindex="-1" role="presentation"></a>Such <code>yield</code> expressions may occur only directly in the generator function itself and not in an inner function you define inside of it. The state a generator saves, when yielding, is only its <em>local</em> environment and the position where it yielded.</p>

<p><a class="p_ident" id="p_TnoowE9/OQ" href="#p_TnoowE9/OQ" tabindex="-1" role="presentation"></a>An <code>async</code> function is a special type of generator. It produces a promise when called, which is resolved when it returns (finishes) and rejected when it throws an exception. Whenever it yields (awaits) a promise, the result of that promise (value or thrown exception) is the result of the <code>await</code> expression.</p>

<h2><a class="h_ident" id="h_GXDb0+eMId" href="#h_GXDb0+eMId" tabindex="-1" role="presentation"></a>The event loop</h2>

<p><a class="p_ident" id="p_AfROx8LXEr" href="#p_AfROx8LXEr" tabindex="-1" role="presentation"></a>Asynchronous programs are executed piece by piece. Each piece may start some actions and schedule code to be executed when the action finishes or fails. In between these pieces, the program sits idle, waiting for the next action.</p>

<p><a class="p_ident" id="p_WG0CglTDJj" href="#p_WG0CglTDJj" tabindex="-1" role="presentation"></a>So callbacks are not directly called by the code that scheduled them. If I call <code>setTimeout</code> from within a function, that function will have returned by the time the callback function is called. And when the callback returns, control does not go back to the function that scheduled it.</p>

<p><a class="p_ident" id="p_jb72lBvUWs" href="#p_jb72lBvUWs" tabindex="-1" role="presentation"></a>Asynchronous behavior happens on its own empty function call
stack. This is one of the reasons that, without promises, managing exceptions across asynchronous code is hard. Since each callback starts with a mostly empty stack, your <code>catch</code> handlers won’t be on the stack when they throw an exception.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_UswfjtMHu4" href="#c_UswfjtMHu4" tabindex="-1" role="presentation"></a><span class="cm-keyword">try</span> {
  <span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Woosh&quot;</span>);
  }, <span class="cm-number">20</span>);
} <span class="cm-keyword">catch</span> (<span class="cm-def">_</span>) {
  <span class="cm-comment">// This will not run</span>
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Caught!&quot;</span>);
}</pre>

<p><a class="p_ident" id="p_SHy5RpBOP1" href="#p_SHy5RpBOP1" tabindex="-1" role="presentation"></a>No matter how closely together events—such as timeouts or incoming requests—happen, a JavaScript environment will run only one program at a time. You can think of this as it running a big loop <em>around</em> your program, called the <em>event loop</em>. When there’s nothing to be done, that loop is stopped. But as events come in, they are added to a queue, and their code is executed one after the other. Because no two things run at the same time, slow-running code might delay the handling of other events.</p>

<p><a class="p_ident" id="p_o5sS+xwBLP" href="#p_o5sS+xwBLP" tabindex="-1" role="presentation"></a>This example sets a timeout but then dallies until after the timeout’s intended point of time, causing the timeout to be late.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Xozg9CCvVZ" href="#c_Xozg9CCvVZ" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">start</span> <span class="cm-operator">=</span> <span class="cm-variable">Date</span>.<span class="cm-property">now</span>();
<span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Timeout ran at&quot;</span>, <span class="cm-variable">Date</span>.<span class="cm-property">now</span>() <span class="cm-operator">-</span> <span class="cm-variable">start</span>);
}, <span class="cm-number">20</span>);
<span class="cm-keyword">while</span> (<span class="cm-variable">Date</span>.<span class="cm-property">now</span>() <span class="cm-operator">&lt;</span> <span class="cm-variable">start</span> <span class="cm-operator">+</span> <span class="cm-number">50</span>) {}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Wasted time until&quot;</span>, <span class="cm-variable">Date</span>.<span class="cm-property">now</span>() <span class="cm-operator">-</span> <span class="cm-variable">start</span>);
<span class="cm-comment">// → Wasted time until 50</span>
<span class="cm-comment">// → Timeout ran at 55</span></pre>

<p><a class="p_ident" id="p_OZm6Yhq/Wa" href="#p_OZm6Yhq/Wa" tabindex="-1" role="presentation"></a>Promises always resolve or reject as a new event. Even if a promise is already resolved, waiting for it will cause your callback to run after the current script finishes, rather than right away.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_B4TYo0a2ol" href="#c_B4TYo0a2ol" tabindex="-1" role="presentation"></a><span class="cm-variable">Promise</span>.<span class="cm-property">resolve</span>(<span class="cm-string">&quot;Done&quot;</span>).<span class="cm-property">then</span>(<span class="cm-variable">console</span>.<span class="cm-property">log</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Me first!&quot;</span>);
<span class="cm-comment">// → Me first!</span>
<span class="cm-comment">// → Done</span></pre>

<p><a class="p_ident" id="p_/AFx3XpMr1" href="#p_/AFx3XpMr1" tabindex="-1" role="presentation"></a>In later chapters we’ll see various other types of events that run on the event loop.</p>

<h2><a class="h_ident" id="h_FcctcOqtcF" href="#h_FcctcOqtcF" tabindex="-1" role="presentation"></a>Asynchronous bugs</h2>

<p><a class="p_ident" id="p_7G3I/OEwrS" href="#p_7G3I/OEwrS" tabindex="-1" role="presentation"></a>When your program runs synchronously, in a single go, there are no state changes happening except those that the program itself makes. For asynchronous programs this is different—they may have <em>gaps</em> in their execution during which other code can run.</p>

<p><a class="p_ident" id="p_IHtlm+p6vM" href="#p_IHtlm+p6vM" tabindex="-1" role="presentation"></a>Let’s look at an example. One of the hobbies of our crows is to count the number of chicks that hatch throughout the village every year. Nests store this count in their storage bulbs. The following code tries to enumerate the counts from all the nests for a given year:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_IMqeevTorV" href="#c_IMqeevTorV" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">anyStorage</span>(<span class="cm-def">nest</span>, <span class="cm-def">source</span>, <span class="cm-def">name</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">source</span> <span class="cm-operator">==</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>) <span class="cm-keyword">return</span> <span class="cm-variable">storage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>);
  <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> <span class="cm-variable">routeRequest</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">source</span>, <span class="cm-string">&quot;storage&quot;</span>, <span class="cm-variable-2">name</span>);
}

<span class="cm-keyword">async</span> <span class="cm-keyword">function</span> <span class="cm-def">chicks</span>(<span class="cm-def">nest</span>, <span class="cm-def">year</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">list</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;&quot;</span>;
  <span class="cm-keyword">await</span> <span class="cm-variable">Promise</span>.<span class="cm-property">all</span>(<span class="cm-variable">network</span>(<span class="cm-variable-2">nest</span>).<span class="cm-property">map</span>(<span class="cm-keyword">async</span> <span class="cm-def">name</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable-2">list</span> <span class="cm-operator">+=</span> <span class="cm-string-2">`${</span><span class="cm-variable-2">name</span><span class="cm-string-2">}</span><span class="cm-string-2">: ${</span>
      <span class="cm-keyword">await</span> <span class="cm-variable">anyStorage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>, <span class="cm-string-2">`chicks in ${</span><span class="cm-variable-2">year</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>)
    <span class="cm-string-2">}</span><span class="cm-string-2">\n`</span>;
  }));
  <span class="cm-keyword">return</span> <span class="cm-variable-2">list</span>;
}</pre>

<p><a class="p_ident" id="p_0pgRtcGBdP" href="#p_0pgRtcGBdP" tabindex="-1" role="presentation"></a>The <code>async name =&gt;</code> part shows that arrow functions can also be made <code>async</code> by putting the word <code>async</code> in front of them.</p>

<p><a class="p_ident" id="p_KHzN+dp1hs" href="#p_KHzN+dp1hs" tabindex="-1" role="presentation"></a>The code doesn’t immediately look suspicious...it maps the <code>async</code> arrow function over the set of nests, creating an array of promises, and then uses <code>Promise.all</code> to wait for all of these before returning the list they build up.</p>

<p><a class="p_ident" id="p_TdSgPYi+yD" href="#p_TdSgPYi+yD" tabindex="-1" role="presentation"></a>But it is seriously broken. It’ll always return only a single line of output, listing the nest that was slowest to respond.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_GWIpudJZ4o" href="#c_GWIpudJZ4o" tabindex="-1" role="presentation"></a><span class="cm-variable">chicks</span>(<span class="cm-variable">bigOak</span>, <span class="cm-number">2017</span>).<span class="cm-property">then</span>(<span class="cm-variable">console</span>.<span class="cm-property">log</span>);</pre>

<p><a class="p_ident" id="p_Dvt4nbkZZR" href="#p_Dvt4nbkZZR" tabindex="-1" role="presentation"></a>Can you work out why?</p>

<p><a class="p_ident" id="p_vdkIPINyQy" href="#p_vdkIPINyQy" tabindex="-1" role="presentation"></a>The problem lies in the <code>+=</code> operator, which takes the <em>current</em> value of <code>list</code> at the time where the statement starts executing and then, when the <code>await</code> finishes, sets the <code>list</code> binding to be that value plus the added string.</p>

<p><a class="p_ident" id="p_faVxxgg3dQ" href="#p_faVxxgg3dQ" tabindex="-1" role="presentation"></a>But between the time where the statement starts executing and the time where it finishes there’s an asynchronous gap. The <code>map</code> expression runs before anything has been added to the list, so each of the <code>+=</code> operators starts from an empty string and ends up, when its storage retrieval finishes, setting <code>list</code> to a single-line list—the result of adding its line to the empty string.</p>

<p><a class="p_ident" id="p_WrnTDweOkP" href="#p_WrnTDweOkP" tabindex="-1" role="presentation"></a>This could have easily been avoided by returning the lines from the mapped promises and calling <code>join</code> on the result of <code>Promise.all</code>, instead of building up the list by changing a binding. As usual, computing new values is less error-prone than changing existing values.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_gkD231Soao" href="#c_gkD231Soao" tabindex="-1" role="presentation"></a><span class="cm-keyword">async</span> <span class="cm-keyword">function</span> <span class="cm-def">chicks</span>(<span class="cm-def">nest</span>, <span class="cm-def">year</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">lines</span> <span class="cm-operator">=</span> <span class="cm-variable">network</span>(<span class="cm-variable-2">nest</span>).<span class="cm-property">map</span>(<span class="cm-keyword">async</span> <span class="cm-def">name</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">name</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;: &quot;</span> <span class="cm-operator">+</span>
      <span class="cm-keyword">await</span> <span class="cm-variable">anyStorage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>, <span class="cm-string-2">`chicks in ${</span><span class="cm-variable-2">year</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  });
  <span class="cm-keyword">return</span> (<span class="cm-keyword">await</span> <span class="cm-variable">Promise</span>.<span class="cm-property">all</span>(<span class="cm-variable-2">lines</span>)).<span class="cm-property">join</span>(<span class="cm-string">&quot;\n&quot;</span>);
}</pre>

<p><a class="p_ident" id="p_7XYZHth7ax" href="#p_7XYZHth7ax" tabindex="-1" role="presentation"></a>Mistakes like this are easy to make, especially when using <code>await</code>, and you should be aware of where the gaps in your code occur. An advantage of JavaScript’s <em>explicit</em> asynchronicity (whether through callbacks, promises, or <code>await</code>) is that spotting these gaps is relatively easy.</p>

<h2><a class="h_ident" id="h_ErccPg/l98" href="#h_ErccPg/l98" tabindex="-1" role="presentation"></a>Summary</h2>

<p><a class="p_ident" id="p_MoVe59fjo8" href="#p_MoVe59fjo8" tabindex="-1" role="presentation"></a>Asynchronous programming makes it possible to express waiting for long-running actions without freezing the program during these actions. JavaScript environments typically implement this style of programming using callbacks, functions that are called when the actions complete. An event loop schedules such callbacks to be called when appropriate, one after the other, so that their execution does not overlap.</p>

<p><a class="p_ident" id="p_8QVLsE1w4k" href="#p_8QVLsE1w4k" tabindex="-1" role="presentation"></a>Programming asynchronously is made easier by promises, objects that represent actions that might complete in the future, and <code>async</code> functions, which allow you to write an asynchronous program as if it were synchronous.</p>

<h2><a class="h_ident" id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe" tabindex="-1" role="presentation"></a>Exercises</h2>

<h3><a class="i_ident" id="i_UvyahfUnfl" href="#i_UvyahfUnfl" tabindex="-1" role="presentation"></a>Tracking the scalpel</h3>

<p><a class="p_ident" id="p_x4s0mGpqFW" href="#p_x4s0mGpqFW" tabindex="-1" role="presentation"></a>The village crows own an old scalpel that they occasionally use on special missions—say, to cut through screen doors or packaging. To be able to quickly track it down, every time the scalpel is moved to another nest, an entry is added to the storage of both the nest that had it and the nest that took it, under the name <code>&quot;scalpel&quot;</code>, with its new location as the value.</p>

<p><a class="p_ident" id="p_X85b03YAMx" href="#p_X85b03YAMx" tabindex="-1" role="presentation"></a>This means that finding the scalpel is a matter of following the breadcrumb trail of storage entries, until you find a nest where that points at the nest itself.</p>

<p><a class="p_ident" id="p_pGzF+NquWH" href="#p_pGzF+NquWH" tabindex="-1" role="presentation"></a>Write an <code>async</code> function <code>locateScalpel</code> that does this, starting at the nest on which it runs. You can use the <code>anyStorage</code> function defined earlier to access storage in arbitrary nests. The scalpel has been going around long enough that you may assume that every nest has a <code>&quot;scalpel&quot;</code> entry in its data storage.</p>

<p><a class="p_ident" id="p_kCIUGPuKAV" href="#p_kCIUGPuKAV" tabindex="-1" role="presentation"></a>Next, write the same function again without using <code>async</code> and <code>await</code>.</p>

<p><a class="p_ident" id="p_rIlnOS1Bz0" href="#p_rIlnOS1Bz0" tabindex="-1" role="presentation"></a>Do request failures properly show up as rejections of the returned promise in both versions? How?</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_YnFVXk9tRo" href="#c_YnFVXk9tRo" tabindex="-1" role="presentation"></a><span class="cm-keyword">async</span> <span class="cm-keyword">function</span> <span class="cm-def">locateScalpel</span>(<span class="cm-def">nest</span>) {
  <span class="cm-comment">// Your code here.</span>
}

<span class="cm-keyword">function</span> <span class="cm-def">locateScalpel2</span>(<span class="cm-def">nest</span>) {
  <span class="cm-comment">// Your code here.</span>
}

<span class="cm-variable">locateScalpel</span>(<span class="cm-variable">bigOak</span>).<span class="cm-property">then</span>(<span class="cm-variable">console</span>.<span class="cm-property">log</span>);
<span class="cm-comment">// → Butcher Shop</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_HBYJhQLRh0" href="#p_HBYJhQLRh0" tabindex="-1" role="presentation"></a>This can be done with a single loop that searches through the nests, moving forward to the next when it finds a value that doesn’t match the current nest’s name and returning the name when it finds a matching value. In the <code>async</code> function, a regular <code>for</code> or <code>while</code> loop can be used.</p>

<p><a class="p_ident" id="p_dvm1OVOM4s" href="#p_dvm1OVOM4s" tabindex="-1" role="presentation"></a>To do the same in a plain function, you will have to build your loop using a recursive function. The easiest way to do this is to have that function return a promise by calling <code>then</code> on the promise that retrieves the storage value. Depending on whether that value matches the name of the current nest, the handler returns that value or a further promise created by calling the loop function again.</p>

<p><a class="p_ident" id="p_4zv80GXYD/" href="#p_4zv80GXYD/" tabindex="-1" role="presentation"></a>Don’t forget to start the loop by calling the recursive function once from the main function.</p>

<p><a class="p_ident" id="p_h9Yrbo5Eju" href="#p_h9Yrbo5Eju" tabindex="-1" role="presentation"></a>In the <code>async</code> function, rejected promises are converted to exceptions by <code>await</code>. When an <code>async</code> function throws an exception, its promise is rejected. So that works.</p>

<p><a class="p_ident" id="p_GEDOzip0j2" href="#p_GEDOzip0j2" tabindex="-1" role="presentation"></a>If you implemented the non-<code>async</code> function as outlined earlier, the way <code>then</code> works also automatically causes a failure to end up in the returned promise. If a request fails, the handler passed to <code>then</code> isn’t called, and the promise it returns is rejected with the same reason.</p>

</div></div>

<h3><a class="i_ident" id="i_Ug+Dv9Mmsw" href="#i_Ug+Dv9Mmsw" tabindex="-1" role="presentation"></a>Building Promise.all</h3>

<p><a class="p_ident" id="p_V49Fgs6t/I" href="#p_V49Fgs6t/I" tabindex="-1" role="presentation"></a>Given an array of promises, <code>Promise.all</code> returns a promise that waits for all of the promises in the array to finish. It then succeeds, yielding an array of result values. If a promise in the array fails, the promise returned by <code>all</code> fails too, with the failure reason from the failing promise.</p>

<p><a class="p_ident" id="p_D4i3Qt21e7" href="#p_D4i3Qt21e7" tabindex="-1" role="presentation"></a>Implement something like this yourself as a regular function called <code>Promise_all</code>.</p>

<p><a class="p_ident" id="p_pUBmweFzla" href="#p_pUBmweFzla" tabindex="-1" role="presentation"></a>Remember that after a promise has succeeded or failed, it can’t succeed or fail again, and further calls to the functions that resolve it are ignored. This can simplify the way you handle failure of your promise.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_70Eq9i3rpH" href="#c_70Eq9i3rpH" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">Promise_all</span>(<span class="cm-def">promises</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>((<span class="cm-def">resolve</span>, <span class="cm-def">reject</span>) <span class="cm-operator">=&gt;</span> {
    <span class="cm-comment">// Your code here.</span>
  });
}

<span class="cm-comment">// Test code.</span>
<span class="cm-variable">Promise_all</span>([]).<span class="cm-property">then</span>(<span class="cm-def">array</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;This should be []:&quot;</span>, <span class="cm-variable-2">array</span>);
});
<span class="cm-keyword">function</span> <span class="cm-def">soon</span>(<span class="cm-def">val</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>(<span class="cm-def">resolve</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">resolve</span>(<span class="cm-variable-2">val</span>), <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">500</span>);
  });
}
<span class="cm-variable">Promise_all</span>([<span class="cm-variable">soon</span>(<span class="cm-number">1</span>), <span class="cm-variable">soon</span>(<span class="cm-number">2</span>), <span class="cm-variable">soon</span>(<span class="cm-number">3</span>)]).<span class="cm-property">then</span>(<span class="cm-def">array</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;This should be [1, 2, 3]:&quot;</span>, <span class="cm-variable-2">array</span>);
});
<span class="cm-variable">Promise_all</span>([<span class="cm-variable">soon</span>(<span class="cm-number">1</span>), <span class="cm-variable">Promise</span>.<span class="cm-property">reject</span>(<span class="cm-string">&quot;X&quot;</span>), <span class="cm-variable">soon</span>(<span class="cm-number">3</span>)])
  .<span class="cm-property">then</span>(<span class="cm-def">array</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;We should not get here&quot;</span>);
  })
  .<span class="cm-property">catch</span>(<span class="cm-def">error</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span> <span class="cm-operator">!=</span> <span class="cm-string">&quot;X&quot;</span>) {
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Unexpected failure:&quot;</span>, <span class="cm-variable-2">error</span>);
    }
  });</pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_zV4HNd52Ay" href="#p_zV4HNd52Ay" tabindex="-1" role="presentation"></a>The function passed to the <code>Promise</code> constructor will have to call <code>then</code> on each of the promises in the given array. When one of them succeeds, two things need to happen. The resulting value needs to be stored in the correct position of a result array, and we must check whether this was the last pending promise and finish our own promise if it was.</p>

<p><a class="p_ident" id="p_oMTLkDbIsp" href="#p_oMTLkDbIsp" tabindex="-1" role="presentation"></a>The latter can be done with a counter that is initialized to the length of the input array and from which we subtract 1 every time a promise succeeds. When it reaches 0, we are done. Make sure you take into account the situation where the input array is empty (and thus no promise will ever resolve).</p>

<p><a class="p_ident" id="p_pVTKGiHusk" href="#p_pVTKGiHusk" tabindex="-1" role="presentation"></a>Handling failure requires some thought but turns out to be extremely simple. Just pass the <code>reject</code> function of the wrapping promise to each of the promises in the array as a <code>catch</code> handler or as a second argument to <code>then</code> so that a failure in one of them triggers the rejection of the whole wrapper promise.</p>

</div></div><nav><a href="10_modules.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="12_language.html" title="next chapter">▶</a></nav>
</article>
