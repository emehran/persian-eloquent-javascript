<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>برنامه‌نویسی ناهمگام :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 11;var sandboxLoadFiles = ["code/crow-tech.js","code/chapter/11_async.js"];</script><script>var clicky_site_ids = clicky_site_ids || []; clicky_site_ids.push(101171577);</script>
  <script async src="//static.getclicky.com/js"></script>

</head>

<article>
<nav><a href="10_modules.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="12_language.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>فصل 11</span>برنامه‌نویسی ناهمگام</h1>

<blockquote>

<p><a class="p_ident" id="p_2jmj7l5rSw" href="#p_2jmj7l5rSw" tabindex="-1" role="presentation"></a>چه کسی می تواند تا ته‌نشین شدن گل‌های آب، شکیبا باشد؟ چه‌کسی می تواند بی‌حرکت بماند تا لحظه‌ی درست عمل فرا برسد؟</p>

<footer>لائودْزی, <cite>دائو ده جینگ</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_11.jpg" alt="Picture of two crows on a branch"></figure>

<p>بخش مرکزی یک کامپیوتر، بخشی که گام‌های اجرای برنامه‌ی ما را بر‌می‌دارد، <em>پردازشگر</em> نامیده می￼ شود. برنامه‌هایی که تا کنون دیده‌ایم از نوعی بوده اند که پردازشگر را تا وقتی که کارشان تمام شود، مشغول نگه می دارند. سرعت اجرا در چیزی مثل یک حلقه که با اعداد سر و کار دارد به میزان زیادی به سرعت پردازشگر ارتباط دارد.</p>

<p>اما خیلی از برنامه‌ها، با چیزهایی غیر از پردازشگر تعامل دارند. به عنوان مثال، ممکن است با کامپیوتری در یک شبکه تعامل داشته باشند یا داده‌ها را از دیسک سخت بخوانند – که خیلی کندتر از گرفتن آن ها از حافظه‌ی اصلی است.</p>

<p>زمانی که اتفاقی این چنینی می افتد، بی کار گذاشتن پردازشگر کار نادرستی است- ممکن است کارهای دیگری وجود داشته باشد که بتوان در آن حین انجام داد. این کار تا حدی توسط سیستم عامل مدیریت می شود که پردازشگر را بین برنامه‌های متعددی که در حال اجرا هستند بکار می گیرد. اما در مواقعی که می‌خواهیم یک برنامه‌ی واحد بتواند در هنگام انتظار برای یک درخواست شبکه به اجرا و پیش‌رفت خود ادامه دهد، از سیستم‌عامل کمکی بر نمی‌آید.</p>

<h2><a class="h_ident" id="h_1leuaMqErl" href="#h_1leuaMqErl" tabindex="-1" role="presentation"></a>ناهمگامی</h2>

<p>در یک مدل برنامه‌نویسی <em>همگام،</em> همه چیز یک به یک اتفاق می افتد. زمانی که تابعی را فراخوانی می کنید که عهده‌دار اجرای کاری طولانی است، تنها بعد از اتمام آن کار و برگرداندن نتیجه‌ی تابع، کنترل به برنامه‌ برمی‌گردد. در حین اجرای تابع، برنامه‌ی شما متوقف خواهد ماند.</p>

<p>در مدل <em>ناهمگام</em> می توان چندین کار را در یک زمان انجام داد. زمانی که کاری را شروع می کنید، برنامه‌ی شما به اجرا ادامه خواهد داد. زمانی که آن کار تمام می شود، برنامه خبردار شده و به نتایج دست خواهد یافت (به عنوان مثال می توان به خواندن اطلاعات از دیسک سخت اشاره کرد).</p>

<p>می توان برنامه‌نویسی همگام و ناهمگام را با یک مثال کوچک مقایسه کرد: برنامه‌ای که از دو منبع در شبکه، اطلاعاتی دریافت می کند و بعد نتایج را با هم ترکیب می کند.</p>

<p>در یک محیط همگام، جایی که درخواست فقط زمانی برمی گردد که کارش را تمام کرده باشد، آسان ترین روش انجام این کار ارسال درخواست ها یکی پس از دیگری است. مشکل این روش این است که درخواست دوم زمانی شروع می شود که درخواست اول تمام شده باشد. جمع زمانی که صرف می شود حداقل برابر است با مجموع زمان پاسخ‌های درخواست ها.</p>

<p><a class="p_ident" id="p_3SG8LH3yFM" href="#p_3SG8LH3yFM" tabindex="-1" role="presentation"></a>راه حل این مسئله، در یک سیستم همگام، استفاده از نخ‌های (threads) اضافی کنترل است. یک <em>thread</em> یک برنامه‌ی دیگر است که در حال اجرا است که اجرای آن ممکن است توسط سیستم عامل بین برنامه‌های دیگر قرار گیرد – چون بیشتر کامپیوترهای مدرن دارای چندین پردازشگر هستند، چندین thread را می توان در یک آن روی پردازشگرها اجرا کرد. یک thread دیگر می تواند درخواست دوم را شروع کند و سپس هر دوی thread ها￼ منتظر نتیجه‌ی درخواستشان می مانند که بعد از آن دوباره همگام شده و نتایج را باهم ترکیب می کنند.</p>

<p><a class="p_ident" id="p_woPjde2M6/" href="#p_woPjde2M6/" tabindex="-1" role="presentation"></a>در نمودار پیش رو، خطوط درشت نمایانگر زمانی است که برنامه سپری می کند تا در حالت نرمال اجرا شود، و خطوط باریک نشانگر زمانی است که برای پاسخ شبکه صرف می شود. در مدل همگام، زمانی که توسط شبکه گرفته می شود به عنوان بخشی از جدول زمانی برای thread داده شده محسوب می شود. در مدل ناهمگام، شروع یک عملیات مرتبط با شبکه، به طور مفهومی باعث ایجاد یک انشعاب در جدول زمانی می شود. برنامه‌ای که این انشعاب را شروع کرده است به اجرای خود ادامی می دهد، و آن عملیات به موازات آن انجام می شود و وقتی پایان یافت برنامه را باخبر می کند.</p><figure><img src="img/control-io.svg" alt="Control flow for synchronous and asynchronous programming"></figure>

<p>راه دیگری که می توان با آن تفاوت این دو را بیان کرد این است که در مدل همگام، انتظار برای پایان درخواست‌ها به صورت ضمنی است در حالیکه در مدل ناهمگام صریح و تحت کنترل ما می‌باشد.</p>

<p>ناهمگامی مثل چاقوی دولبه است. برای برنامه‌هایی که مناسب اجرای مستقیم خطی نیستند کار را ساده تر می کند اما در عین حال می تواند برای برنامه هایی که به صورت مستقیم خطی اجرا می شوند نامناسب باشد. در ادامه این فصل با راه‌هایی برای حل این ناهمگونی آشنا خواهیم شد.</p>

<p><a class="p_ident" id="p_DJSgOGbrf5" href="#p_DJSgOGbrf5" tabindex="-1" role="presentation"></a>هر دو پلتفرم مهم برنامه‌نویسی جاوااسکریپت – مرورگرها و <bdo>Node.js</bdo> – عملیاتی که ممکن است زمانگیر باشند را به صورت ناهمگام اجرا می کنند و از نخ‌ها (threads) استفاده نمی کنند. به دلیل اینکه برنامه‌نویسی روی thread ها کار سختی محسوب می شود (در این نوع برنامه‌نویسی درک کارکرد برنامه، به دلیل انجام چند کار در آن واحد بسیار سخت‌تر می شود)، روش ناهمگام عموما چیز خوبی محسوب می شود.</p>

<h2><a class="h_ident" id="h_zUZJr7Lzut" href="#h_zUZJr7Lzut" tabindex="-1" role="presentation"></a>فناوری کلاغ‌ها</h2>

<p>خیلی از مردم می‌دانند که کلاغ‌ها پرنده‌هایی بسیار باهوش هستند. آن ها می توانند از ابزار استفاده کنند، برای آینده برنامه ریزی کنند، چیزهایی را به خاطر بسپارند و حتی این موارد را با هم به اشتراک بگذارند.</p>

<p>چیزی که بیشتر مردم از آن آگاه نیستند این است که کلاغ‌ها توانایی های زیادی دارند که از دید ما مخفی می کنند. یکی از متخصصین مشهور (و کمی عجیب و غریب) کلاغ‌ها به من گفت که فناوری کلاغ خیلی از فناوری انسان عقب نیست و به زودی به انسان ها می‌رسند.</p>

<p>به عنوان مثال، نهاد‌های زیادی بین کلاغ‌ها وجود دارد که توانایی ساخت وسایل محاسباتی را دارند. این وسایل شبیه وسایل محاسباتی انسان‌ها، الکترونیکی نیستند بلکه از رفتارهای حشراتی کوچک، گونه‌هایی نزدیک به موریانه￼ که یک رابطه‌ی همزیستی با کلاغ ها توسعه داده اند، بهره برداری می کنند. کلاغ‌ها برایشان غذا فراهم می کنند و در عوض حشرات کلنی‌های پیچیده‌ی آن ها را ساخته و بکار می اندازند، که به کمک موجودات زنده‌ای که در درون آن ها زندگی می کنند، محاسبات را انجام می دهند.</p>

<p>این گونه کلنی‌ها معمولا در لانه‌های بزرگ و قدیمی قرار دارند. پرنده‌ها و حشرات با همکاری هم شبکه‌ای از ساختارهای گلی پیازی‌شکل را می‌سازند و بین ترک‌های لانه پنهان می کنند که در آن حشرات زندگی و کار خواهند کرد.</p>

<p>برای تعامل با دیگر وسایل،این ماشین‌ها از سیگنال‌های نور استفاده می کنند. کلاغ‌ها قطعاتی از مواد انعکاسی را در ساقه‌های خاصی که برای ارتباط در نظر گرفته شده اند جاسازی می کنند و حشرات آن ها را هدف قرار می دهند تا نور را به لانه‌ی دیگری بتابانند و داده‌ها را به صورت دنباله‌ای از چشمک‌های کوتاه به رمز در می آورند. این یعنی فقط لانه‌هایی که دارای یک ارتباط متصل بصری هستند می توانند با یکدیگر تعامل کنند.</p>

<p><a class="p_ident" id="p_cCgxPRsF1V" href="#p_cCgxPRsF1V" tabindex="-1" role="presentation"></a>دوست متخصص کلاغ ما نقشه‌ای از شبکه‌ی لانه‌های کلاغ‌ها در روستای <bdo>Hières-sur-Amby</bdo> قرار دارد، کشیده است که در حاشیه‌ی رودخانه‌ی Rhône قرار دارد. آن نقشه نشان می دهد که لانه‌ها و ارتباطاتشان چگونه است:</p><figure><img src="img/Hieres-sur-Amby.png" alt="A network of crow nests in a small village"></figure>

<p>در نمونه‌ای شگفت‌انگیز از تکامل همگرا، کامپیوترهای کلاغ‌ها، جاوااسکریپت را اجرا می کنند. در این فصل قرار است بعضی از قابلیت‌های پایه‌ای شبکه را برایشان برنامه‌نویسی کنیم.</p>

<h2><a class="h_ident" id="h_mpRFz5EAjK" href="#h_mpRFz5EAjK" tabindex="-1" role="presentation"></a>توابع callback</h2>

<p><a class="p_ident" id="p_jU9HKeneWd" href="#p_jU9HKeneWd" tabindex="-1" role="presentation"></a>یکی از راه‌های برنامه‌نویسی ناهمگام این است توابعی که یک کار زمانگیر را انجام می دهند، یک آرگومان اضافی دریافت کنند، یک تابع callback. در این روش، تابع اصلی اجرا شده و پایان می پذیرد سپس تابع callback با نتایج دریافتی از تابع اصلی فراخوانی می گردد.</p>

<p><a class="p_ident" id="p_Kzh6PibMf8" href="#p_Kzh6PibMf8" tabindex="-1" role="presentation"></a>به عنوان یک مثال، تابع <code>setTimeout</code>، که در <bdo>Node.js</bdo> و مرورگرها در دسترس است، به اندازه‌ی هزارم ثانیه‌ ای که مشخص شده است منتظر می ماند و سپس یک تابع را فراخوانی می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_RyFm7Uoiuv" href="#c_RyFm7Uoiuv" tabindex="-1" role="presentation"></a><span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Tick&quot;</span>), <span class="cm-number">500</span>);</pre>

<p>این انتظار معمولا خیلی کاربردهای مهمی ندارد؛ اما گاهی تواند مفید باشد مانند به‌روز‌رسانی یک انیمیشن یا بررسی طول کشیدن چیزی در برنامه.</p>

<p><a class="p_ident" id="p_tNWze/ephs" href="#p_tNWze/ephs" tabindex="-1" role="presentation"></a>اجرای چندین عمل ناهمگام در یک ردیف با استفاده از توابع callback به این معنا است که شما باید به ارسال توابع جدید برای ادامه‌ی محاسبه بعد از هر عمل ادامه دهید.</p>

<p>بیشتر کامپیوترهای موجود در لانه‌های کلاغ‌ها، دارای یک بافت ذخیره‌سازی بلند مدت می باشند، جاییکه اطلاعات، درون شاخه‌ها حک می شوند و می توان آن ها را بعدا دوباره خواند. حک کردن یا پیدا کردن یک بخش از اطلاعات زمانگیر است بنابراین رابط سیستم ذخیره‌سازی بلند مدت، ناهمگام خواهد بود و از توابع callback استفاده خواهد شد.</p>

<p><a class="p_ident" id="p_KiwPWHDFBj" href="#p_KiwPWHDFBj" tabindex="-1" role="presentation"></a>بافت‌های ذخیره‌سازی، بخش‌های اطلاعات را که به فرمت JSON درآمده اند، تحت نام‌هایی ذخیره می کنند. یک کلاغ ممکن است اطلاعاتی در مورد مخفیگاه‌ غذاها را به عنوان <bdo><code>&quot;food caches&quot;</code></bdo> ذخیره کند، که می تواند دارای آرایه‌ای از نام‌هایی باشد که به دیگر بخش‌های اطلاعات اشاره می نمایند، اطلاعاتی که مخفیگاه واقعی را توصیف می کنند. برای جستجوی یک مخفیگاه غذا در بافت‌های ذخیره‌سازی لانه‌ی <bdo>Big Oak</bdo>، یک کلاغ می تواند کدی مثل زیر را اجرا کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_f7XSZ4G+k8" href="#c_f7XSZ4G+k8" tabindex="-1" role="presentation"></a><span class="cm-keyword">import</span> {<span class="cm-def">bigOak</span>} <span class="cm-keyword">from</span> <span class="cm-string">&quot;./crow-tech&quot;</span>;

<span class="cm-variable">bigOak</span>.<span class="cm-property">readStorage</span>(<span class="cm-string">&quot;food caches&quot;</span>, <span class="cm-def">caches</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">let</span> <span class="cm-def">firstCache</span> <span class="cm-operator">=</span> <span class="cm-variable-2">caches</span>[<span class="cm-number">0</span>];
  <span class="cm-variable">bigOak</span>.<span class="cm-property">readStorage</span>(<span class="cm-variable-2">firstCache</span>, <span class="cm-def">info</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">info</span>);
  });
});</pre>

<p>(تمامی متغیرها و رشته‌ها از زبان کلاغی به زبان انگلیسی ترجمه شده اند.)</p>

<p>این سبک از برنامه‌نویسی شدنی است؛ اما با هر بار عمل ناهمگام، میزان تورفتگی اضافه می شود ،چرا که به یک تابع دیگر نیاز خواهد بود. برای انجام کارهای پیچیده‌تر ، مثل انجام چند عمل در یک زمان واحد، این شیوه‌ی کدنویسی می تواند کمی بدقواره و نامناسب شود.</p>

<p>کامپیوترهای لانه‌ها، طوری ساخته شده اند که بتوانند به وسیله‌ی جفت‌های درخواست-پاسخ با هم ارتباط برقرار کنند. این یعنی یک لانه، پیامی را به لانه‌ی دیگری ارسال می کند، که این لانه نیز بلافاصله پیامی را که حاوی تایید دریافت و احتمالا شامل پاسخی به درخواست است برمی‌گرداند.</p>

<p>هر پیغام توسط یک <em>نوع</em>، برچسب گذاری می شود که تعیین کننده‌ی نحوه‌ی مدیریت آن می باشد. کد ما می تواند توابعی را برای رسیدگی به انواع خاص، تعریف کند، و زمانی که درخواستی از آن نوع آمد ، تابع رسیدگی‌کننده فراخوانی شده تا پاسخی را تولید کند.</p>

<p>رابطی که توسط ماژول <bdo><code>&quot;./<wbr>crow-tech&quot;</code></bdo> صادر می شود، تابعی دارای callback برای تعامل فراهم می کند. لانه‌ها دارای متدی به نام <code>send</code> هستند که درخواست‌ها را ارسال می کند. این متد نام لانه‌ی مقصد، نوع درخواست و محتوای درخواست را به عنوان سه آرگومان اول گرفته و آرگومان بعدی یک تابع است که زمانی که یک پاسخ دریافت می شود، فراخوانی می شود.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_qzWIKDLKSP" href="#c_qzWIKDLKSP" tabindex="-1" role="presentation"></a><span class="cm-variable">bigOak</span>.<span class="cm-property">send</span>(<span class="cm-string">&quot;Cow Pasture&quot;</span>, <span class="cm-string">&quot;note&quot;</span>, <span class="cm-string">&quot;Let's caw loudly at 7PM&quot;</span>,
            () <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Note delivered.&quot;</span>));</pre>

<p>اما برای اینکه لانه‌ها را قادر سازیم تا آن درخواست را دریافت کند، می‌بایست ابتدا نوع درخواستی به نام <code>&quot;note&quot;</code> را تعریف کنیم. کدی که به این درخواست‌ها رسیدگی می کند باید نه تنها بر روی کامپیوتر این لانه اجرا شود بلکه باید روی تمامی لانه‌هایی که می توانند پیامی از این نوع را دریافت کنند اجرا شود. ما فرض می کنیم که کلاغی پرواز کرده و کد ما را روی همه‌ی لانه‌ها نصب می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_38THPHvc7d" href="#c_38THPHvc7d" tabindex="-1" role="presentation"></a><span class="cm-keyword">import</span> {<span class="cm-def">defineRequestType</span>} <span class="cm-keyword">from</span> <span class="cm-string">&quot;./crow-tech&quot;</span>;

<span class="cm-variable">defineRequestType</span>(<span class="cm-string">&quot;note&quot;</span>, (<span class="cm-def">nest</span>, <span class="cm-def">content</span>, <span class="cm-def">source</span>, <span class="cm-def">done</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">nest</span>.<span class="cm-property">name</span><span class="cm-string-2">}</span> <span class="cm-string-2">received note: ${</span><span class="cm-variable-2">content</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  <span class="cm-variable-2">done</span>();
});</pre>

<p>تابع <code>defineRequestType</code> یک نوع درخواست جدید را تعریف می کند. در مثال، امکان پشتیبانی از درخواست‌های <code>&quot;note&quot;</code> اضافه می می‌شود که در واقع تنها یک یادداشت را به لانه‌ی داده شده ارسال می کند. پیاده‌سازی ما، از <bdo><code>console.log</code></bdo> برای تایید رسیدن درخواست استفاده می کند. لانه‌ها دارای خاصیتی به نام <code>name</code> هستند که نامشان را نگه داری می کند.</p>

<p><a class="p_ident" id="p_lEh6rApDCd" href="#p_lEh6rApDCd" tabindex="-1" role="presentation"></a>آرگومان چهارمی که به تابع رسیدگی کننده داده می شود، <code>done</code>، یک تابع callback است که باید زمانی که درخواست کارش تمام شد فراخوانی شود. اگر از مقدار بازگشتی (توسط return) از تابع رسیدگی کننده به عنوان مقدار پاسخ استفاده کرده بودیم ، در این‌صورت رسیدگی‌کننده‌ی درخواست نمی توانست خودش یک عمل ناهمگام را اجرا کند. تابعی که یک کار ناهمگام را انجام می دهد نوعا قبل از انجام آن کار بر‌می‌گردد و برای اجرای تابع callback پس از انجام کار تنظیم می شود. بنابراین ما نیاز به مکانیزم‌هایی ناهمگام داریم – در این مثال، به یک تابع callback دیگر- تا وقتی که یک پاسخ آماده بود، علامت بدهیم.</p>

<p>به شکلی، ناهمگامی مسری است. هر تابعی که یک تابع را فراخوانی کند که به صورت ناهمگام عمل می کند، خودش باید ناهمگام باشد که می توان با استفاده از یک callback یا مکانیزمی شبیه به آن باشد تا نتیجه‌اش را تحویل دهد. فراخوانی یک callback، از برگرداندن یک مقدار به شکل ساده، کمی پیچیده تر و مشکل‌ساز تر است؛ بنابراین استفاده از این روش برای ساختاردهی بخش‌های بزرگی از برنامه‌تان جالب نیست.</p>

<h2><a class="h_ident" id="h_i7gRmvd0TO" href="#h_i7gRmvd0TO" tabindex="-1" role="presentation"></a>Promise ها</h2>

<p>اگر بتوان مفاهیم مجرد را به صورت مقدار‌ها نمایش داد، اغلب درکشان ساده تر می شود. در رابطه با کارهای ناهمگام می توانید به جای تنظیم یک تابع برای فراخوانی در یک نقطه‌ی خاص در آینده، یک شیء را برگردانید که این رخداد آینده را نمایندگی کند.</p>

<p><a class="p_ident" id="p_jC/YRC/GWd" href="#p_jC/YRC/GWd" tabindex="-1" role="presentation"></a>این دقیقا چیزی است که کلاس استاندارد <code>Promise</code> انجام می دهد. یک <em>promise</em> یک عمل ناهمگام است که در زمانی تکمیل می شود و مقداری را تولید می کند. می تواند هرکسی که علاقمند باشد را در زمان آماده شدن مقدارش باخبر کند.</p>

<p><a class="p_ident" id="p_rAjGu7aKrd" href="#p_rAjGu7aKrd" tabindex="-1" role="presentation"></a>آسان ترین روش ایجاد یک promise فراخوانی <bdo><code>Promise.resolve</code></bdo> است. این تابع اطمینان حاصل می کند که مقداری که به آن می دهید درون یک promise قرار می گیرد. اگر خودش از قبل یک promise بود، برگردانده می  شود – در غیر این صورت، شما promise جدیدی دریافت می کنید که با مقدار شما به عنوان نتیجه‌اش بلافاصله پایان می می‌پذیرد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_fzJ7VLwQ/i" href="#c_fzJ7VLwQ/i" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">fifteen</span> <span class="cm-operator">=</span> <span class="cm-variable">Promise</span>.<span class="cm-property">resolve</span>(<span class="cm-number">15</span>);
<span class="cm-variable">fifteen</span>.<span class="cm-property">then</span>(<span class="cm-def">value</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Got ${</span><span class="cm-variable-2">value</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>));
<span class="cm-comment">// → Got 15</span></pre>

<p><a class="p_ident" id="p_Q87nCNSnKu" href="#p_Q87nCNSnKu" tabindex="-1" role="presentation"></a>برای گرفتن نتیجه‌ی یک promise، می توانید از متد <code>then</code> آن استفاده کنید. این متد تابع callbackای را ثبت می کند که در هنگامی که promise به نتیجه رسید و مقداری را تولید کرد، فراخوانی می شود. می توانید چندین تابع callback را به یک promise اضافه کنید، و همه‌ی آن‌ها فراخوانی خواهند شد، حتی اگر آن‌ها را بعد از به نتیجه‌رسیدن promise اضافه کنید.</p>

<p><a class="p_ident" id="p_J2+Ok30Bhh" href="#p_J2+Ok30Bhh" tabindex="-1" role="presentation"></a>اما این همه‌ی آن چیزی نیست که متد <code>then</code> انجام می دهد. این متد promise دیگری را برمی‌گرداند، که مقداری که از تابع رسیدگی کننده برمی گردد را (resolve) را نتیجه‌یابی می کند یا اگر یک promise را برگرداند، برای آن promise منتظر می ماند سپس به حل و فصل نتیجه‌اش می پردازد.</p>

<p><a class="p_ident" id="p_x1wxB3v/ex" href="#p_x1wxB3v/ex" tabindex="-1" role="presentation"></a>خوب است که promiseها را به عنوان وسایلی که مقدارها را به درون فضای ناهمگام انتقال می دهند تصور کنید. یک مقدار نرمال به صورت طبیعی وجود دارد. یک مقدار وعده داده شده (promised value) مقداری است که ممکن است از قبل وجود داشته باشد یا در نقطه‌ای در آینده ظاهر شود. محاسباتی که به عنوان promise تعریف می شوند روی این گونه مقدارها عمل می کنند و همزمان با در دسترس قرار گرفتن مقدارها به اجرا در می آیند.</p>

<p><a class="p_ident" id="p_CZ6CO6EnK8" href="#p_CZ6CO6EnK8" tabindex="-1" role="presentation"></a>برای ایجاد یک promise، می‌توانید از <code>Promise</code> به عنوان یک سازنده استفاده کنید. رابط آن کمی غیرمعمول است – سازنده یک تابع را به عنوان آرگومان می گیرد که آن را بلافاصله فراخوانی می کند و تابعی به آن ارسال می کند که این تابع می تواند برای نتیجه یابی promise استفاده شود. این سازنده به صورتی که گفته شد کار می کند نه مثلا به شکلی که با یک متد ‍<code>resolve</code> کار کند و فقط کدی که promise را ایجاد کرده بتواند آن را نتیجه‌یابی کند.</p>

<p>این روشی است که می توانید برای ایجاد یک رابط مبتنی بر promise برای تابع <code>readStorage</code> ایجاد کنید:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_gYXlRtzMyd" href="#c_gYXlRtzMyd" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">storage</span>(<span class="cm-def">nest</span>, <span class="cm-def">name</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>(<span class="cm-def">resolve</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable-2">nest</span>.<span class="cm-property">readStorage</span>(<span class="cm-variable-2">name</span>, <span class="cm-def">result</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">resolve</span>(<span class="cm-variable-2">result</span>));
  });
}

<span class="cm-variable">storage</span>(<span class="cm-variable">bigOak</span>, <span class="cm-string">&quot;enemies&quot;</span>)
  .<span class="cm-property">then</span>(<span class="cm-def">value</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Got&quot;</span>, <span class="cm-variable-2">value</span>));</pre>

<p><a class="p_ident" id="p_AJNl7eWKVe" href="#p_AJNl7eWKVe" tabindex="-1" role="presentation"></a>این تابع ناهمگام یک مقدار معنادار را تولید می کند. این مزیت اصلی promise ها است – آن ها استفاده از توابع ناهمگام را ساده می کنند. به جای اینکه مجبور باشیم callbackهای متعددی ارسال کنیم، توابع مبتنی بر promise￼ شبیه توابع معمولی به نظر می رسند: ورودی ها را به عنوان آرگومان می گیرند و خروجی شان را تولید می کنند. تنها تفاوت این است که خروجی ممکن است هنوز در دسترس نباشد.</p>

<h2><a class="h_ident" id="h_C1ZTsB+NFB" href="#h_C1ZTsB+NFB" tabindex="-1" role="presentation"></a>شکست</h2>

<p>محاسبات عادی جاوااسکریپت می توانند با شکست روبرو شده و یک استثنا را تولید کنند. محاسبات ناهمگام هم اغلب به چیزی شبیه به آن نیاز دارند. ممکن است یک درخواست در شبکه با شکست روبرو شود یا کدی که بخشی از یک محاسبه‌ی ناهمگام است استثنایی را تولید کند.</p>

<p>یکی از حیاتی‌ترین مشکلاتی که در سبک مبتنی بر callback برنامه‌نویسی ناهمگام وجود دارد این است که در این سبک، گزارش صحیح شکست‌ها به توابع callback بسیار دشوار است.</p>

<p>یکی از راه حل های رایج برای آن این است که آرگومان اول callback را برای مشخص کردن شکست عمل در نظر می گیرند و دومین آرگومان، حاوی مقداری خواهد بود که در صورت موفقیت عمل، تولید می شود. این گونه توابع callback باید همیشه بررسی کنند که آیا استثنایی دریافت کرده اند یا خیر و اطمینان حاصل کنند که هر مشکلی که ایجاد می کنند، مانند استثناهای تولیدی توسط توابعی که فراخوانی می‌کنند، مدیریت شده و به تابع درستی داده می شود.</p>

<p><a class="p_ident" id="p_EbZSDdu4h/" href="#p_EbZSDdu4h/" tabindex="-1" role="presentation"></a>promiseها این کار را ساده تر کرده اند. می توان آن ها را resolve (نتیجه یابی ) کرد (عمل با موفقیت به پایان رسیده) یا رد (reject) کرد (شکست خورده است). توابع رسیدگی کننده به موفقیت (که با متد <code>then</code> ثبت شده اند) فقط زمانی فراخوانی می شوند که عمل باموفقیت انجام شده باشد و rejectها به صورت خودکار به یک promise جدید سپرده‌ می شوند که توسط <code>then</code> برگردانده می شود. و زمانی که یک تابع گرداننده (handler) استثنا تولید می کند، این به طور خودکار سبب می شود که promise ای که توسط فراخوانی متد thenاش تولید شده است رد بشود. بنابراین اگر یکی از عناصری که در زنجیره‌ی اعمال ناهمگام قرار دارد با شکست روبرو شود، خروجی تمام زنجیره به عنوان “رد شده” یا rejected در نظر گرفته می شود، و هیچ تابع گرداننده‌ی دیگری بعد از نقطه‌ای که با مشکل روبرو شده است فراخوانی نمی شود.</p>

<p>بسیار شبیه به نتیجه‌یابی یک promise که مقداری را فراهم می ساخت، رد شدن آن نیز مقداری را فراهم می کند، که معمولا به عنوان دلیل رد شدن شناخته می شود. زمانی که یک استثنا در یک تابع گرداننده باعث رد شدن می شود، مقدار استثنا به عنوان دلیل استفاده می شود. به طور مشابه زمانی که یک گرداننده، یک promise را برمی گرداند که رد شده است، این پذیرفته‌نشدن به درون promise بعدی جریان می یابد. تابعی به نام <bdo><code>Promise.reject</code></bdo> وجود دارد که یک promise رد شده جدید بلافاصله ایجاد می کند.</p>

<p>رای رسیدگی صریح به این گونه رد شدن‌ها، promise ها دارای متدی به نام <code>catch</code> هستند که یک گرداننده را برای￼ فراخوانی در هنگام رد شدن ثبت می کند، شبیه به گرداننده‌های <code>then</code> که در موارد یافتن نتیجه صحیح استفاده می شدند. از این لحاظ نیز بسیار شبیه به <code>then</code> است که یک promise جدید برمی گرداند که در صورت نتیجه‌یابی بدون مشکل به نتیجه‌ی promise اصلی منجر می شود و در غیر این صورت به نتیجه‌ی گرداننده‌ی <code>catch</code>. اگر یک گرداننده‌ی <code>catch</code> خطایی تولید کند، promise جدید نیز رد می شود.</p>

<p>به عنوان یک راه خلاصه تر، متد <code>then</code> همچنین یک گرداننده‌ی عدم پذیرش نیز به عنوان آرگومان دوم قبول می کند، بنابراین می توانید هر دوی گرداننده‌ها را با یک فراخوانی متد ثبت کنید.</p>

<p><a class="p_ident" id="p_r46r7g/dRF" href="#p_r46r7g/dRF" tabindex="-1" role="presentation"></a>تابعی که به سازنده‌ی <code>Promise</code> ارسال می شود در کنار تابع موفقیت (resolve) آرگومان دومی را دریافت می کند، که می تواند برای رد کردن promise جدید استفاده شود.</p>

<p>زنجیره‌ی مقدارهای promise که با فراخوانی‌هایی که به <code>then</code> و <code>catch</code> زده شده است تولید شده را می توان به عنوان یک خط لوله در طول مقدارهای ناهمگام یا حرکت‌های منجر به شکست دانست. به دلیل این که این زنجیره به وسیله‌ی ثبت گرداننده‌ها تولید می شود، هر پیوند دارای یک گرداننده‌ی موفقیت یا عدم پذیرش (یا هر دو) است که به آن ارتباط دارد. گرداننده‌هایی که تطبیقی با نوع خروجی (موفقیت یا شکست) ندارند در نظر گرفته نمی شوند. اما آن هایی که هماهنگ هستند فراخوانی می شوند و خروجی آن ها مشخص می کند چه نوع مقداری در ادامه‌ خواهد آمد – موفقیت در زمانی که یک مقدار غیر promise بر می گرداند، عدم پذیرش زمانی که یک استثنا تولید می شود، و خروجی یک promise زمانی که یکی از آن ها را بر می گرداند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_TOwOnoqIIW" href="#c_TOwOnoqIIW" tabindex="-1" role="presentation"></a><span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>((<span class="cm-def">_</span>, <span class="cm-def">reject</span>) <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">reject</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Fail&quot;</span>)))
  .<span class="cm-property">then</span>(<span class="cm-def">value</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Handler 1&quot;</span>))
  .<span class="cm-property">catch</span>(<span class="cm-def">reason</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Caught failure &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">reason</span>);
    <span class="cm-keyword">return</span> <span class="cm-string">&quot;nothing&quot;</span>;
  })
  .<span class="cm-property">then</span>(<span class="cm-def">value</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Handler 2&quot;</span>, <span class="cm-variable-2">value</span>));
<span class="cm-comment">// → Caught failure Error: Fail</span>
<span class="cm-comment">// → Handler 2 nothing</span></pre>

<p>بسیار شبیه به یک استثنای مدیریت نشده که توسط محیط رسیدگی می شود ، محیط های جاوااسکریپت می توانند تشخیص دهند در چه زمانی یک عدم موفقیت promise رسیدگی نشده است و آن را به عنوان یک خطا گزارش خواهند داد.</p>

<h2><a class="h_ident" id="h_GQZBOQOHOg" href="#h_GQZBOQOHOg" tabindex="-1" role="presentation"></a>شبکه‌ها دشوار هستند</h2>

<p>گاهی اوقات، نور کافی برای سیستم انعکاس نور کلاغ‌ها برای انتقال سیگنال وجود ندارد، یا چیزی مسیر سیگنال را مسدود کرده است. ممکن است سیگنالی فرستاده شود ولی هرگز دریافت نشود.</p>

<p>در این صورت، این باعث می شود که تابع callback ای که به متد <code>send</code> داده شده است هرگز فراخوانی نشود، که احتمالا موجب توقف برنامه بدون هیچ گونه اعلام مشکل می شود. خوب بود اگر بعد از یک دوره‌ی زمانی مشخص شده که پاسخی دریافت نشود، یک درخواست به صورت خودکار منقضی می شد و یک شکست گزارش می شد.</p>

<p>اغلب، شکست های مربوط به ارسال به صورت تصادفی اتفاق می افتند، مانند بروز تداخل بین چراغ جلوی یک خودرو با￼ سیگنال‌های نوری، و در این صورت فقط دوباره فرستان درخواست مشکل را برطرف می کند. بنابراین هنگامی که هنوز در آن نقطه قرار داریم، اجازه بدهید تابع درخواست را طوری تنظیم کنیم که به طور خودکار قبل از اینکه دست از کار بکشد چندین بار درخواست را ارسال کند.</p>

<p><a class="p_ident" id="p_ycn/u9w/t9" href="#p_ycn/u9w/t9" tabindex="-1" role="presentation"></a>و به دلیل اینکه قبول کرده ایم که promise ها مفید هستند، پس تابع درخواست را تغییر می دهیم تا یک promise برگرداند. در رابطه با کاری که می توانند انجام دهند تفاوتی بین callback ها و promise ها وجود‌ ندارد. توابع مبتنی بر callback را می توان پوشاند به شکلی که رابطی promise گونه داشته باشند و همین طور برعکس.</p>

<p>حتی زمانی که یک درخواست و پاسخ آن با موفقیت تحویل داده می شوند، پاسخ ممکن است نشانگر یک شکست باشد – به عنوان مثال، اگر درخواست تلاش کند که از نوع درخواستی استفاده کند که تعریف نشده است یا گرداننده یک خطا تولید کند. برای پشتیبانی از این، <code>send</code> و <code>defineRequestType</code> از قراردادی پیروی می کنند که قبل تر ذکر شد جاییکه اولین آرگومان فرستاده شده با تابع callback، دلیل شکست خواهد بود، در صورت وجود البته، و دومین آرگومان نتیجه‌ی واقعی خواهد بود.</p>

<p><a class="p_ident" id="p_/HAGRiWyCN" href="#p_/HAGRiWyCN" tabindex="-1" role="presentation"></a>این‌ها را می توان به وسیله‌ی یک پوشاننده (wrapper) به پذیرش و عدم پذیرش promise ترجمه کرد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Wg7xZ1po7J" href="#c_Wg7xZ1po7J" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">Timeout</span> <span class="cm-keyword">extends</span> <span class="cm-variable">Error</span> {}

<span class="cm-keyword">function</span> <span class="cm-def">request</span>(<span class="cm-def">nest</span>, <span class="cm-def">target</span>, <span class="cm-def">type</span>, <span class="cm-def">content</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>((<span class="cm-def">resolve</span>, <span class="cm-def">reject</span>) <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">done</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;
    <span class="cm-keyword">function</span> <span class="cm-def">attempt</span>(<span class="cm-def">n</span>) {
      <span class="cm-variable-2">nest</span>.<span class="cm-property">send</span>(<span class="cm-variable-2">target</span>, <span class="cm-variable-2">type</span>, <span class="cm-variable-2">content</span>, (<span class="cm-def">failed</span>, <span class="cm-def">value</span>) <span class="cm-operator">=&gt;</span> {
        <span class="cm-variable-2">done</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;
        <span class="cm-keyword">if</span> (<span class="cm-variable-2">failed</span>) <span class="cm-variable-2">reject</span>(<span class="cm-variable-2">failed</span>);
        <span class="cm-keyword">else</span> <span class="cm-variable-2">resolve</span>(<span class="cm-variable-2">value</span>);
      });
      <span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> {
        <span class="cm-keyword">if</span> (<span class="cm-variable-2">done</span>) <span class="cm-keyword">return</span>;
        <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>) <span class="cm-variable-2">attempt</span>(<span class="cm-variable-2">n</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>);
        <span class="cm-keyword">else</span> <span class="cm-variable-2">reject</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Timeout</span>(<span class="cm-string">&quot;Timed out&quot;</span>));
      }, <span class="cm-number">250</span>);
    }
    <span class="cm-variable-2">attempt</span>(<span class="cm-number">1</span>);
  });
}</pre>

<p><a class="p_ident" id="p_++U4Ouqvnt" href="#p_++U4Ouqvnt" tabindex="-1" role="presentation"></a>به دلیل اینکه promise ها می توانند فقط یک بار موفق شوند (یا رد بشوند)، این روش کار خواهد کرد. اولین باری که <code>resolve</code> یا <code>reject</code> فراخوانی می شوند، خروجی promise را معین می کنند، و هر فراخوانی ای در بعد، مانند timeout که بعد از پایان درخواست می رسد یا درخواستی که بعد از یک پایان یک درخواست دیگر برمی گردد، در نظر گرفته نمی شوند.</p>

<p><a class="p_ident" id="p_rFYXmIrG7W" href="#p_rFYXmIrG7W" tabindex="-1" role="presentation"></a>برای ساخت یک حلقه‌ی ناهمگام، برای تلاش‌های اضافی، لازم است تا از یک تابع بازگشتی استفاده کنیم – یک حلقه‌ی معمولی امکان توقف و صبر برای یک عمل ناهمگام را فراهم نمی کند. تابع <code>attemp</code> یک تلاش واحد برای ارسال یک درخواست ترتیب می دهد. همچنین یک زمان انقضا تنظیم می کند، اگر پاسخی بعد از 250 هزارم ثانیه نیامد ، یا تلاش بعد را شروع کند یا اگر این چهارمین تلاش بود ، promise را رد می‌کند و به عنوان دلیل عدم پذیرش هم یک نمونه از <code>Timeout</code> را استفاده می‌کند.</p>

<p>تلاش مجدد هر یک چهارم ثانیه و توقف در صورت نیامدن پاسخ پس از گذشت یک ثانیه، قطعاً دلخواه است. البته حتی ممکن است که درخواست دریافت شود اما تابع گرداننده کند عمل کند که باعث شود عمل دریافت چندین بار صورت گیرد. ما توابع گرداننده‌ را طوری می نویسیم که این مشکل را پوشش دهیم و پیغام‌های تکراری ضرری برای سیستم نداشته باشند.</p>

<p>طبیعتا قرار نیست که یک شبکه‌ی بی نقص در سطح جهانی را امروز بسازیم. اما قابل قبول خواهد بود- کلاغ‌ها انتظارات خیلی بالایی در رابطه با محاسبات ندارند.</p>

<p><a class="p_ident" id="p_vgWUGmZvWm" href="#p_vgWUGmZvWm" tabindex="-1" role="presentation"></a>برای اینکه خودمان را به طور کامل از callback ها رها کنیم، پیش‌تر خواهیم رفت و همچنین یک پوشش برای تابع <code>defineRequestType</code> تعریف خواهیم کرد که به تابع گرداننده اجازه بدهد تا یک promise یا مقداری ساده را برگرداند و آن را به callback برای ما متصل کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_HejJcHo3dj" href="#c_HejJcHo3dj" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">requestType</span>(<span class="cm-def">name</span>, <span class="cm-def">handler</span>) {
  <span class="cm-variable">defineRequestType</span>(<span class="cm-variable-2">name</span>, (<span class="cm-variable">nest</span>, <span class="cm-variable">content</span>, <span class="cm-variable">source</span>,
                           <span class="cm-variable">callback</span>) <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">try</span> {
      <span class="cm-variable">Promise</span>.<span class="cm-property">resolve</span>(<span class="cm-variable-2">handler</span>(<span class="cm-variable">nest</span>, <span class="cm-variable">content</span>, <span class="cm-variable">source</span>))
        .<span class="cm-property">then</span>(<span class="cm-def">response</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">callback</span>(<span class="cm-atom">null</span>, <span class="cm-variable-2">response</span>),
              <span class="cm-def">failure</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">callback</span>(<span class="cm-variable-2">failure</span>));
    } <span class="cm-keyword">catch</span> (<span class="cm-def">exception</span>) {
      <span class="cm-variable">callback</span>(<span class="cm-variable-2">exception</span>);
    }
  });
}</pre>

<p><bdo><code>Promise.resolve</code></bdo> برای تبدیل مقدار بازگشتی از <code>handler</code> به یک promise استفاده می شود؛ اگر قبلا انجام نشده باشد.</p>

<p><a class="p_ident" id="p_JHm/3YHwce" href="#p_JHm/3YHwce" tabindex="-1" role="presentation"></a>توجه داشته باشید فراخوانی به تابع <code>handler</code> بایستی درون یک بلاک <code>try</code> قرار می گرفت، تا اطمینان حاصل شود هر استثنایی که تولید می کند مستقیما به تابع callback داده می شود. این به خوبی سختی رسیدگی درست به خطاها در مدل callback های خام را نشان می دهد – به راحتی می ممکن است مدیریت صحیح استثناها را فراموش کنیم؛ مانند بالا و اگر این کار را انجام ندهید، شکست‌ها به callback درستی گزارش نمی شوند. در promise ها، این کار را به طور خودکار انجام می می‌شود بنابراین کمتر خطاساز خواهند بود.</p>

<h2><a class="h_ident" id="h_CLoO0aJnUK" href="#h_CLoO0aJnUK" tabindex="-1" role="presentation"></a>مجموعه‌ای از promise ها</h2>

<p>هر کامپیوتر لانه دارای آرایه‌ای از دیگر لانه‌ها می‌باشد که درون محدوده‌ی مخابره قرار دارند و آن را در خاصیت <code>neighbors</code> آن ذخیره می کند. برای بررسی اینکه کدام یک از آن ها در حال حاضر در دسترس هستند، می توانید تابعی بنویسید که تلاش کند تا یک درخواست <code>“ping”</code> (درخواستی که فقط برای دریافت پاسخ ارسال می شود) را به هر یک از لانه ها ارسال کند و مشاهده کنید کدام درخواست پاسخ داده می شود.</p>

<p><a class="p_ident" id="p_ZoxCR+xi/G" href="#p_ZoxCR+xi/G" tabindex="-1" role="presentation"></a>زمانی که با مجموعه‌ای از promise ها کار می کنید که در یک زمان یکسان اجرا می شوند، تابع <bdo><code>Promise.all</code></bdo> می تواند مفید باشد. این تابع یک promise را برمی گرداند که برای همه‌ی promise های درون آرایه صبر می کند تا به نتیجه برسند و بعد نتیجه را درون یک آرایه از مقدارهایی که این promise ها تولید کرده اند می ریزد (به همان ترتیبی که در آرایه‌ی اصلی آمده بودند). اگر یک promise رد شده باشد، نتیجه‌ی <bdo><code>Promise.all</code></bdo> خودش نیز رد می شود.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ZtEtR5AsHV" href="#c_ZtEtR5AsHV" tabindex="-1" role="presentation"></a><span class="cm-variable">requestType</span>(<span class="cm-string">&quot;ping&quot;</span>, () <span class="cm-operator">=&gt;</span> <span class="cm-string">&quot;pong&quot;</span>);

<span class="cm-keyword">function</span> <span class="cm-def">availableNeighbors</span>(<span class="cm-def">nest</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">requests</span> <span class="cm-operator">=</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>.<span class="cm-property">map</span>(<span class="cm-def">neighbor</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">return</span> <span class="cm-variable">request</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">neighbor</span>, <span class="cm-string">&quot;ping&quot;</span>)
      .<span class="cm-property">then</span>(() <span class="cm-operator">=&gt;</span> <span class="cm-atom">true</span>, () <span class="cm-operator">=&gt;</span> <span class="cm-atom">false</span>);
  });
  <span class="cm-keyword">return</span> <span class="cm-variable">Promise</span>.<span class="cm-property">all</span>(<span class="cm-variable-2">requests</span>).<span class="cm-property">then</span>(<span class="cm-def">result</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>.<span class="cm-property">filter</span>((<span class="cm-def">_</span>, <span class="cm-def">i</span>) <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">result</span>[<span class="cm-variable-2">i</span>]);
  });
}</pre>

<p><a class="p_ident" id="p_FykHZel6vX" href="#p_FykHZel6vX" tabindex="-1" role="presentation"></a>زمانی که یک همسایه در دسترس نیست، دوست نداریم که تمامی promise ترکیب شده با شکست روبرو شود، در آن موقع ما هنوز چیزی نمی دانیم. بنابراین تابعی که بر روی مجموعه‌ی همسایه‌ها اعمال شده است تا هر یک از￼ آن ها را به درخواست‌های promise تبدیل کند، گرداننده‌هایی الصاق می کند تا درخواست های موفق <code>true</code> را تولید کنند و رد شده ها <code>false</code> را برگردانند.</p>

<p><a class="p_ident" id="p_cTnz5bc7io" href="#p_cTnz5bc7io" tabindex="-1" role="presentation"></a>در گرداننده‌ای که برای promise ترکیبی در نظر گرفته شده، <code>filter</code> کار حذف آن عناصر، عناصری که مقدار متناظرشان برابر با false باشد را از آرایه‌ی <code>neighbors</code> انجام می‌دهد. این کار از این واقعیت بهره می برد که <code>filter</code> اندیس عنصر فعلی در آرایه‌ را به عنوان آرگومان دومش به تابع فیلترش (مانند <code>map</code>، <code>some</code> یا دیگر توابع رده‌بالای آرایه‌ها که مشابه عمل می کنند) ارسال می کند.</p>

<h2><a class="h_ident" id="h_O1/k+50Gd4" href="#h_O1/k+50Gd4" tabindex="-1" role="presentation"></a>جریان سیل‌گونه در شبکه</h2>

<p>این واقعیت که لانه‌ها فقط می توانند با همسایه‌هایشان ارتباط برقرار کنند در مفید بودن این شبکه مانع ایجاد می کند.</p>

<p>برای رساندن اطلاعات به کل شبکه، یک راه حل این است که نوع درخواستی تنظیم شود که به صورت خودکار به دیگر همسایه‌ها مخابره شود. این همسایه ها سپس آن اطلاعات را به همسایه‌هایشان منتقل می کنند تا زمانی که کل شبکه پیام را گرفته باشد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_wHo3Wk05Ya" href="#c_wHo3Wk05Ya" tabindex="-1" role="presentation"></a><span class="cm-keyword">import</span> {<span class="cm-def">everywhere</span>} <span class="cm-keyword">from</span> <span class="cm-string">&quot;./crow-tech&quot;</span>;

<span class="cm-variable">everywhere</span>(<span class="cm-def">nest</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">gossip</span> <span class="cm-operator">=</span> [];
});

<span class="cm-keyword">function</span> <span class="cm-def">sendGossip</span>(<span class="cm-def">nest</span>, <span class="cm-def">message</span>, <span class="cm-def">exceptFor</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>) {
  <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">gossip</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">message</span>);
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">neighbor</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">neighbor</span> <span class="cm-operator">==</span> <span class="cm-variable-2">exceptFor</span>) <span class="cm-keyword">continue</span>;
    <span class="cm-variable">request</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">neighbor</span>, <span class="cm-string">&quot;gossip&quot;</span>, <span class="cm-variable-2">message</span>);
  }
}

<span class="cm-variable">requestType</span>(<span class="cm-string">&quot;gossip&quot;</span>, (<span class="cm-def">nest</span>, <span class="cm-def">message</span>, <span class="cm-def">source</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">gossip</span>.<span class="cm-property">includes</span>(<span class="cm-variable-2">message</span>)) <span class="cm-keyword">return</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">nest</span>.<span class="cm-property">name</span><span class="cm-string-2">}</span> <span class="cm-string-2">received gossip '${</span>
               <span class="cm-variable-2">message</span><span class="cm-string-2">}</span><span class="cm-string-2">' from ${</span><span class="cm-variable-2">source</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  <span class="cm-variable">sendGossip</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">message</span>, <span class="cm-variable-2">source</span>);
});</pre>

<p><a class="p_ident" id="p_qkpfgSXyNB" href="#p_qkpfgSXyNB" tabindex="-1" role="presentation"></a>برای جلوگیری از ارسال مداوم یک پیام یکسان در شبکه، هر لانه آرایه‌ای از رشته‌هایی که قبلا دیده شده اند را نگه داری می کند. برای تعریف این آرایه، از تابع <code>everywhere</code> استفاده می کنیم – که کد را روی هر لانه اجرا می کند – برای افزودن یک خاصیت به شیء state لانه، که جایی است که ما وضعیت محلی لانه را نگه داری خواهیم کرد.</p>

<p>زمانی که یک لانه یک پیام تکراری را دریافت کند، که احتمالش جایی که هر لانه پیام‌ها را ندید بازارسال می کند وجود دارد، از آن پیام صرف نظر می شود. اما زمانی که پیامی جدید را دریافت می کند، آن پیام را با هیجان به همه‌ی لانه‌ها به جز لانه‌ی فرستنده‌ی پیام، ارسال می کند.</p>

<p>این کار درست مانند پخش شدن جوهر در آب، خبر جدید را در شبکه پخش می کند. حتی زمانی که بعضی از ارتباطات در دسترس نیستند، اگر مسیر جایگزینی به یک لانه‌ی مشخص وجود داشته باشد، خبر از آن طریق به آن لانه خواهد رسید.</p>

<p><a class="p_ident" id="p_COKlrJswvV" href="#p_COKlrJswvV" tabindex="-1" role="presentation"></a>این سبک از ارتباطات شبکه‌ای را سیل‌گونه (flooding) می گویند – مانند سیل تمام شبکه را با اطلاعات فرا‌ می‌گیرد تا این که همه‌ی گره ها را پوشش دهد.</p>

<p>با فراخوانی <code>sendGossip</code> می توانیم جریان پیغام درون روستا را مشاهده کنیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_KWBmLZ/aO7" href="#c_KWBmLZ/aO7" tabindex="-1" role="presentation"></a><span class="cm-variable">sendGossip</span>(<span class="cm-variable">bigOak</span>, <span class="cm-string">&quot;Kids with airgun in the park&quot;</span>);</pre>

<h2><a class="h_ident" id="h_53a+eNWwKU" href="#h_53a+eNWwKU" tabindex="-1" role="presentation"></a>مسیردهی پیام</h2>

<p>اگر یک گره بخواهید با یک گره‌ی مشخص دیگر ارتباط برقرار کند، سبک سیل‌گونه زیاد بهینه عمل نخواهد کرد. مخصوصا زمانی که شبکه بزرگ باشد، که باعث می‌شود میزان زیادی مخابره اطلاعات بدون کاربرد صورت گیرد.</p>

<p>یک راه حل جایگزین این است که برای پیام‌ها راهی در نظر گرفته شود تا از گره‌ای به گره‌های دیگر بپرند تا به گره‌ی مقصد برسند. مشکل این روش این است که بایستی اطلاعاتی در باره‌ی نقشه‌ی شبکه داشته باشیم. برای ارسال درخواستی به سمت یک گره دور، لازم است بدانیم کدام لانه‌های همسایه پیام را به مقصد نزدیک تر می کنند. ارسال آن به سمتی اشتباه مارا به هدف نمی‌رساند.</p>

<p>به دلیل اینکه هر لانه فقط همسایه‌های مجاورش را می‌شناسد، اطلاعات کافی برای محاسبه یک مسیر را در دست ندارد. باید به شیوه‌ای اطلاعات این اتصالات را بین همه‌ی لانه‌ها منتشر کنیم. ترجیحا به روشی که بتوان در آینده در آن تغییر ایجاد کرد مثلا زمانی‌که که یک لانه متروکه می شود یا لانه‌ی جدیدی ساخته می شود.</p>

<p>می توانیم دوباره به سراغ روش سیل‌گونه برویم، اما به جای استفاده از آن برای بررسی دریافت یک پیام، اکنون بررسی می کنیم آیا مجموعه‌ی همسایه‌ها برای یک گره‌ی مشخص با مجموعه‌ای که اکنون برای آن در دسترس داریم مطابقت دارد یا خیر.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_68Z9trrpeS" href="#c_68Z9trrpeS" tabindex="-1" role="presentation"></a><span class="cm-variable">requestType</span>(<span class="cm-string">&quot;connections&quot;</span>, (<span class="cm-variable">nest</span>, {<span class="cm-property">name</span>, <span class="cm-property">neighbors</span>},
                            <span class="cm-variable">source</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">let</span> <span class="cm-def">connections</span> <span class="cm-operator">=</span> <span class="cm-variable">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable">JSON</span>.<span class="cm-property">stringify</span>(<span class="cm-variable-2">connections</span>.<span class="cm-property">get</span>(<span class="cm-variable">name</span>)) <span class="cm-operator">==</span>
      <span class="cm-variable">JSON</span>.<span class="cm-property">stringify</span>(<span class="cm-variable">neighbors</span>)) <span class="cm-keyword">return</span>;
  <span class="cm-variable-2">connections</span>.<span class="cm-property">set</span>(<span class="cm-variable">name</span>, <span class="cm-variable">neighbors</span>);
  <span class="cm-variable">broadcastConnections</span>(<span class="cm-variable">nest</span>, <span class="cm-variable">name</span>, <span class="cm-variable">source</span>);
});

<span class="cm-keyword">function</span> <span class="cm-def">broadcastConnections</span>(<span class="cm-def">nest</span>, <span class="cm-def">name</span>, <span class="cm-def">exceptFor</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">neighbor</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">neighbor</span> <span class="cm-operator">==</span> <span class="cm-variable-2">exceptFor</span>) <span class="cm-keyword">continue</span>;
    <span class="cm-variable">request</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">neighbor</span>, <span class="cm-string">&quot;connections&quot;</span>, {
      <span class="cm-property">name</span>,
      <span class="cm-property">neighbors</span>: <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span>.<span class="cm-property">get</span>(<span class="cm-variable-2">name</span>)
    });
  }
}

<span class="cm-variable">everywhere</span>(<span class="cm-def">nest</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Map</span>;
  <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span>.<span class="cm-property">set</span>(<span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>, <span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>);
  <span class="cm-variable">broadcastConnections</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>);
});</pre>

<p><a class="p_ident" id="p_mWQe772OAF" href="#p_mWQe772OAF" tabindex="-1" role="presentation"></a>در مقایسه از <bdo><code>JSON.stringify</code></bdo> استفاده می شود چرا که <code>==</code>، روی اشیاء و آرایه‌ها، فقط زمانی true برمی گرداند که هر دو طرف دارای مقدار یکسانی باشند، که چیزی نیست که ما در اینجا لازم داریم. مقایسه‌ی رشته‌های JSON جالب به نظر نمی رسد اما روشی موثر برای مقایسه‌ی محتوای آن ها است.</p>

<p>گره‌ها بلافاصله شروع به مخابره‌ی اتصالاتشان می کنند، که باید به سرعت به هر لانه یک نقشه از گراف فعلی شبکه را بدهد، مگر اینکه بعضی از لانه‌ها کلا در دسترس نباشند.</p>

<p>یکی از کارهایی که در گراف‌ها می توان انجام داد پیدا کردن مسیر‌ها در آن‌ها است ، همانطور که در <a href="07_robot.html">فصل 7</a> دیدیم. اگر مسیری به سمت یک مقصد پیام داشته باشیم، می دانیم از کدام جهت باید اقدام به ارسال آن کنیم.</p>

<p>این تابع <code>findRoute</code>، که بسیار شباهت به تابع <code>findRoute</code> <a href="07_robot.html#findRoute">فصل 7</a> دارد، برای رسیدن به یک گره مشخص شده در شبکه به جستجو می پردازد. اما به جای برگرداندن تمام مسیر، فقط گام بعدی را برمی گرداند. لانه‌ی بعدی خودش، از اطلاعات فعلی اش در رابطه با شبکه استفاده خواهد کرد و تصمیم می گیرد که کجا پیغام را بفرستد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_BDriUx0MeG" href="#c_BDriUx0MeG" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">findRoute</span>(<span class="cm-def">from</span>, <span class="cm-def">to</span>, <span class="cm-def">connections</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">work</span> <span class="cm-operator">=</span> [{<span class="cm-property">at</span>: <span class="cm-variable-2">from</span>, <span class="cm-property">via</span>: <span class="cm-atom">null</span>}];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">work</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">let</span> {<span class="cm-def">at</span>, <span class="cm-def">via</span>} <span class="cm-operator">=</span> <span class="cm-variable-2">work</span>[<span class="cm-variable-2">i</span>];
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">next</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">connections</span>.<span class="cm-property">get</span>(<span class="cm-variable-2">at</span>) <span class="cm-operator">|</span><span class="cm-operator">|</span> []) {
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">next</span> <span class="cm-operator">==</span> <span class="cm-variable-2">to</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">via</span>;
      <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">work</span>.<span class="cm-property">some</span>(<span class="cm-def">w</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">w</span>.<span class="cm-property">at</span> <span class="cm-operator">==</span> <span class="cm-variable-2">next</span>)) {
        <span class="cm-variable-2">work</span>.<span class="cm-property">push</span>({<span class="cm-property">at</span>: <span class="cm-variable-2">next</span>, <span class="cm-property">via</span>: <span class="cm-variable-2">via</span> <span class="cm-operator">|</span><span class="cm-operator">|</span> <span class="cm-variable-2">next</span>});
      }
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-atom">null</span>;
}</pre>

<p>اکنون می توانیم تابعی بسازیم که می تواند پیغام‌ها را به نقاط دور ارسال کند. اگر پیام مورد نظر مقصدش یک همسایه‌ی مجاور بود، به طور معمولی تحویل داده می شود. در غیر این صورت، درون یک شیء قرار گرفته و به همسایه‌ای ارسال می شود که به هدف نزدیک تر است، با استفاده از نوع درخواست <code>&quot;route&quot;</code> که باعث می شود آن همسایه نیز این رفتار را تکرار کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_qgwq/4PpOq" href="#c_qgwq/4PpOq" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">routeRequest</span>(<span class="cm-def">nest</span>, <span class="cm-def">target</span>, <span class="cm-def">type</span>, <span class="cm-def">content</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>.<span class="cm-property">includes</span>(<span class="cm-variable-2">target</span>)) {
    <span class="cm-keyword">return</span> <span class="cm-variable">request</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">target</span>, <span class="cm-variable-2">type</span>, <span class="cm-variable-2">content</span>);
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">via</span> <span class="cm-operator">=</span> <span class="cm-variable">findRoute</span>(<span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>, <span class="cm-variable-2">target</span>,
                        <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span>);
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">via</span>) <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string-2">`No route to ${</span><span class="cm-variable-2">target</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
    <span class="cm-keyword">return</span> <span class="cm-variable">request</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">via</span>, <span class="cm-string">&quot;route&quot;</span>,
                   {<span class="cm-property">target</span>, <span class="cm-property">type</span>, <span class="cm-property">content</span>});
  }
}

<span class="cm-variable">requestType</span>(<span class="cm-string">&quot;route&quot;</span>, (<span class="cm-def">nest</span>, {<span class="cm-def">target</span>, <span class="cm-def">type</span>, <span class="cm-def">content</span>}) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">return</span> <span class="cm-variable">routeRequest</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">target</span>, <span class="cm-variable-2">type</span>, <span class="cm-variable-2">content</span>);
});</pre>

<p>اکنون می‌توانیم پیامی به لانه‌ای که در برج کلیسا قرار دارد ارسال کنیم که چهار گام در شبکه نیاز دارد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_S73i8jJBHA" href="#c_S73i8jJBHA" tabindex="-1" role="presentation"></a><span class="cm-variable">routeRequest</span>(<span class="cm-variable">bigOak</span>, <span class="cm-string">&quot;Church Tower&quot;</span>, <span class="cm-string">&quot;note&quot;</span>,
             <span class="cm-string">&quot;Incoming jackdaws!&quot;</span>);</pre>

<p>تاکنون لایه‌های متعددی از قابلیت‌ها را روی یک سیستم ارتباطی اولیه ساخته ایم تا استفاده از آن را راحت و سرراست کنیم. این مدل (البته ساده شده‌ی) خوبی از چگونگی عملکرد شبکه‌های کامپیوتر در واقعیت است.</p>

<p><a class="p_ident" id="p_1oBJu4VFTA" href="#p_1oBJu4VFTA" tabindex="-1" role="presentation"></a>یک خاصیت متمایز کننده در شبکه‌های کامپیوتری این است که آن ها قابل اتکا نیستند – تجریدهایی که بر اساس آن‌ها انجام می‌ شود می توانند مفید باشند، اما شکست شبکه را نمی توان با آن‌ها پوشش داد. بنابراین برنامه‌نویسی تحت شبکه نوعا با انتظار خرابی (failure) در شبکه و مدیریت آن سر و کار دارد.</p>

<h2><a class="h_ident" id="h_qZQ84odw86" href="#h_qZQ84odw86" tabindex="-1" role="presentation"></a>توابع Async</h2>

<p>برای ذخیره‌ی اطلاعات مهم، کلاغ‌ها اطلاعات را بین لانه‌ها تکثیر می کنند. در این روش ، زمانی که یک شاهین یکی از لانه‌ها را از بین می برد، اطلاعات از بین نخواهند رفت.</p>

<p>برای بازیابی یک بخش از اطلاعات که در بافت موجود در خود لانه وجود ندارد، یک کامپیوتر لانه ممکن است با لانه‌های تصادفی در شبکه ارتباط بگیرد تا اینکه آن لانه‌ای که اطلاعات را دارد پیدا شود.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_QLKv1tpg1i" href="#c_QLKv1tpg1i" tabindex="-1" role="presentation"></a><span class="cm-variable">requestType</span>(<span class="cm-string">&quot;storage&quot;</span>, (<span class="cm-def">nest</span>, <span class="cm-def">name</span>) <span class="cm-operator">=&gt;</span> <span class="cm-variable">storage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>));

<span class="cm-keyword">function</span> <span class="cm-def">findInStorage</span>(<span class="cm-def">nest</span>, <span class="cm-def">name</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">storage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>).<span class="cm-property">then</span>(<span class="cm-def">found</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">found</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">found</span>;
    <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> <span class="cm-variable">findInRemoteStorage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>);
  });
}

<span class="cm-keyword">function</span> <span class="cm-def">network</span>(<span class="cm-def">nest</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">Array</span>.<span class="cm-property">from</span>(<span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span>.<span class="cm-property">keys</span>());
}

<span class="cm-keyword">function</span> <span class="cm-def">findInRemoteStorage</span>(<span class="cm-def">nest</span>, <span class="cm-def">name</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">sources</span> <span class="cm-operator">=</span> <span class="cm-variable">network</span>(<span class="cm-variable-2">nest</span>).<span class="cm-property">filter</span>(<span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>);
  <span class="cm-keyword">function</span> <span class="cm-def">next</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">sources</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
      <span class="cm-keyword">return</span> <span class="cm-variable">Promise</span>.<span class="cm-property">reject</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Not found&quot;</span>));
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">let</span> <span class="cm-def">source</span> <span class="cm-operator">=</span> <span class="cm-variable-2">sources</span>[<span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span>
                                      <span class="cm-variable-2">sources</span>.<span class="cm-property">length</span>)];
      <span class="cm-variable-2">sources</span> <span class="cm-operator">=</span> <span class="cm-variable-2">sources</span>.<span class="cm-property">filter</span>(<span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">source</span>);
      <span class="cm-keyword">return</span> <span class="cm-variable">routeRequest</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">source</span>, <span class="cm-string">&quot;storage&quot;</span>, <span class="cm-variable-2">name</span>)
        .<span class="cm-property">then</span>(<span class="cm-def">value</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">value</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span> <span class="cm-operator">?</span> <span class="cm-variable-2">value</span> : <span class="cm-variable-2">next</span>(),
              <span class="cm-variable-2">next</span>);
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">next</span>();
}</pre>

<p>به دلیل اینکه <code>connections</code> از جنس <code>Map</code> است، <bdo><code>Object.keys</code></bdo> روی آن جواب نمی دهد. متد <code>keys</code> در این شیء هم وجود دارد اما یک شمارنده را برمی گرداند نه یک آرایه. یک شمارنده (یا مقدار شمارنده) را می توان به وسیله‌ی <bdo><code>Array.from</code></bdo> به آرایه تبدیل کرد.</p>

<p><a class="p_ident" id="p_ZEHr4qx6tt" href="#p_ZEHr4qx6tt" tabindex="-1" role="presentation"></a>حتی با وجود استفاده از promise ها این کد نسبتا شکل خوبی ندارد. عملیات متعدد ناهمگام با هم زنجیر شده اند به صورتی که اصلا خوانا و واضح نیست. دوباره نیاز به یک تابع بازگشتی داریم (<code>next</code>) تا بتوانیم حلقه (looping) را بین لانه‌ها مدل سازی کنیم.</p>

<p>و این که کاری که این کد درواقع انجام می دهد کاملا خطی است – همیشه منتظر اتمام عمل قبلی پیش از شروع￼ عمل بعدی می ماند. در یک مدل برنامه‌نویسی همگام ، ساده‌تر می توان این کارها را پیاده سازی کرد.</p>

<p>خبر خوب این است که جاوااسکریپت این امکان را فراهم کرده است که کدهای شبه-همگام بنویسید. یک تابع <code>async</code> تابعی است که به طور ضمنی یک promise را بر‌می‌گرداند و می تواند در بدنه‌اش ، به وسیله‌ی دستور <code>await</code> منتظر دیگر promiseها باشد به طوری که همگام به نظر برسد.</p>

<p>می توانیم تابع <code>findInStorage</code> را به شکل زیر بازنویسی کنیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_eDKVOF1oo/" href="#c_eDKVOF1oo/" tabindex="-1" role="presentation"></a><span class="cm-keyword">async</span> <span class="cm-keyword">function</span> <span class="cm-def">findInStorage</span>(<span class="cm-def">nest</span>, <span class="cm-def">name</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">local</span> <span class="cm-operator">=</span> <span class="cm-keyword">await</span> <span class="cm-variable">storage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">local</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">local</span>;

  <span class="cm-keyword">let</span> <span class="cm-def">sources</span> <span class="cm-operator">=</span> <span class="cm-variable">network</span>(<span class="cm-variable-2">nest</span>).<span class="cm-property">filter</span>(<span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">sources</span>.<span class="cm-property">length</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">source</span> <span class="cm-operator">=</span> <span class="cm-variable-2">sources</span>[<span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span>
                                    <span class="cm-variable-2">sources</span>.<span class="cm-property">length</span>)];
    <span class="cm-variable-2">sources</span> <span class="cm-operator">=</span> <span class="cm-variable-2">sources</span>.<span class="cm-property">filter</span>(<span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">source</span>);
    <span class="cm-keyword">try</span> {
      <span class="cm-keyword">let</span> <span class="cm-def">found</span> <span class="cm-operator">=</span> <span class="cm-keyword">await</span> <span class="cm-variable">routeRequest</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">source</span>, <span class="cm-string">&quot;storage&quot;</span>,
                                     <span class="cm-variable-2">name</span>);
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">found</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">found</span>;
    } <span class="cm-keyword">catch</span> (<span class="cm-def">_</span>) {}
  }
  <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Not found&quot;</span>);
}</pre>

<p><a class="p_ident" id="p_WGJXcLYhs0" href="#p_WGJXcLYhs0" tabindex="-1" role="presentation"></a>یک تابع async را می توان با واژه‌ی <code>async</code> قبل از کلیدواژه‌ی <code>function</code> مشخص کرد. متدها را نیز می توان با نوشتن آن قبل از نام متد تبدیل به <code>async</code> کرد . زمانی که تابع یا متدی با این خصوصیت فراخوانی شود یک promise را تولید خواهد کرد. به محض این که بدنه‌ی تابع چیزی را برگرداند، آن promise نتیجه‌یابی می شود. اگر استثنایی تولید کند، promise رد می شود.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_04MPwtOsw6" href="#c_04MPwtOsw6" tabindex="-1" role="presentation"></a><span class="cm-variable">findInStorage</span>(<span class="cm-variable">bigOak</span>, <span class="cm-string">&quot;events on 2017-12-21&quot;</span>)
  .<span class="cm-property">then</span>(<span class="cm-variable">console</span>.<span class="cm-property">log</span>);</pre>

<p>درون یک تابع <code>async،</code> واژه‌ی <code>await</code> را می توان در ابتدای یک عبارت قرار داد تا تابع برای دریافت نتیجه‌ی promise منتظر بماند و بعد از آن به ادامه‌ی اجرای تابع بپردازد.</p>

<p>این گونه توابع دیگر مانند توابع معمولی جاوااسکریپت از ابتدا تا انتها در یک حرکت اجرا نمی شوند. بلکه ممکن است در هر نقطه‌ای که یک <code>await</code> دارند ایست کنند و بعدا به ادامه مسیرشان بپردازند.</p>

<p>برای کدهای ناهمگام مهم، استفاده از این روش معمولا مناسب تر است از استفاده از promise ها. حتی اگر لازم است که کاری انجام بدهید که مناسب مدل همگام نیست، مثل اجرای چندین کار در یک زمان، به آسانی می توان <code>await</code> را با استفاده مستقیم از promise ها ترکیب کرد.</p>

<h2><a class="h_ident" id="h_FTcnrJ/73W" href="#h_FTcnrJ/73W" tabindex="-1" role="presentation"></a>مولدها Generators</h2>

<p><a class="p_ident" id="p_PuKbCCrieL" href="#p_PuKbCCrieL" tabindex="-1" role="presentation"></a>این قابلیت در توابع که می توانند متوقف شده و بعدا دوباره به مسیرشان ادامه بدهند فقط مخصوص به توابع <code>async</code> نیست. جاوااسکریپت قابلیتی به نام توابع <em>generator</em> (مولد) دارد. این توابع به طور مشابه عمل می کنند اما بدون promise ها.</p>

<p><a class="p_ident" id="p_qes9UFq0bh" href="#p_qes9UFq0bh" tabindex="-1" role="presentation"></a>زمانی که تابعی را با <bdo><code>function*</code></bdo> (یک ستاره بعد از کلیدواژه‌ی function قرار می دهید)، تعریف می کنید، باعث می شود که آن تابع به یک مولد تبدیل شود. زمانی که یک تابع مولد فراخوانی می شود، یک تکرار‌کننده (iterator) را برمی گرداند که￼ پیش تر در <a href="06_object.html">فصل 6</a> دیده ایم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_B4ek89g871" href="#c_B4ek89g871" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span><span class="cm-keyword">*</span> <span class="cm-def">powers</span>(<span class="cm-def">n</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">current</span> <span class="cm-operator">=</span> <span class="cm-variable-2">n</span>;; <span class="cm-variable-2">current</span> <span class="cm-operator">*=</span> <span class="cm-variable-2">n</span>) {
    <span class="cm-keyword">yield</span> <span class="cm-variable-2">current</span>;
  }
}

<span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">power</span> <span class="cm-keyword">of</span> <span class="cm-variable">powers</span>(<span class="cm-number">3</span>)) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">power</span> <span class="cm-operator">&gt;</span> <span class="cm-number">50</span>) <span class="cm-keyword">break</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>);
}
<span class="cm-comment">// → 3</span>
<span class="cm-comment">// → 9</span>
<span class="cm-comment">// → 27</span></pre>

<p>در ابتدا، وقتی که تابع <code>powers</code> را فراخوانی می کنید، تابع در ابتدای خودش ایست می کند. هر بار که <code>next</code> را روی تکرارکننده فراخوانی می کنید، تابع تا رسیدن به یک عبارت <code>yield</code> اجرا می شود، و دوباره متوقف شده و مقداری که به وسیله‌ی <code>yield</code> حاصل شده است به عنوان مقدار بعدی تولیدی توسط تکرارکننده در نظر گرفته می شود. زمانی که تابع به پایان می رسد (که در این مثال هرگز اتفاق نمی افتد) تکرارکننده نیز به پایان می رسد.</p>

<p>نوشتن تکرارکننده‌ها اغلب در هنگام استفاده از توابع مولد ساده تر می باشد. تکرارکننده‌ی مربوط به کلاس <code>Groupe</code> (مربوط به تمرین <a href="06_object.html#group_iterator">فصل 6</a>) را می توان با این مولد بازنویسی کرد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_C6OZWjI9EM" href="#c_C6OZWjI9EM" tabindex="-1" role="presentation"></a><span class="cm-variable">Group</span>.<span class="cm-property">prototype</span>[<span class="cm-variable">Symbol</span>.<span class="cm-property">iterator</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span><span class="cm-keyword">*</span>() {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">members</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">yield</span> <span class="cm-keyword">this</span>.<span class="cm-property">members</span>[<span class="cm-variable-2">i</span>];
  }
};</pre>

<p><a class="p_ident" id="p_8S4ej0Vfgj" href="#p_8S4ej0Vfgj" tabindex="-1" role="presentation"></a>دیگر نیازی نیست که یک شیء را ایجاد کرده تا وضعیت تکرار را نگه داری کنیم – مولدها این کار را به صورت خودکار با ذخیره‌ی وضعیت محلی‌شان با هر بار خواندن yield انجام می دهند.</p>

<p><a class="p_ident" id="p_K+GGmrPUSt" href="#p_K+GGmrPUSt" tabindex="-1" role="presentation"></a>عبارت‌های <code>yield</code> فقط می توانند مستقیما درون خود تابع مولد استفاده شوند نه درون تابعی که درون مولد تعریف می کنید. وضعیتی که یک مولد در هنگام اجرای yield ذخیره می کند ، فقط شامل محیط محلی آن و موقعیتی که در آنجا yield انجام شده می شود.</p>

<p><a class="p_ident" id="p_QRQ2o23GXY" href="#p_QRQ2o23GXY" tabindex="-1" role="presentation"></a>یک تابع <code>async</code> یک نوع خاص از یک مولد است. در هنگام فراخوانی یک promise تولید می کند که در هنگام پایان تابع به نتیجه می رسد و زمانی که یک استثنا تولید می کنند reject می شوند. هر وقت که این تابع یک promise را yield می کند (به عبارتی با <code>await</code> منتظر یک promise می ماند)، نتیجه‌ی آن promise (مقدار یا استثنای تولید شده) نتیجه‌ی عبارت <code>await</code> خواهد بود.</p>

<h2><a class="h_ident" id="h_LixJ9Ii6vp" href="#h_LixJ9Ii6vp" tabindex="-1" role="presentation"></a>حلقه‌ی رخداد - event loop</h2>

<p>برنامه‌های ناهمگام به صورت بخش بخش اجرا می شوند. هر بخش ممکن است کارهایی را شروع کند و کدهایی را هم برنامه ریزی کند که در صورت پایان یا شکست آن کارها اجرا شوند. بین این بخش ها، برنامه بیکار می نشیند و منتظر کار بعدی خواهد ماند.</p>

<p><a class="p_ident" id="p_mYfa1fy9XO" href="#p_mYfa1fy9XO" tabindex="-1" role="presentation"></a>بنابراین callbackها به طور مستقیم توسط کدی که آن ها را زمانبندی کرده اند فراخوانی نمی شوند. اگر من تابع <code>setTimeout</code> را از درون یک تابع فراخوانی کنم، آن تابع زمانی برگردانده می شود که تابع callback فراخوانی می￼ شود. و زمانی که تابع callback اجرا و بر‌می‌گردد، کنترل برنامه به تابعی که آن را زمانبندی کرده بود بر نخواهد گشت.</p>

<p><a class="p_ident" id="p_l29z7MW66K" href="#p_l29z7MW66K" tabindex="-1" role="presentation"></a>رفتار ناهمگام، در تابع تهی خودش (پشته‌ی فراخوانی) اتفاق می‌افتد. این یکی از دلایلی است که بدون استفاده از promiseها، مدیریت استثناها در کدهای ناهمگام مشکل است. به دلیل اینکه هر callback با یک پشته‌ی تقریبا خالی شروع می شود، گرداننده‌های <code>catch</code> شما در پشته در هنگام بروز یک استثنا در پشته نخواهند بود.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_UswfjtMHu4" href="#c_UswfjtMHu4" tabindex="-1" role="presentation"></a><span class="cm-keyword">try</span> {
  <span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Woosh&quot;</span>);
  }, <span class="cm-number">20</span>);
} <span class="cm-keyword">catch</span> (<span class="cm-def">_</span>) {
  <span class="cm-comment">// This will not run</span>
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Caught!&quot;</span>);
}</pre>

<p><a class="p_ident" id="p_f1DBc3jezP" href="#p_f1DBc3jezP" tabindex="-1" role="presentation"></a>اهمیتی ندارد چقدر این رخدادها به هم نزدیک باشند- مانند timeoutها یا درخواست‌های وارده – ، یک محیط جاوااسکریپت فقط یک برنامه را در یک لحظه اجرا می کند. می توان این را به عنوان اجرای یک حلقه‌ی بزرگ دور برنامه شما تصور کرد که به آن حلقه‌ی رخداد (event loop) می گویند. وقتی کاری دیگر برای انجام نمانده باشد ، حلقه از کار می ایستد. اما با ورود رخدادها، آن‌ها به یک صف اضافه می شوند و کدهایشان یکی بعد از دیگری اجرا می شوند. بدلیل اینکه هیچگاه دو کار در یک لحظه اجرا نمی شود، کدهای کند و زمانگیر ممکن است در رسیدگی به دیگر رخدادها تاخیر ایجاد کنند.</p>

<p><a class="p_ident" id="p_VtPJSQviYI" href="#p_VtPJSQviYI" tabindex="-1" role="presentation"></a>در این مثال یک timeout تنظیم می شود، اما اجرای آن به بعد از زمان اجرای در نظر گرفته شده به تاخیر می‌افتد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Xozg9CCvVZ" href="#c_Xozg9CCvVZ" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">start</span> <span class="cm-operator">=</span> <span class="cm-variable">Date</span>.<span class="cm-property">now</span>();
<span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Timeout ran at&quot;</span>, <span class="cm-variable">Date</span>.<span class="cm-property">now</span>() <span class="cm-operator">-</span> <span class="cm-variable">start</span>);
}, <span class="cm-number">20</span>);
<span class="cm-keyword">while</span> (<span class="cm-variable">Date</span>.<span class="cm-property">now</span>() <span class="cm-operator">&lt;</span> <span class="cm-variable">start</span> <span class="cm-operator">+</span> <span class="cm-number">50</span>) {}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Wasted time until&quot;</span>, <span class="cm-variable">Date</span>.<span class="cm-property">now</span>() <span class="cm-operator">-</span> <span class="cm-variable">start</span>);
<span class="cm-comment">// → Wasted time until 50</span>
<span class="cm-comment">// → Timeout ran at 55</span></pre>

<p><a class="p_ident" id="p_6zLBnp0Ex1" href="#p_6zLBnp0Ex1" tabindex="-1" role="presentation"></a>promise ها همیشه به عنوان یک رخداد جدید، رد یا حل‌ و فصل می‌شوند. حتی اگر یک promise از پیش به نتیجه رسیده باشد، انتظار برای آن باعث می شود که callback شما بعد از پایان اسکریپت کنونی اجرا شود، نه به صورت فوری.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_B4TYo0a2ol" href="#c_B4TYo0a2ol" tabindex="-1" role="presentation"></a><span class="cm-variable">Promise</span>.<span class="cm-property">resolve</span>(<span class="cm-string">&quot;Done&quot;</span>).<span class="cm-property">then</span>(<span class="cm-variable">console</span>.<span class="cm-property">log</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Me first!&quot;</span>);
<span class="cm-comment">// → Me first!</span>
<span class="cm-comment">// → Done</span></pre>

<p>در فصل‌های بعدی انواع مختلفی از رخدادها را مشاهده خواهیم کرد که روی حلقه‌ی رخدادها اجرا می شوند.</p>

<h2><a class="h_ident" id="h_gTEP5a9/M7" href="#h_gTEP5a9/M7" tabindex="-1" role="presentation"></a>باگ‌ها در مدل برنامه‌نویسی ناهمگام</h2>

<p>زمانی که برنامه‌ی شما به صورت همگام اجرا می شود، در یک اجرای واحد، هیچ تغییر وضعیتی به جز آن هایی که خود برنامه ایجاد می کند وجود ندارد. در برنامه‌های ناهمگام قضیه متفاوت است- ممکن است شامل وقفه‌هایی در اجرایشان باشند که در این وقفه‌ها دیگر کدها می توانند اجرا شوند.</p>

<p>اجازه بدهید تا به مثالی نگاه کنیم. یکی از سرگرمی‌های کلاغ‌های ما این است که تعداد جوجه‌هایی که از تخم بیرون می آیند در طول یک سال در روستا را بشمارند. لانه‌ها این عدد را در بافت‌های ذخیره‌سازی‌شان حفظ می کنند. کد پیش رو تلاش می کند تا تمامی اعداد موجود در همه‌ی لانه‌ها را برای یک سال مشخص بشمارد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_IMqeevTorV" href="#c_IMqeevTorV" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">anyStorage</span>(<span class="cm-def">nest</span>, <span class="cm-def">source</span>, <span class="cm-def">name</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">source</span> <span class="cm-operator">==</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>) <span class="cm-keyword">return</span> <span class="cm-variable">storage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>);
  <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> <span class="cm-variable">routeRequest</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">source</span>, <span class="cm-string">&quot;storage&quot;</span>, <span class="cm-variable-2">name</span>);
}

<span class="cm-keyword">async</span> <span class="cm-keyword">function</span> <span class="cm-def">chicks</span>(<span class="cm-def">nest</span>, <span class="cm-def">year</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">list</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;&quot;</span>;
  <span class="cm-keyword">await</span> <span class="cm-variable">Promise</span>.<span class="cm-property">all</span>(<span class="cm-variable">network</span>(<span class="cm-variable-2">nest</span>).<span class="cm-property">map</span>(<span class="cm-keyword">async</span> <span class="cm-def">name</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable-2">list</span> <span class="cm-operator">+=</span> <span class="cm-string-2">`${</span><span class="cm-variable-2">name</span><span class="cm-string-2">}</span><span class="cm-string-2">: ${</span>
      <span class="cm-keyword">await</span> <span class="cm-variable">anyStorage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>, <span class="cm-string-2">`chicks in ${</span><span class="cm-variable-2">year</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>)
    <span class="cm-string-2">}</span><span class="cm-string-2">\n`</span>;
  }));
  <span class="cm-keyword">return</span> <span class="cm-variable-2">list</span>;
}</pre>

<p><a class="p_ident" id="p_e1B1QHaHbK" href="#p_e1B1QHaHbK" tabindex="-1" role="presentation"></a>قسمت <bdo><code>async name =&gt;</code></bdo> نشان می دهد که توابع پیکانی arrow functions را همچنین می توان به صورت <code>async</code> با قرار دادن واژه‌ی <code>async</code> در ابتدای آن ایجاد کرد.</p>

<p>کد ما در نگاه اول نادرست به نظر نمی‌رسد... تابع پیکانی <code>async</code> بر روی مجموعه‌ی لانه‌ها نگاشت می شود، آرایه‌‌ای از promiseها تولید می شود و سپس از <bdo><code>Promise.all</code></bdo> برای انتظار برای همه‌ی این‌ها قبل از بازگشتن از لیستی که می‌سازند استفاده می شود.</p>

<p>اما این کد مطمئنا مشکل دارد. خروجی آن همیشه لانه‌ای است که کند‌ترین پاسخ را داشته است.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_GWIpudJZ4o" href="#c_GWIpudJZ4o" tabindex="-1" role="presentation"></a><span class="cm-variable">chicks</span>(<span class="cm-variable">bigOak</span>, <span class="cm-number">2017</span>).<span class="cm-property">then</span>(<span class="cm-variable">console</span>.<span class="cm-property">log</span>);</pre>

<p>می توانید علت این مشکل را بیابید؟</p>

<p>مشکل در قسمت عملگر <bdo><code>+=</code></bdo> قرار دارد، که مقدار فعلی لیست را در زمانی که دستور شروع به اجرا می کند می گیرد و بعد از اینکه دستور <code>await</code> به پایان می رسد، متغیر <code>list</code> را معادل با آن مقدار به اضافه رشته‌ی افزوده شده قرار می دهد.</p>

<p>اما در این میان جایی که دستور شروع به اجرا می کند و زمانی که به اتمام می رسد یک وقفه‌ی ناهمگام وجود دارد. عبارت <code>map</code> قبل از اینکه چیزی به لیست اضافه شود، اجرا می شود بنابراین هرکدام از عملگرهای <bdo><code>+=</code></bdo> با یک رشته‌ی خالی شروع می کنند و به پایان می رسند، زمانی که بازیابی مخزنش به اتمام برسد، متغیر <code>list</code> را برابر با یک لیست تک-خطی قرار می دهد — نتیجه افزودن خطش به رشته‌ی تهی.</p>

<p>بجای اینکه لیست را با تغییر یک متغیر بسازیم، با برگرداندن خطوط از promiseهای نگاشت شده و فراخوانی <code>join</code> روی نتیجه‌ی <bdo><code>Promise.all</code></bdo>، می توان به سادگی از این اشکال جلوگیری کرد. به طور معمول، محاسبه‌ی مقدارهای جدید نسبت به تغییر مقادیر فعلی کمتر خطاساز هستند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_gkD231Soao" href="#c_gkD231Soao" tabindex="-1" role="presentation"></a><span class="cm-keyword">async</span> <span class="cm-keyword">function</span> <span class="cm-def">chicks</span>(<span class="cm-def">nest</span>, <span class="cm-def">year</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">lines</span> <span class="cm-operator">=</span> <span class="cm-variable">network</span>(<span class="cm-variable-2">nest</span>).<span class="cm-property">map</span>(<span class="cm-keyword">async</span> <span class="cm-def">name</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">name</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;: &quot;</span> <span class="cm-operator">+</span>
      <span class="cm-keyword">await</span> <span class="cm-variable">anyStorage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>, <span class="cm-string-2">`chicks in ${</span><span class="cm-variable-2">year</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  });
  <span class="cm-keyword">return</span> (<span class="cm-keyword">await</span> <span class="cm-variable">Promise</span>.<span class="cm-property">all</span>(<span class="cm-variable-2">lines</span>)).<span class="cm-property">join</span>(<span class="cm-string">&quot;\n&quot;</span>);
}</pre>

<p><a class="p_ident" id="p_U+0BUkeym7" href="#p_U+0BUkeym7" tabindex="-1" role="presentation"></a>اشتباهاتی شبیه این خیلی ساده اتفاق می افتند مخصوصا زمانی که از <code>await</code> استفاده می کنیم، و باید حواستان به￼ جایی که وقفه‌ها در کدتان رخ می دهد باشد. یک مزیت برنامه نویسی ناهمگام (چه با استفاده از callbackها ، promise ها یا await) به صورت صریح در جاوااسکریپت، این است که پیدا کردن این وقفه‌ها نسبتا ساده است.</p>

<h2><a class="h_ident" id="h_EzvDUHyjs2" href="#h_EzvDUHyjs2" tabindex="-1" role="presentation"></a>خلاصه</h2>

<p>برنامه‌نویسی ناهمگام این امکان را فراهم می سازد که بتوان برای کارهای اجرایی زمانگیر صبر کرد بدون اینکه برنامه در حین انجام این کارها متوقف شود. محیط‌های جاوااسکریپت نوعا این سبک از برنامه‌نویسی را با استفاده از callback ها پیاده سازی می کنند، توابعی که بعد از پایان یافتن کارهای مورد نظر، فراخوانی می شوند. یک حلقه‌ی رخداد، این توابع callback را زمانبندی می کند تا در زمان مناسب فراخوانی شوند، یکی پس از دیگری، تا اجرای آن‌ها با تداخل روبرو نشود.</p>

<p>برنامه‌نویسی ناهمگام با استفاده از promise ها آسان تر می شود، اشیائی که نماینده‌ی کارهایی هستند که ممکن است در آینده تکمیل شوند، و توابع <code>async</code>، که به شما این امکان را می دهند تا یک برنامه‌ی ناهمگام را به شکلی بنویسید که انگار همگام است.</p>

<h2><a class="h_ident" id="h_ggOFdVwDCk" href="#h_ggOFdVwDCk" tabindex="-1" role="presentation"></a>تمرین‌ها</h2>

<h3><a class="i_ident" id="i_4zlaDf3FG4" href="#i_4zlaDf3FG4" tabindex="-1" role="presentation"></a>رهگیری چاقوی جراحی</h3>

<p>کلاغ‌های روستا یک چاقوی جراحی قدیمی دارند که گاهی اوقات از آن برای ماموریت‌های خاص استفاده می می‌کنند — فرض کنید، برای بریدن توری درها یا بسته ها. برای اینکه بتوان به سرعت آن را رهگیری کرد، هربار که چاقو به لانه‌ی دیگری منتقل می شد، یک مدخل به مخزن هر دو لانه اضافه می شد، لانه‌ای که آن را داشت و لانه‌ای که آن را دریافت کرده است و این مدخل با نام <code>&quot;scalpel&quot;</code> و با مقداری برای محل جدیدش ذخیره می شود.</p>

<p>این به این معنا است که برای پیدا کردن چاقو باید به تاریخچه‌ی نشانه‌های موجود در مخزن مراجعه کرد تا اینکه به لانه‌ای برسید که به خودش ارجاع می دهد.</p>

<p>یک تابع <code>async</code> به نام <code>locateScalpel</code> ایجاد کنید که این کار را انجام می دهد که از لانه‌ای که روی آن اجرا می شود شروع می کند. می توانید از تابع <code>anyStorage</code> که پیش تر تعریف شده برای دسترسی به لانه‌های مورد نظر استفاده کنید. چاقو از مدت زمان مدیدی است که بین لانه‌ها دست به دست می شود که می توان نتیجه گرفت که هر لانه یک مدخل <code>&quot;scalpel&quot;</code> را در مخزنش دارد.</p>

<p>در گام بعدی، همین تابع را بدون استفاده از <code>async</code> و <code>await</code> بنویسید.</p>

<p>آیا شکست‌های درخواست‌ها به درستی به عنوان عدم پذیرش یک promise برگردانده شده، در هر دو  نسخه نمایش داده می شوند؟ چگونه؟</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_YnFVXk9tRo" href="#c_YnFVXk9tRo" tabindex="-1" role="presentation"></a><span class="cm-keyword">async</span> <span class="cm-keyword">function</span> <span class="cm-def">locateScalpel</span>(<span class="cm-def">nest</span>) {
  <span class="cm-comment">// Your code here.</span>
}

<span class="cm-keyword">function</span> <span class="cm-def">locateScalpel2</span>(<span class="cm-def">nest</span>) {
  <span class="cm-comment">// Your code here.</span>
}

<span class="cm-variable">locateScalpel</span>(<span class="cm-variable">bigOak</span>).<span class="cm-property">then</span>(<span class="cm-variable">console</span>.<span class="cm-property">log</span>);
<span class="cm-comment">// → Butcher Shop</span></pre>

<div class="solution"><div class="solution-text">

<p>این کار را می توان به وسیله‌ی یک حلقه که درون‌ لانه‌ها را می‌گردد صورت داد، اگر مقداری مطابق نام لانه‌ی فعلی پیدا کند آن را بر‌می گرداند و درغیر این صورت به سراغ لانه‌ی بعدی می رود. در تابع <code>async</code>، یک دستور <code>for</code> یا <code>while</code> می تواند استفاده شود.</p>

<p>برای انجام این کار در یک تابع ساده، باید حلقه‌ی خودتان را به وسیله‌ی یک تابع بازگشتی بنویسید. آسان ترین روش انجام این کار این است که تابع یک promise را با فراخوانی <code>then</code> روی promiseای که مقدار ذخیره‌شده را بر‌می‌گرداند بنویسید. بسته به اینکه آن مقدار با نام لانه‌ی فعلی مطابقت داشته باشد یا خیر ، تابع گرداننده، یا آن مقدار را بر‌می‌گرداند یا یک promise دیگر با فراخوانی دوباره‌ی تابع بر‌می‌گرداند.</p>

<p>فراموش نکنید که حلقه‌ را با یک بار فراخوانی تابع بازگشتی از درون تابع اصلی شروع کنید.</p>

<p>در تابع <code>async</code>، promiseهای رد شده به وسیله‌ی <code>await</code> به استثنا تبدیل می‌شوند. زمانی که یک تابع <code>async</code> یک استثنا تولید می کند، promise آن رد شده است.</p>

<p>اگر تابع را بدون استفاده از <code>async</code> همانطور که مشخص شده است پیاده سازی کنید، نحوه‌ی عملکرد پیش‌فرض <code>then</code> نیز باعث تولید یک شکست برای پایان دادن promise برگشتی می شود. اگر درخواستی با شکست روبرو شود، گرداننده‌ای که به <code>then</code> ارسال می‌شود، فراخوانی نمی‌گردد و promiseای که برمی‌گرداند به همان دلیل رد می‌شود.</p>

</div></div>

<h3><a class="i_ident" id="i_Uy3j2HjqAG" href="#i_Uy3j2HjqAG" tabindex="-1" role="presentation"></a>ساختن Promise.all</h3>

<p><a class="p_ident" id="p_elCjOOWYcy" href="#p_elCjOOWYcy" tabindex="-1" role="presentation"></a>با داشتن یک آرایه از promise ها، متد <bdo><code>Promise.all</code></bdo> یک promise را برمی گرداند که برای همه‌ی promise های موجود در آرایه، منتظر می ماند تا پایان یابند. در صورت موفقیت، آرایه‌ای از مقدارهای نتایج تولید می شود. اگر یک promise موجود در آرایه با شکست روبرو شود، promise ای که به وسیله <code>all</code> برگردانده می شود نیز با شکست روبرو می شود، همراه با دلیل شکست promise مشکل خورده.</p>

<p>تابعی به نام <code>Promise_all</code> بنویسید که همین کار را انجام دهد.</p>

<p>به خاطر داشته‌باشید که بعد از اینکه یک promise موفق شود یا با شکست روبرو شود، دیگر نمی تواند دوباره موفق یا شکست بخورد و فراخوانی‌های بعدی به توابعی که برای نتیجه‌یابی آن اقدام می کنند صرف نظر می شوند. این می تواند راهی که شما شکست‌ها را در promise تان رسیدگی می کنید ساده تر سازد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_70Eq9i3rpH" href="#c_70Eq9i3rpH" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">Promise_all</span>(<span class="cm-def">promises</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>((<span class="cm-def">resolve</span>, <span class="cm-def">reject</span>) <span class="cm-operator">=&gt;</span> {
    <span class="cm-comment">// Your code here.</span>
  });
}

<span class="cm-comment">// Test code.</span>
<span class="cm-variable">Promise_all</span>([]).<span class="cm-property">then</span>(<span class="cm-def">array</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;This should be []:&quot;</span>, <span class="cm-variable-2">array</span>);
});
<span class="cm-keyword">function</span> <span class="cm-def">soon</span>(<span class="cm-def">val</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>(<span class="cm-def">resolve</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">resolve</span>(<span class="cm-variable-2">val</span>), <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">500</span>);
  });
}
<span class="cm-variable">Promise_all</span>([<span class="cm-variable">soon</span>(<span class="cm-number">1</span>), <span class="cm-variable">soon</span>(<span class="cm-number">2</span>), <span class="cm-variable">soon</span>(<span class="cm-number">3</span>)]).<span class="cm-property">then</span>(<span class="cm-def">array</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;This should be [1, 2, 3]:&quot;</span>, <span class="cm-variable-2">array</span>);
});
<span class="cm-variable">Promise_all</span>([<span class="cm-variable">soon</span>(<span class="cm-number">1</span>), <span class="cm-variable">Promise</span>.<span class="cm-property">reject</span>(<span class="cm-string">&quot;X&quot;</span>), <span class="cm-variable">soon</span>(<span class="cm-number">3</span>)])
  .<span class="cm-property">then</span>(<span class="cm-def">array</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;We should not get here&quot;</span>);
  })
  .<span class="cm-property">catch</span>(<span class="cm-def">error</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span> <span class="cm-operator">!=</span> <span class="cm-string">&quot;X&quot;</span>) {
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Unexpected failure:&quot;</span>, <span class="cm-variable-2">error</span>);
    }
  });</pre>

<div class="solution"><div class="solution-text">

<p>تابعی که به سازنده‌ی <code>Promise</code> داده می‌شود نیاز خواهد داشت که <code>then</code> را روی هر یک از promiseهای آرایه فراخوانی کند. زمانی که یکی از این promiseها موفق شود، دو چیز لازم است تا اتفاق بیفتد. مقدار نتیجه باید در آرایه نتیجه و در موقعیت صحیح ذخیره شود، و باید بررسی کنیم که اگر این promise آخرین promise در حال بررسی بود، promise خودمان را به پایان برسانیم.</p>

<p><a class="p_ident" id="p_uGhSwQNlY2" href="#p_uGhSwQNlY2" tabindex="-1" role="presentation"></a>عمل آخر را می‌توان به وسیله‌ی یک شمارنده استفاده کنیم که مقدار اولیه‌اش از اندازه‌ی آرایه شروع می‌شود و با هر بار موفقیت یک promise، 1 واحد کاهش می‌یابد. وقتی این شمارنده به عدد 0 رسید، کار تمام است. مطمئن شوید که خالی بودن آرایه‌ی ورودی را نیز بررسی کرده باشید ( که در این صورت هیچ promiseی حل و فصل نخواهد شد).</p>

<p>مدیریت شکست نیاز به کمی تفکر دارد اما درنهایت کاری بسیار ساده است. کافی است تابع <code>reject</code> متعلق به promise پوشش دهنده را به هر یک از promiseهای موجود در آرایه به عنوان گرداننده‌ی <code>catch</code> ارسال کنید یا به عنوان آرگومان دوم به <code>then</code> بفرستید درنتیجه شکست در یکی از آن دو منجر به رد شدن کل promise پوشش دهنده می شود.</p>

</div></div><nav><a href="10_modules.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="12_language.html" title="next chapter">▶</a></nav>
</article>
