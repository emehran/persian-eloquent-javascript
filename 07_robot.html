<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>پروژه: ساخت یک ربات :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 7;var sandboxLoadFiles = ["code/chapter/07_robot.js","code/animatevillage.js"];</script><script>var clicky_site_ids = clicky_site_ids || []; clicky_site_ids.push(101171577);</script>
  <script async src="//static.getclicky.com/js"></script>

</head>

<article>
<nav><a href="06_object.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="08_error.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>Chapter 7</span>پروژه: ساخت یک ربات</h1>

<blockquote>

<p><a class="p_ident" id="p_uJUZHUrdPa" href="#p_uJUZHUrdPa" tabindex="-1" role="presentation"></a>[...] the question of whether Machines Can Think [...] is about as relevant as the question of whether Submarines Can Swim.</p>

<footer>Edsger Dijkstra, <cite>The Threats to Computing Science</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_7.jpg" alt="Picture of a package-delivery robot"></figure>

<p><a class="p_ident" id="p_2jmj7l5rSw" href="#p_2jmj7l5rSw" tabindex="-1" role="presentation"></a>در فصل‌های “پروژه”، موقتا مطلب جدیدی معرفی نمی کنم و به جای آن باهم روی ساخت یک برنامه کار خواهیم کرد. مطالب تئوری برای برنامه نویسی لازم هستند، اما خواندن و فهمیدن برنامه‌های واقعی نیز به همان اندازه مهم می باشد.</p>

<p>پروژه‌ی ما در این فصل، ساخت یک ماشین خودکار است؛ برنامه‌ی کوچکی که وظیفه‌ای را در یک جهان مجازی انجام می دهد. ماشین خودکار ما، یک ربات نامه‌رسان است که بسته‌های پستی را تحویل گرفته و به مقصدشان می‌رساند.</p>

<h2><a class="h_ident" id="h_SbbDoYLjwJ" href="#h_SbbDoYLjwJ" tabindex="-1" role="presentation"></a>روستای مدوفیلد</h2>

<p><a class="p_ident" id="p_VxunETfsef" href="#p_VxunETfsef" tabindex="-1" role="presentation"></a>روستای مدوفیلد زیاد بزرگ نیست. دارای 11 مکان است که 14 راه بین آن‌ها وجود دارد. می توان آن را با این آرایه از راه‌ها توصیف نمود:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Zs4LZxNb9d" href="#c_Zs4LZxNb9d" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">roads</span> <span class="cm-operator">=</span> [
  <span class="cm-string">&quot;Alice's House-Bob's House&quot;</span>,   <span class="cm-string">&quot;Alice's House-Cabin&quot;</span>,
  <span class="cm-string">&quot;Alice's House-Post Office&quot;</span>,   <span class="cm-string">&quot;Bob's House-Town Hall&quot;</span>,
  <span class="cm-string">&quot;Daria's House-Ernie's House&quot;</span>, <span class="cm-string">&quot;Daria's House-Town Hall&quot;</span>,
  <span class="cm-string">&quot;Ernie's House-Grete's House&quot;</span>, <span class="cm-string">&quot;Grete's House-Farm&quot;</span>,
  <span class="cm-string">&quot;Grete's House-Shop&quot;</span>,          <span class="cm-string">&quot;Marketplace-Farm&quot;</span>,
  <span class="cm-string">&quot;Marketplace-Post Office&quot;</span>,     <span class="cm-string">&quot;Marketplace-Shop&quot;</span>,
  <span class="cm-string">&quot;Marketplace-Town Hall&quot;</span>,       <span class="cm-string">&quot;Shop-Town Hall&quot;</span>
];</pre><figure><img src="img/village2x.png" alt="The village of Meadowfield"></figure>

<p>شبکه‌ی راه‌ها در این روستا، یک گراف تشکیل می دهد. یک <em>گراف</em> مجموعه‌ای از نقطه‌ها است (مکان‌ها در روستا) به همراه‌ خطوطی که بین آن‌ها قرار می گیرند (راه‌ها). این گراف همان جهانی خواهد بود که ربات ما در آن حرکت خواهد کرد.</p>

<p>کارکردن با آرایه‌ای از رشته‌ها، زیاد راحت نیست. ما می خواهیم بدانیم از هر مکان به چه مقصد‌هایی می توان رفت. بیایید لیست راه ها را به ساختار داده‌ای تبدیل کنیم که برای هر مکان، جاهایی که می توان رفت را مشخص کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_URtngTWego" href="#c_URtngTWego" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">buildGraph</span>(<span class="cm-def">edges</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">graph</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);
  <span class="cm-keyword">function</span> <span class="cm-def">addEdge</span>(<span class="cm-def">from</span>, <span class="cm-def">to</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">graph</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">==</span> <span class="cm-atom">null</span>) {
      <span class="cm-variable-2">graph</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">=</span> [<span class="cm-variable-2">to</span>];
    } <span class="cm-keyword">else</span> {
      <span class="cm-variable-2">graph</span>[<span class="cm-variable-2">from</span>].<span class="cm-property">push</span>(<span class="cm-variable-2">to</span>);
    }
  }
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> [<span class="cm-def">from</span>, <span class="cm-def">to</span>] <span class="cm-keyword">of</span> <span class="cm-variable-2">edges</span>.<span class="cm-property">map</span>(<span class="cm-def">r</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">r</span>.<span class="cm-property">split</span>(<span class="cm-string">&quot;-&quot;</span>))) {
    <span class="cm-variable-2">addEdge</span>(<span class="cm-variable-2">from</span>, <span class="cm-variable-2">to</span>);
    <span class="cm-variable-2">addEdge</span>(<span class="cm-variable-2">to</span>, <span class="cm-variable-2">from</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">graph</span>;
}

<span class="cm-keyword">const</span> <span class="cm-def">roadGraph</span> <span class="cm-operator">=</span> <span class="cm-variable">buildGraph</span>(<span class="cm-variable">roads</span>);</pre>

<p><a class="p_ident" id="p_N3Re16DwBf" href="#p_N3Re16DwBf" tabindex="-1" role="presentation"></a>این تابع، با گرفتن آرایه‌ای از راه‌ها، <code>buildGraph</code> شیءای از نوع نگاشت (map) را ایجاد خواهد کرد که برای هر گره، آرایه‌ای از گره‌های متصل به آن را ذخیره خواهد کرد.</p>

<p>تابع از متد <code>split</code> برای تبدیل رشته‌های راه، که به صورت <code>&quot;انتها-ابتدا&quot;</code> می باشند، به آرایه‌های دوعنصری که نقاط شروع و پایان در آن‌ها جدا شده است، استفاده می کند.</p>

<h2><a class="h_ident" id="h_21T02S+StD" href="#h_21T02S+StD" tabindex="-1" role="presentation"></a>ماموریت</h2>

<p>ربات ما در روستا گشت خواهد زد و بسته‌های پستی که در مکان‌های مختلف پراکنده هستند و هر کدام به مکان دیگری باید برده شوند را گرفته و در مقصد‌هایشان تحویل می دهد.</p>

<p>این ماشین خودکار باید در هر نقطه تصمیم بگیرد که مکان بعدی کجاست. زمانی که همه‌ی بسته‌ها تحویل داده شدند، ماموریتش تمام می شود.</p>

<p>برای شبیه سازی این فرایند، باید یک جهان مجازی تعریف کنیم که آن را توصیف کند. این مدل، مکان ربات و بسته‌ها را مشخص می‌کند. زمانی که ربات تصمیم می گیرد که به سمتی حرکت کند، لازم است تا مدل را به روزرسانی کنیم تا شرایط جدید را منعکس کند.</p>

<p>اگر به با تفکر برنامه نویسی شیء گرا به مساله نگاه می کنید، حرکت اول شما شاید تعریف اشیاء مجزا برای عناصر مختلف این جهان باشد: یک کلاس برای ربات، یک کلاس برای یک بسته، و شاید یکی هم برای مکان‌ها. این کلاس‌ها می توانند خاصیت‌هایی را هم داشته باشند که وضعیت فعلی آن ها را نگه داری کند. مانند تعداد بسته‌ها در یک مکان، که می توانند با به‌روز‌رسانی جهان، تغییر کنند.</p>

<p>این کار اشتباه است.</p>

<p>حداقل ، معمولا اشتباه است. اینکه چیزی به نظر می‌رسد که یک شیء است، به این معنا نیست که در برنامه‌ی شما هم باید به عنوان یک شیء در نظر گرفته شود. این کار، در نظر گرفتن کلاس‌های مجزا برای تک تک مفاهیم در برنامه، شما را به سمتی می برد که با مجموعه‌ای از اشیاء به هم متصل روبرو شوید که هر کدام وضعیت‌ درونی قابل تغییر خود را دارند. معمولا به سختی می توان این‌گونه برنامه‌ها را درک کرد و در نتیجه، به سادگی با مشکل روبرو می شوند.</p>

<p>به جای آن، بیایید وضعیت روستا را با کوچکترین مجموعه‌مقادیری که می تواند آن را توصیف کند خلاصه کنیم؛ موقعیت فعلی ربات و مجموعه‌‌ی بسته‌هایی که هنوز تحویل داده نشده اند. این بسته‌ها هر کدام دارای یک موقعیت فعلی و یک آدرس مقصد می باشند.</p>

<p>اجازه دهید آن را طوری بسازیم که با حرکت ربات، خود وضعیت را تغییر ندهیم بلکه یک وضعیت جدید محاسبه‌ کنیم که حالت بعد از حرکت را نشان می دهد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_VcDNIi1lcV" href="#c_VcDNIi1lcV" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">VillageState</span> {
  <span class="cm-property">constructor</span>(<span class="cm-def">place</span>, <span class="cm-def">parcels</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">place</span> <span class="cm-operator">=</span> <span class="cm-variable-2">place</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">parcels</span> <span class="cm-operator">=</span> <span class="cm-variable-2">parcels</span>;
  }

  <span class="cm-property">move</span>(<span class="cm-def">destination</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">roadGraph</span>[<span class="cm-keyword">this</span>.<span class="cm-property">place</span>].<span class="cm-property">includes</span>(<span class="cm-variable-2">destination</span>)) {
      <span class="cm-keyword">return</span> <span class="cm-keyword">this</span>;
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">let</span> <span class="cm-def">parcels</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">parcels</span>.<span class="cm-property">map</span>(<span class="cm-def">p</span> <span class="cm-operator">=&gt;</span> {
        <span class="cm-keyword">if</span> (<span class="cm-variable-2">p</span>.<span class="cm-property">place</span> <span class="cm-operator">!=</span> <span class="cm-keyword">this</span>.<span class="cm-property">place</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">p</span>;
        <span class="cm-keyword">return</span> {<span class="cm-property">place</span>: <span class="cm-variable-2">destination</span>, <span class="cm-property">address</span>: <span class="cm-variable-2">p</span>.<span class="cm-property">address</span>};
      }).<span class="cm-property">filter</span>(<span class="cm-def">p</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">p</span>.<span class="cm-property">place</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">p</span>.<span class="cm-property">address</span>);
      <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">VillageState</span>(<span class="cm-variable-2">destination</span>, <span class="cm-variable-2">parcels</span>);
    }
  }
}</pre>

<p>متد <code>move</code> جایی است که کار صورت می گیرد. این متد ابتدا وجود مسیری بین مکان فعلی و مقصد را بررسی می‌کند، و در صورت نبود مسیر، وضعیت قبلی را برمی گرداند، دلیل آن هم این است که حرکت خواسته شده معتبر نیست.</p>

<p>سپس، یک وضعیت جدید ایجاد می‌کند که در آن، مقصد به عنوان مکان جدید ربات در نظر گرفته‌ می شود. همچنین لازم است تا یک مجموعه‌ی جدید از بسته‌ها ایجاد شود – بسته‌هایی که ربات در حال حمل آن‌ها است ( در مکان فعلی ربات قرار دارند) و باید به مکان جدید برده شوند. و بسته‌هایی که مقصدشان مکان جدید است و باید تحویل داده شوند  – که باید از مجموعه‌ی بسته‌های تحویل داده نشده، حذف شوند. فراخوانی <code>map</code> عمل حرکت ربات و فراخوانی <code>filter</code> کار تحویل بسته‌ها را انجام می دهد.</p>

<p>اشیاء مربوط به بسته‌ها،  زمانی که جابه‌جا می شوند تغییری نمی کنند بلکه از نو ایجاد می شوند. متد <code>move</code> به ما وضعیت جدیدی از روستا را می دهد و حالت قبلی را دست‌نخورده باقی می گذارد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Z0crEkc0Bs" href="#c_Z0crEkc0Bs" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">first</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">VillageState</span>(
  <span class="cm-string">&quot;Post Office&quot;</span>,
  [{<span class="cm-property">place</span>: <span class="cm-string">&quot;Post Office&quot;</span>, <span class="cm-property">address</span>: <span class="cm-string">&quot;Alice's House&quot;</span>}]
);
<span class="cm-keyword">let</span> <span class="cm-def">next</span> <span class="cm-operator">=</span> <span class="cm-variable">first</span>.<span class="cm-property">move</span>(<span class="cm-string">&quot;Alice's House&quot;</span>);

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">next</span>.<span class="cm-property">place</span>);
<span class="cm-comment">// → Alice's House</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">next</span>.<span class="cm-property">parcels</span>);
<span class="cm-comment">// → []</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">first</span>.<span class="cm-property">place</span>);
<span class="cm-comment">// → Post Office</span></pre>

<p>متد <code>move</code> باعث می شود که بسته، تحویل داده شود و این عمل در وضعیت بعدی قابل مشاهده است. اما وضعیت ابتدایی هنوز شرایطی را نشان می دهد که ربات در دفتر پست است و بسته تحویل داده نشده است.</p>

<h2><a class="h_ident" id="h_IYubiS5alq" href="#h_IYubiS5alq" tabindex="-1" role="presentation"></a>داده‌های پایا (Persistent Data)</h2>

<p><a class="p_ident" id="p_PmPz1w2C5d" href="#p_PmPz1w2C5d" tabindex="-1" role="presentation"></a>ساختارهای داده‌ای که تغییر نمی کنند را تغییرناپذیر (<em>immutable</em>) یا پایا (<em>persistent</em>) می‌نامند.  این ساختار‌ها، بسیار شبیه به رشته‌ها و اعداد عمل می کنند، یعنی همیشه آنی خواهند بود که هستند و به همین حالت می مانند، نه اینکه در زمان‌های مختلف محتوای مختلفی داشته باشند.</p>

<p>در جاوااسکریپت، تقریبا همه چیز را <em>می توان</em> تغییر داد. بنابراین کار کردن با مقدارهایی که قرار است پایا باشند موانعی خواهد داشت.  تابعی به نام <bdo><code>Object.freeze</code></bdo> وجود دارد که در صورت اعمال به یک شیء، باعث می شود نتوان خاصیت‌های آن شیء را تغییر داد. اگر قصد دارید تا جوانب احتیاط را رعایت کنید، می توانید از این متد برای جلوگیری از تغییر شیءتان استفاده کنید. ثابت‌ نگه‌داشتن شیء باعث می شود که کامپیوتر کار بیشتری انجام دهد، و در نظر نگرفتن  به‌روز‌رسانی اشیاء، به احتمال زیاد افراد را به اشتباه‌ می اندازد. بنابراین من معمولا ترجیح می دهم که به دیگران اعلام کنم که یک فلان شیء را نباید دستکاری کرد و امیدوار باشم که دیگران هم رعایت کنند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_tzmey+74SE" href="#c_tzmey+74SE" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">object</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">freeze</span>({<span class="cm-property">value</span>: <span class="cm-number">5</span>});
<span class="cm-variable">object</span>.<span class="cm-property">value</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object</span>.<span class="cm-property">value</span>);
<span class="cm-comment">// → 5</span></pre>

<p>چرا اصرار دارم که اشیاء را تغییر ندهم، با اینکه زبان به روشنی این کار را مجاز می داند؟</p>

<p><a class="p_ident" id="p_NTGCZMmpj6" href="#p_NTGCZMmpj6" tabindex="-1" role="presentation"></a>زیرا این کار به من در درک برنامه‌ها کمک می‌کند. این موضوع دوباره به مدیریت پیچیدگی برنامه باز می‌گردد.  زمانی که اشیاء در سیستم من چیزهایی ثابت و پایدار هستند، می توانم فرض کنم که عملیات روی آن‌ها در فضایی جداگانه انجام می پذیرد – رفتن به خانه‌ی Alice، از یک وضعیت ابتدایی داده شده، همیشه وضعیت جدید یکسانی را تولید می‌کند. زمانی که اشیاء در طول زمان تغییر می کنند، این کار باعث اضافه شدن بعد دیگری از پیچیدگی به این‌گونه نتیجه‌گیری می گردد.</p>

<p>برای یک سیستم کوچک مانند چیزی که در این فصل در حال ساخت آن هستیم، می توانیم از پس این پیچیدگی اضافی بر بیاییم. اما مهم‌ترین محدودیتی که در نوع سیستم‌هایی که می توانیم بسازیم وجود دارد آن است که تا چه حد می توانیم آن سیستم‌ها را درک کنیم. هر چیزی که درک کد شما را آسان‌تر کند، باعث می شود که بتوانید سیستم بلندپروازانه‌تری بسازید.</p>

<p>متاسفانه، با وجود اینکه درک سیستمی که با ساختارهای داده‌ی پایا ساخته شده آسان تر است، <em>طراحی</em> آن، مخصوصا وقتی که خود زبان برنامه‌نویسی کمکی نمی‌کند، ممکن است کمی مشکل تر باشد. با این حال، ما به دنبال فرصت‌هایی برای استفاده از ساختارهای داده پایا در این کتاب خواهیم بود، همچنین از موارد قابل تغییر نیز استفاده خواهیم کرد.</p>

<h2><a class="h_ident" id="h_vcflslSyki" href="#h_vcflslSyki" tabindex="-1" role="presentation"></a>شبیه‌سازی</h2>

<p>یک ربات تحویل دهنده به جهان پیرامون خود نگاه می‌کند و تصمیم می گیرد که از کدام جهت باید حرکت کند. بر این اساس، می توانیم بگوییم که یک ربات یک تابع است که یک شیء از نوع <code>VillageState</code> را گرفته و نام یک مکان نزدیک را برمی گرداند.</p>

<p>به دلیل اینکه ربات‌ها قادر به برنامه‌ریزی و اجرای آن باشند، باید بتوانند چیزهایی به خاطر بسپارند. پس به آن‌ها حافظه‌شان را ارسال می کنیم و امکان برگرداندن حافظه‌ی جدید را نیز فراهم می‌سازیم . پس، چیزی که یک ربات برمی گرداند شیءای است که دارای دو چیز است:   جهتی که قرار است به سمت آن حرکت کند و یک مقدار حافظه که در فراخوانی بعد استفاده می شود.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_PAmfnoCtiQ" href="#c_PAmfnoCtiQ" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">runRobot</span>(<span class="cm-def">state</span>, <span class="cm-def">robot</span>, <span class="cm-def">memory</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">turn</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;; <span class="cm-variable-2">turn</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">state</span>.<span class="cm-property">parcels</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Done in ${</span><span class="cm-variable-2">turn</span><span class="cm-string-2">}</span> <span class="cm-string-2">turns`</span>);
      <span class="cm-keyword">break</span>;
    }
    <span class="cm-keyword">let</span> <span class="cm-def">action</span> <span class="cm-operator">=</span> <span class="cm-variable-2">robot</span>(<span class="cm-variable-2">state</span>, <span class="cm-variable-2">memory</span>);
    <span class="cm-variable-2">state</span> <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>.<span class="cm-property">move</span>(<span class="cm-variable-2">action</span>.<span class="cm-property">direction</span>);
    <span class="cm-variable-2">memory</span> <span class="cm-operator">=</span> <span class="cm-variable-2">action</span>.<span class="cm-property">memory</span>;
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Moved to ${</span><span class="cm-variable-2">action</span>.<span class="cm-property">direction</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  }
}</pre>

<p>ببینید یک ربات برای اینکه یک وضعیت داده شده را حل کند، چه کار باید انجام دهد. برای برداشتن بسته‌ها، باید به همه‌ی موقعیت‌هایی که بسته دارند برود و برای تحویل آن‌ها، باید به همه‌ی موقعیت‌هایی که بسته‌ای به آنجا آدرس‌دهی شده است سر بزند، البته بعد از اینکه بسته را تحویل گرفت.</p>

<p>احمقانه ترین استراتژی برای حل این موضوع چیست؟ ربات می تواند به صورت تصادفی هر بار به جهتی برود. معنای آن این است که با احتمال زیاد، در نهایت به همه‌ی بسته‌ها دست خواهد یافت و بالاخره به مکان‌هایی که باید آن‌ها را تحویل دهد نیز می رسد.</p>

<p>در این جا می توان نمونه‌ی این کد را دید:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_eldzpwzhOB" href="#c_eldzpwzhOB" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">randomPick</span>(<span class="cm-def">array</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">choice</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">array</span>[<span class="cm-variable-2">choice</span>];
}

<span class="cm-keyword">function</span> <span class="cm-def">randomRobot</span>(<span class="cm-def">state</span>) {
  <span class="cm-keyword">return</span> {<span class="cm-property">direction</span>: <span class="cm-variable">randomPick</span>(<span class="cm-variable">roadGraph</span>[<span class="cm-variable-2">state</span>.<span class="cm-property">place</span>])};
}</pre>

<p>به خاطر داشته باشید که متد <bdo><code>Math.random()</code></bdo> عددی بین صفر و یک تولید می‌کند که همیشه کمتر از یک است. ضرب این عدد در طول یک آرایه و بعد اعمال <bdo><code>Math.floor</code></bdo> به آن باعث می شود که به صورت تصادفی یکی از اندیس‌های آرایه را بدست بیاوریم.</p>

<p>به دلیل اینکه این ربات نیازی ندارد تا چیزی را به خاطر داشته باشد، پس آرگومان دوم در نظر گرفته نمی شود  ( به یاد دارید که در جاوااسکریپت می توان بدون ایجاد خطا، یک تابع را با آرگومان بیشتر فراخوانی کرد) و خاصیت <code>memory</code> را هم در شیء خروجی قرار نمی دهد.</p>

<p>برای بکار انداختن این ربات ، ابتدا لازم است راهی برای ایجاد یک وضعیت جدید به وسیله‌ی چند بسته پیدا کنیم. یک متد ایستا (در اینجا به طور مستقیم با افزودن یک خاصیت به سازنده تعریف می شود) جای خوبی برای این قابلیت است.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_oz9CFlpcci" href="#c_oz9CFlpcci" tabindex="-1" role="presentation"></a><span class="cm-variable">VillageState</span>.<span class="cm-property">random</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">parcelCount</span> <span class="cm-operator">=</span> <span class="cm-number">5</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">parcels</span> <span class="cm-operator">=</span> [];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">parcelCount</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">address</span> <span class="cm-operator">=</span> <span class="cm-variable">randomPick</span>(<span class="cm-variable">Object</span>.<span class="cm-property">keys</span>(<span class="cm-variable">roadGraph</span>));
    <span class="cm-keyword">let</span> <span class="cm-def">place</span>;
    <span class="cm-keyword">do</span> {
      <span class="cm-variable-2">place</span> <span class="cm-operator">=</span> <span class="cm-variable">randomPick</span>(<span class="cm-variable">Object</span>.<span class="cm-property">keys</span>(<span class="cm-variable">roadGraph</span>));
    } <span class="cm-keyword">while</span> (<span class="cm-variable-2">place</span> <span class="cm-operator">==</span> <span class="cm-variable-2">address</span>);
    <span class="cm-variable-2">parcels</span>.<span class="cm-property">push</span>({<span class="cm-property">place</span>, <span class="cm-property">address</span>});
  }
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">VillageState</span>(<span class="cm-string">&quot;Post Office&quot;</span>, <span class="cm-variable-2">parcels</span>);
};</pre>

<p>بسته‌هایی که آدرس مبدا و مقصدشان یکی است را نیازی نیست در نظر بگیریم.  به همین علت، حلقه <code>do</code>  تا زمانی که مبدا و مقصد برابر باشد، به گرفتن مکان‌ها ادامه می دهد.</p>

<p>بیاید تا یک جهان مجازی را شروع کنیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_1SZDRlmBkn" href="#c_1SZDRlmBkn" tabindex="-1" role="presentation"></a><span class="cm-variable">runRobot</span>(<span class="cm-variable">VillageState</span>.<span class="cm-property">random</span>(), <span class="cm-variable">randomRobot</span>);
<span class="cm-comment">// → Moved to Marketplace</span>
<span class="cm-comment">// → Moved to Town Hall</span>
<span class="cm-comment">// → …</span>
<span class="cm-comment">// → Done in 63 turns</span></pre>

<p>برای تحویل بسته‌ها، ربات باید حرکت‌های زیادی انجام دهد به این خاطر که از پیش به خوبی برنامه‌ریزی نشده است. به زودی این مشکل را حل خواهیم کرد.</p>

<p>برای دیدن نمایی بهتر از شبیه‌سازی، می توانید از تابع <code>runRobotAnimation</code> استفاده کنید که در <a href="https://eloquentjavascript.net/code/#7">فضای برنامه‌نویسی این فصل</a> موجود است. این تابع برای شبیه‌سازی، به جای استفاده از متن ساده، از حرکت ربات در نقشه‌ی روستا استفاده می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_jWQlJ73x2Z" href="#c_jWQlJ73x2Z" tabindex="-1" role="presentation"></a><span class="cm-variable">runRobotAnimation</span>(<span class="cm-variable">VillageState</span>.<span class="cm-property">random</span>(), <span class="cm-variable">randomRobot</span>);</pre>

<p>نحوه‌ی پیاده‌سازی تابع <code>runRobotAnimation</code> فعلا سربسته می ماند، اما بعد از اینکه <a href="14_dom.html">فصل‌‌های بعدی</a> کتاب را خواندید، که به موضوع جاوااسکریپت در مرورگر‌های وب می پردازد، می توانید حدس بزنید که چگونه کار می کند.</p>

<h2><a class="h_ident" id="h_cFXn83ngMD" href="#h_cFXn83ngMD" tabindex="-1" role="presentation"></a>مسیر ماشین پست</h2>

<p>باید بتوانیم کاری بهتر از ساخت یک ربات تصادفی انجام دهیم. یک بهبود ساده می تواند الهام گیری از سیستم تحویل پست در دنیای واقعی باشد . اگر مسیری پیدا کنیم که از همه‌ی خانه‌های روستا بگذرد، ربات می تواند از آن مسیر دو مرتبه عبور کند. با این کار می توان ضمانت کرد که ماموریتش را انجام می دهد. در این جا مسیری با این مشخصات آورده شده است (شروع از دفتر پست):</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_smZcG/wBFx" href="#c_smZcG/wBFx" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">mailRoute</span> <span class="cm-operator">=</span> [
  <span class="cm-string">&quot;Alice's House&quot;</span>, <span class="cm-string">&quot;Cabin&quot;</span>, <span class="cm-string">&quot;Alice's House&quot;</span>, <span class="cm-string">&quot;Bob's House&quot;</span>,
  <span class="cm-string">&quot;Town Hall&quot;</span>, <span class="cm-string">&quot;Daria's House&quot;</span>, <span class="cm-string">&quot;Ernie's House&quot;</span>,
  <span class="cm-string">&quot;Grete's House&quot;</span>, <span class="cm-string">&quot;Shop&quot;</span>, <span class="cm-string">&quot;Grete's House&quot;</span>, <span class="cm-string">&quot;Farm&quot;</span>,
  <span class="cm-string">&quot;Marketplace&quot;</span>, <span class="cm-string">&quot;Post Office&quot;</span>
];</pre>

<p>برای پیاده‌سازی ربات مسیرپیما، باید از حافظه‌ی ربات استفاده کنیم.  ربات مسیر باقی‌مانده را در حافظه‌اش نگه داری می کند و با هر بار جابه‌جایی، اولین عنصر  را از آن خارج می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_FlV5rBgCYM" href="#c_FlV5rBgCYM" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">routeRobot</span>(<span class="cm-def">state</span>, <span class="cm-def">memory</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">memory</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
    <span class="cm-variable-2">memory</span> <span class="cm-operator">=</span> <span class="cm-variable">mailRoute</span>;
  }
  <span class="cm-keyword">return</span> {<span class="cm-property">direction</span>: <span class="cm-variable-2">memory</span>[<span class="cm-number">0</span>], <span class="cm-property">memory</span>: <span class="cm-variable-2">memory</span>.<span class="cm-property">slice</span>(<span class="cm-number">1</span>)};
}</pre>

<p><a class="p_ident" id="p_S/aRrNXGNE" href="#p_S/aRrNXGNE" tabindex="-1" role="presentation"></a>این ربات از ربات قبلی بسیار سریع تر عمل می کند. در حالت بیشینه 26 حرکت خواهد داشت، ( دو برابر مسیر 13 گامه)، اما معمولا کمتر طول خواهد کشید.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_EkwtJVsUrQ" href="#c_EkwtJVsUrQ" tabindex="-1" role="presentation"></a><span class="cm-variable">runRobotAnimation</span>(<span class="cm-variable">VillageState</span>.<span class="cm-property">random</span>(), <span class="cm-variable">routeRobot</span>, []);</pre>

<h2><a class="h_ident" id="h_wBSC7hceKm" href="#h_wBSC7hceKm" tabindex="-1" role="presentation"></a>مسیریابی</h2>

<p>هنوز، نمی توانم دنباله‌روی کورکورانه از یک مسیر ثابت را واقعا یک رفتار هوشمندانه بنامم. اگر رفتار ربات را به سمت کاری که واقعا باید انجام دهد اصلاح کنیم، می تواند با کارایی بیشتری عمل کند.</p>

<p>برای این کار، باید بتواند به صورت دلخواه به سمت یک بسته‌ی مشخص، یا جایی که قرار است بسته تحویل داده شود حرکت کند. انجام این‌ کار، حتی زمانی که تا هدف تنها دو گام یا بیشتر فاصله دارد، به نوعی مسیریابی نیاز دارد.</p>

<p><a class="p_ident" id="p_wwW0b1Mdqm" href="#p_wwW0b1Mdqm" tabindex="-1" role="presentation"></a>مساله پیدا کردن یک مسیر در یک گراف، یک <em>مساله‌ی جستجوی</em> معمولی است. ما می توانیم بگوییم که یک راه‌حل داده‌شده (یک مسیر) راه حلی معتبر است؛ اما نمی توانیم به همان صورت که 2+2 را محاسبه می کنیم، به طور مستقیم راه حل را به دست بیاوریم. در عوض، باید به ایجاد راه‌حل‌های بالقوه ادامه دهیم تا زمانی که به مورد صحیح برسیم.</p>

<p><a class="p_ident" id="p_/bnyU8N/s2" href="#p_/bnyU8N/s2" tabindex="-1" role="presentation"></a>تعداد مسیرهای ممکن در یک گراف نامتناهی است. اما زمانی که به دنبال مسیری از نقطه‌ی <em>A</em> به <em>B</em> هستیم، تنها به مسیرهایی توجه می کنیم که از نقطه‌ی <em>A</em> شروع می شوند. همچنین به مسیرهایی که دوبار از یک مکان عبور می کنند، اهمیت نمی دهیم –  آن‌ها قطعا نمی توانند بهترین مسیر باشند. بنابراین، تعداد مسیرهایی که مسیریاب باید در نظر بگیرد کاهش می یابند.</p>

<p>در واقع، ما بیشتر علاقمندیم تا <em>کوتاهترین</em> مسیر را پیدا کنیم. بنابراین باید اطمینان حاصل کنیم که پیش از مسیرهای بلند‌تر، مسیرهای کوتاه بررسی می شوند. یک راه حل خوب می تواند این باشد که از نقطه‌ی شروع، مسیرها را “رشد” دهیم، و هر مکان قابل دسترسی که قبلا بازدید نکرده‌ایم را بررسی کنیم تا اینکه یک مسیر به هدفش برسد. به این ترتیب، ما فقط مسیرهایی را کشف خواهیم کرد که به صورت بالقوه مرتبط به نظر می‌رسند و درنتیجه کوتاه‌ترین مسیر را تا هدف پیدا خواهیم کرد ( یا یکی از کوتاه‌ترین مسیرها در صورتی که بیش از یک مسیر وجود داشته باشد).</p>

<p id="findRoute">تابع زیر این کار را انجام می دهد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_qT/+IETEgM" href="#c_qT/+IETEgM" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">findRoute</span>(<span class="cm-def">graph</span>, <span class="cm-def">from</span>, <span class="cm-def">to</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">work</span> <span class="cm-operator">=</span> [{<span class="cm-property">at</span>: <span class="cm-variable-2">from</span>, <span class="cm-property">route</span>: []}];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">work</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">let</span> {<span class="cm-def">at</span>, <span class="cm-def">route</span>} <span class="cm-operator">=</span> <span class="cm-variable-2">work</span>[<span class="cm-variable-2">i</span>];
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">place</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">graph</span>[<span class="cm-variable-2">at</span>]) {
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">place</span> <span class="cm-operator">==</span> <span class="cm-variable-2">to</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">route</span>.<span class="cm-property">concat</span>(<span class="cm-variable-2">place</span>);
      <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">work</span>.<span class="cm-property">some</span>(<span class="cm-def">w</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">w</span>.<span class="cm-property">at</span> <span class="cm-operator">==</span> <span class="cm-variable-2">place</span>)) {
        <span class="cm-variable-2">work</span>.<span class="cm-property">push</span>({<span class="cm-property">at</span>: <span class="cm-variable-2">place</span>, <span class="cm-property">route</span>: <span class="cm-variable-2">route</span>.<span class="cm-property">concat</span>(<span class="cm-variable-2">place</span>)});
      }
    }
  }
}</pre>

<p>بررسی مکان‌ها باید با ترتیب درست انجام شود – مکان‌هایی که ربات زودتر به آن ها رسیده است را باید زودتر بررسی کرد. نمی توانیم یک مکان را به محض اینکه به آن رسیدیم مورد بررسی قرار دهیم زیرا در این صورت مکان‌هایی که از آن نقطه به دست می‌آیند را نیز باید بلافاصله بررسی کنیم و به همین ترتیب ادامه دهیم؛ در حالیکه ممکن است مسیرهای کوتاه تری باشند که اصلا بررسی نشده اند.</p>

<p>بنابراین، تابع <em>فهرستی از کارها</em> را نگه داری می کند. این فهرست یک آرایه از مکان‌هایی است که باید در گام بعدی بررسی شود، به همراه مسیری که ما را به آنجا می‌رساند. این فهرست کار، در ابتدا فقط یک موقعیت شروع و یک مسیر خالی دارد.</p>

<p>سپس جستجو مورد بعدی در فهرست را می‌گیرد و آن را بررسی می کند، به این معنا که همه‌ی راه‌هایی که از آن مکان عبور می کنند دیده می شوند. اگر یکی از آن ها هدف باشد، یک مسیر کامل می تواند برگردانده شود. در غیر این صورت، اگر قبلا به این مکان نگاه نکرده باشیم، یک مورد جدید به فهرست اضافه می شود. اگر قبلا آن را دیده باشیم، از آنجا که ما اول مسیرهای کوتاه تر را بررسی می کنیم، یا یک مسیر طولانی تر به آن محل را پیدا کرده ایم یا مسیری دقیقا برابر با مسیر که در فهرست وجود دارد؛ پس نیازی نیست که آن را مورد بررسی قرار دهیم.</p>

<p>می توان آن را به عنوان یک شبکه‌ای مانند تار عنکبوت در نظر گرفت که از موقعیت شروع به صورت برابر و به سمت همه‌ی اضلاع به بیرون پیموده می شود ( اما تارها با هم قاطی و پیچیده نمی شوند). به محض اینکه اولین تار به مکان هدف رسید، این تار تا نقطه‌ی شروع رصد می شود و مسیر را مشخص می کند.</p>

<p><a class="p_ident" id="p_xeI0V6p8Kz" href="#p_xeI0V6p8Kz" tabindex="-1" role="presentation"></a>کد ما حالتی که در آرایه‌ی فهرست‌ کارها، موردی وجود نداشته باشد را در نظر نمی‌گیرد زیرا می دانیم که گراف ما یک گراف <em>متصل</em> است (<em>connected</em>) به این معنی که هر مکان را می توان از همه‌ی مکان‌های دیگر بدست آورد. همیشه قادر خواهیم بود مسیری بین دو نقطه پیدا کنیم و عمل جستجو هرگز با شکست روبرو نمی شود.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_RJgvG9cgxq" href="#c_RJgvG9cgxq" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">goalOrientedRobot</span>({<span class="cm-def">place</span>, <span class="cm-def">parcels</span>}, <span class="cm-def">route</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">route</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">parcel</span> <span class="cm-operator">=</span> <span class="cm-variable-2">parcels</span>[<span class="cm-number">0</span>];
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">parcel</span>.<span class="cm-property">place</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">place</span>) {
      <span class="cm-variable-2">route</span> <span class="cm-operator">=</span> <span class="cm-variable">findRoute</span>(<span class="cm-variable">roadGraph</span>, <span class="cm-variable-2">place</span>, <span class="cm-variable-2">parcel</span>.<span class="cm-property">place</span>);
    } <span class="cm-keyword">else</span> {
      <span class="cm-variable-2">route</span> <span class="cm-operator">=</span> <span class="cm-variable">findRoute</span>(<span class="cm-variable">roadGraph</span>, <span class="cm-variable-2">place</span>, <span class="cm-variable-2">parcel</span>.<span class="cm-property">address</span>);
    }
  }
  <span class="cm-keyword">return</span> {<span class="cm-property">direction</span>: <span class="cm-variable-2">route</span>[<span class="cm-number">0</span>], <span class="cm-property">memory</span>: <span class="cm-variable-2">route</span>.<span class="cm-property">slice</span>(<span class="cm-number">1</span>)};
}</pre>

<p>این ربات از مقدار حافظه‌ی خود به عنوان یک لیست از جهت‌ها برای حرکت استفاده می‌کند، درست مانند ربات مسیرپیما. هر زمان که این لیست خالی می شود، ربات باید گام بعدی را کشف کند. برای این‌کار، به سراغ اولین بسته‌ی تحویل داده نشده در این مجموعه می‌رود، و اگر آن بسته هنوز برداشته نشده بود، مسیری به سمت آن طرح ریزی می‌کند. اگر قبلا تحویل گرفته شده باشد، پس هنوز باید تحویل داده شود، بنابراین ربات، مسیری به سمت آدرس تحویل ایجاد می‌کند.</p>

<p>بیایید ببینیم چگونه کار می‌کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_yYuNlgXLX9" href="#c_yYuNlgXLX9" tabindex="-1" role="presentation"></a><span class="cm-variable">runRobotAnimation</span>(<span class="cm-variable">VillageState</span>.<span class="cm-property">random</span>(),
                  <span class="cm-variable">goalOrientedRobot</span>, []);</pre>

<p><a class="p_ident" id="p_8cujr+n2Lu" href="#p_8cujr+n2Lu" tabindex="-1" role="presentation"></a>این ربات معمولا تحویل 5 بسته را در 16 حرکت انجام می دهد. کمی بهتر از <code>routeRobot</code> کار می‌کند اما قطعا هنوز بهینه نیست.</p>

<h2><a class="h_ident" id="h_ggOFdVwDCk" href="#h_ggOFdVwDCk" tabindex="-1" role="presentation"></a>تمرین‌ها</h2>

<h3><a class="i_ident" id="i_relI12WB8+" href="#i_relI12WB8+" tabindex="-1" role="presentation"></a>اندازه‌گیری یک ربات</h3>

<p>خیلی سخت بتوان ربات‌ها را بر اساس حل چند مساله‌ی محدود به طور صحیح مقایسه کرد. شاید یک ربات به صورت تصادفی با مساله‌های آسان روبرو شود یا مسائلی که در حل آن ها بهتر عمل می کند. اما دیگر ربات‌ها این شرایط را نداشته باشند.</p>

<p>تابعی به نام <code>compareRobots</code> بنویسید که دو ربات را دریافت می‌کند (به همراه حافظه‌ی شروع‌شان).  تابع باید صد وظیفه ایجاد کرده و هر یک از ربات ها باید همه‌ی وظایف را انجام دهند. پس از پایان، متوسط تعداد گام‌هایی که هر ربات برای یک وظیفه برداشته است را برگرداند.</p>

<p>برای رعایت عدالت، مطمئن شوید که هر وظیفه توسط هر دوی ربات ها انجام می شود و از ایجاد وظایف جدید برای هر ربات پرهیز کنید.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Pif/U+hwqO" href="#c_Pif/U+hwqO" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">compareRobots</span>(<span class="cm-def">robot1</span>, <span class="cm-def">memory1</span>, <span class="cm-def">robot2</span>, <span class="cm-def">memory2</span>) {
  <span class="cm-comment">// Your code here</span>
}

<span class="cm-variable">compareRobots</span>(<span class="cm-variable">routeRobot</span>, [], <span class="cm-variable">goalOrientedRobot</span>, []);</pre>

<div class="solution"><div class="solution-text">

<p>برای این‌کار باید نسخه‌ای متفاوت از تابع <code>runRobot</code> را بنویسید که به جای چاپ گزارش رخداد‌ها در کنسول مرورگر، تعداد گام‌هایی که ربات برای انجام وظیفه طی کرده است را برگرداند.</p>

<p>تابع اندازه‌گیری شما می تواند به وسیله‌ی یک حلقه، وضعیت‌های جدید تولید کند و تعداد گام‌های هر ربات‌ را بشمارد. هنگامی‌ که به تعداد کافی اندازه‌گیری انجام شد، می توان از <bdo><code>console.log</code></bdo> برای قراردادن متوسط گام‌های طی‌شده توسط هر ربات در خروجی استفاده کرد که این متوسط با تقسیم مجموع گام‌ها بر تعداد اندازه‌گیری‌ها بدست می‌آید.</p>

</div></div>

<h3><a class="i_ident" id="i_LMC1VH9SZD" href="#i_LMC1VH9SZD" tabindex="-1" role="presentation"></a>کارایی ربات</h3>

<p>آیا می توانید رباتی بنویسید که وظیفه تحویل بسته‌ها را سریع تر از ربات <code>goalOrientedRobot</code> انجام دهد؟ با مشاهده‌ی دقیق رفتار آن، چه اشتباهات روشنی انجام می‌دهد؟ چگونه می توان آن ها را بهبود بخشید؟</p>

<p>اگر تمرین قبلی را حل کرده اید، ممکن است بخواهید از تابع <code>compareRobots</code> که نوشته اید برای برای بررسی بهبود ربات جدید استفاده کنید.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_kgk5f055Ej" href="#c_kgk5f055Ej" tabindex="-1" role="presentation"></a><span class="cm-comment">// Your code here</span>

<span class="cm-variable">runRobotAnimation</span>(<span class="cm-variable">VillageState</span>.<span class="cm-property">random</span>(), <span class="cm-variable">yourRobot</span>, <span class="cm-variable">memory</span>);</pre>

<div class="solution"><div class="solution-text">

<p>محدودیت اصلی ربات <code>goalOrientedRobot</code> این است که در هر لحظه فقط یک بسته‌ را در نظر می‌گیرد. با این‌ کار، حتی زمانی که دیگر بسته‌ها در نزدیکی آن هستند،  اغلب بین خانه‌های روستا به عقب و جلو حرکت می‌کند زیرا بسته‌ای که ممکن است به دنبال آن باشد شاید در طرف دیگر نقشه است.</p>

<p>یک راه‌حل محتمل می تواند این باشد که مسیر‌ها را برای همه‌ی بسته‌ها محاسبه کنید و کوتاه‌ترین آن‌ها را برگزینید. در شرایطی که چند مسیر کوتاه‌ در دسترس است، می تواند با ترجیح مسیرهای برداشتن بسته‌ها به مسیر‌های تحویل، نتیجه‌ی بهتری گرفت.</p>

</div></div>

<h3><a class="i_ident" id="i_8Zokh060Ru" href="#i_8Zokh060Ru" tabindex="-1" role="presentation"></a>گروه پایا (Persistent Group)</h3>

<p>اکثر ساختارهای داده‌ای که به صورت استاندارد در جاوااسکریپت وجود دارند، برای استفاده به عنوان ساختار داده‌ی پایا، خیلی مناسب نیستند. آرایه ها دارای متدهای <code>slice</code>  و  <code>concat</code> می باشند که این امکان را فراهم می سازند تا آرایه های جدید را بدون تغییر آرایه‌ی اصلی ایجاد کنیم. اما مثلا <code>Set</code>، متدی برای ایجاد یک مجموعه‌ی جدید که آیتمی اضافه یا کم داشته باشد ندارد.</p>

<p>کلاس جدیدی به نام <code>PGroup</code> بنویسید، شبیه‌ به کلاس <code>Group</code> که در <a href="06_object.html#groups">فصل 6</a> نوشتید، که مجموعه‌ای از مقادیر را ذخیره می‌کند. مانند <code>Group</code> دارای متدهای <code>add،</code> <code>delete</code> و <code>has</code> خواهد بود.</p>

<p>متد <code>add</code> آن، باید نمونه‌ی <em>جدیدی</em>  از <code>‌PGroup</code> را که شامل عضو جدید می باشد، تولید کند و نمونه‌ی قبلی را دست نخورده باقی بگذارد. به طور مشابه، متد <code>delete</code> نمونه‌ی جدیدی بدون عضو داده شده، تولید می‌کند.</p>

<p>کلاس مورد نظر باید بتواند علاوه بر رشته‌، هر نوع داده‌ای را به عنوان کلید قبول کند. نیازی <em>نیست</em> تا کارایی بالایی در کار با تعداد بالای کلیدها داشته باشد.</p>

<p>سازنده نباید بخشی از رابط کلاس باشد ( اگرچه حتما لازم است که به صورت درونی از آن استفاده کنید). در عوض، یک نمونه‌ی تهی به نام <bdo><code>PGroup.empty</code></bdo> باید باشد که بتوان از آن برای مقدار ابتدایی استفاده کرد.</p>

<p>چرا به جای داشتن تابعی که بتواند هر بار یک نگاشت تهی جدید ایجاد کند، لازم است تا فقط یک <bdo><code>PGroup.empty</code></bdo> وجود داشته باشد؟</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_KN+ky/iMYB" href="#c_KN+ky/iMYB" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">PGroup</span> {
  <span class="cm-comment">// Your code here</span>
}

<span class="cm-keyword">let</span> <span class="cm-def">a</span> <span class="cm-operator">=</span> <span class="cm-variable">PGroup</span>.<span class="cm-property">empty</span>.<span class="cm-property">add</span>(<span class="cm-string">&quot;a&quot;</span>);
<span class="cm-keyword">let</span> <span class="cm-def">ab</span> <span class="cm-operator">=</span> <span class="cm-variable">a</span>.<span class="cm-property">add</span>(<span class="cm-string">&quot;b&quot;</span>);
<span class="cm-keyword">let</span> <span class="cm-def">b</span> <span class="cm-operator">=</span> <span class="cm-variable">ab</span>.<span class="cm-property">delete</span>(<span class="cm-string">&quot;a&quot;</span>);

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">b</span>.<span class="cm-property">has</span>(<span class="cm-string">&quot;b&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">a</span>.<span class="cm-property">has</span>(<span class="cm-string">&quot;b&quot;</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">b</span>.<span class="cm-property">has</span>(<span class="cm-string">&quot;a&quot;</span>));
<span class="cm-comment">// → false</span></pre>

<div class="solution"><div class="solution-text">

<p>همچنان سرراست‌ترین روش نمایش یک مجموعه‌ از اعضا، آرایه است،‌ زیرا آرایه‌ها را می توان به راحتی کپی کرد.</p>

<p>با اضافه‌شدن یک مقدار به گروه، می توانید با کپی کردن آرایه‌ی اصلی، گروه جدیدی ایجاد کنید که شامل عنصر جدید باشد (به عنوان مثال، به وسیله‌ی <code>concat</code>). با حذف یک مقدار، می توانید آن را از آرایه فیلتر کنید.</p>

<p><a class="p_ident" id="p_w77GvLybnw" href="#p_w77GvLybnw" tabindex="-1" role="presentation"></a>سازنده‌ی کلاس می تواند این آرایه را به عنوان آرگومان دریافت کند و آن را به عنوان تنها خاصیت نمونه‌ (instance) ذخیره نماید. این آرایه هرگز تغییر نمی کند.</p>

<p>برای افزودن یک خاصیت غیر متد (<code>empty</code>) به یک سازنده، باید بعد از تعریف کلاس، آن را مانند یک خاصیت معمولی به سازنده اضافه کنید.</p>

<p>شما فقط به یک نمونه‌ی <code>empty</code> نیاز دارید زیرا تمامی گروه‌های تهی، مانند هم هستند و نمونه‌های کلاس تغییر نمی کنند. می توانید از همان گروه تهی واحد، گروه‌های متفاوت زیادی ایجاد کنید بدون آن‌که روی آن اثری داشته باشد.</p>

</div></div><nav><a href="06_object.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="08_error.html" title="next chapter">▶</a></nav>
</article>
