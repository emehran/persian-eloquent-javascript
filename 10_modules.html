<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ماژول‌ها :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 10;var sandboxLoadFiles = ["code/packages_chapter_10.js","code/chapter/07_robot.js"];</script><script>var clicky_site_ids = clicky_site_ids || []; clicky_site_ids.push(101171577);</script>
  <script async src="//static.getclicky.com/js"></script>

</head>

<article>
<nav><a href="09_regexp.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="11_async.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>Chapter 10</span>ماژول‌ها</h1>

<blockquote>

<p><a class="p_ident" id="p_OwlHMaRbBt" href="#p_OwlHMaRbBt" tabindex="-1" role="presentation"></a>Write code that is easy to delete, not easy to extend.</p>

<footer>Tef, <cite>Programming is Terrible</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_10.jpg" alt="Picture of a building built from modular pieces"></figure>

<p><a class="p_ident" id="p_2jmj7l5rSw" href="#p_2jmj7l5rSw" tabindex="-1" role="presentation"></a>یک برنامه‌ی ایده‌آل دارای ساختاری شفاف و روشن است. به راحتی می توان کارکرد آن را توضیح داد و هر بخش￼ آن نقشی را ایفا می کند که به خوبی تعریف شده است.</p>

<p>معمولا یک برنامه‌ی واقعی به شکلی ارگانیک رشد می کند. قابلیت‌های جدید، همانطور که لازم می شوند به برنامه افزوده شوند. ساختاردهی – و حفظ ساختار – کاری مجزایی است. کاری است که فقط در آینده با مزایای آن روبرو می‌شوید زمانی که کسی دوباره روی برنامه قرار است کار کند. پس ممکن است وسوسه‌انگیز باشد که از آن غفلت کنید و بگذارید بخش‌های برنامه عمیقا دچار آشفتگی شوند.</p>

<p>در عمل این غفلت دو اشکال ایجاد می کند. اول اینکه درک یک سیستم بدون‌ ساختار مشکل است. اگر همه‌ی بخش‌های برنامه در تماس با دیگر بخش‌ها باشند، سخت می توان بخشی از برنامه را به صورت جداگانه بررسی نمود. شما مجبورید که درکی کلی و جامع از برنامه داشته باشید. دوم اینکه، اگر بخواهید هر کدام از قابلیت‌های برنامه‌ای اینچنینی را در جایی دیگر استفاده کنید، از اول نوشتن آن قابلیت ممکن است از جداسازی آن از برنامه، آسان تر باشد.</p>

<p><a class="p_ident" id="p_yhmJYha4k4" href="#p_yhmJYha4k4" tabindex="-1" role="presentation"></a>اصطلاح “big ball of mud” (توپ‌ بزرگ گلی) اغلب برای برنامه‌های بزرگی که ساختاری ندارند استفاده می شود. همه چیز به هم چسبیده است و زمانی که قصد دارید یک قسمت را جدا کنید، کل آن قسمت یا برنامه متلاشی می شود و دستانتان را کثیف کند.</p>

<h2><a class="h_ident" id="h_3Uyo5Wx/hs" href="#h_3Uyo5Wx/hs" tabindex="-1" role="presentation"></a>ماژول‌ها</h2>

<p>استفاده از <em>ماژول‌ها</em> تلاشی برای اجتناب از این گونه مشکلات است. یک ماژول بخشی از برنامه است که مشخص می کند به کدام بخش‌های دیگر از برنامه وابسته است (وابستگی‌های آن) و چه قابلیتی برای استفاده‌ی دیگر ماژول ها فراهم می کند (<em>رابط</em> آن).</p>

<p>رابط‌های ماژول شباهت‌ زیادی با رابط‌های شیء دارند، همانطور که با آن ها در<a href="06_object.html#interface">فصل 6</a> آشنا شدیم. رابط‌ها بخشی از ماژول را در دسترس جهان بیرون می گذارند و بقیه‌ی قسمت ها را به صورت خصوصی حفظ می کنند. با محدودسازی راه‌های تعامل ماژول‌ها با یکدیگر ، سیستم بیشتر شبیه لگو می شود، جایی که قطعات توسط متصل‌کننده‌هایی که به خوبی تعریف شده اند با هم تعامل دارند و کمتر به توپ گلی شباهت دارد که همه چیز در آن با هم مخلوط شده است.</p>

<p>ارتباطات بین ماژول ها را <em>وابستگی‌ها</em> می نامند. زمانی که یک ماژول به بخشی از یک ماژول دیگر نیاز دارد، گفته می شود که به آن ماژول وابستگی دارد. زمانی که این وابستگی در خود ماژول به صورت مشخص اعلام شود، می توان از آن برای شناسایی دیگر ماژول‌هایی که لازم است برای اجرای یک ماژول خاص حضور داشته باشند استفاده کرد و به صورت خودکار آن وابستگی‌ها را بارگذاری کرد.</p>

<p>برا جداسازی ماژول‌ها به این روش ، لازم است هر کدام محدوده‌ی خصوصی خودش را داشته باشد.</p>

<p>فقط قرار دادن کدهای جاوااسکریپت در فایل های جداگانه این امکان را فراهم نمی کند. فایل‌ها همچنان فضای نام سراسری یکسانی را به صورت مشترک استفاده می کنند. ممکن است به صورت تصادفی یا آگاهانه بین متغیرهای یکدیگر تداخل ایجاد کنند و ساختار وابستگی همچنان غیر شفاف خواهد ماند. می توان کار بهتری کرد که در ادامه خواهیم دید.</p>

<p>طراحی یک ساختار ماژول مناسب برای یک برنامه ممکن است سخت باشد. در مرحله‌ای که هنوز در حال بررسی مشکل هستید، و چیزهای متفاوتی را آزمایش می کنید، ممکن است علاقه‌ای نداشته باشید که زیاد به ساختاردهی فکر کنید، چرا که می تواند باعث حواسپرتی زیادی بشود. وقتی به نتیجه‌ای استوار و قابل اتکا رسیدید ، آن زمان مناسب برای اقدام جهت سازماندهی برنامه خواهد بود.</p>

<h2><a class="h_ident" id="h_pq4Kg1pCcs" href="#h_pq4Kg1pCcs" tabindex="-1" role="presentation"></a>بسته‌ها</h2>

<p>یکی از مزایای ساختن یک برنامه بر اساس قسمت‌های جداگانه، و داشتن قابلیت اجرای آن قسمت‌ها به صورت مستقل، این است که ممکن است بتوانید آن قسمت‌ها را در برنامه‌های مختلف به کار ببرید.</p>

<p>اما چگونه آن را راه‌اندازی می کنید؟ فرض کنیم من می خواهم که تابع <code>parseINI</code> را که در <a href="09_regexp.html#ini">فصل 9</a> نوشتیم در برنامه‌ی دیگری استفاده کنم. اگر روشن باشد که این تابع چه وابستگی‌هایی دارد (که در اینجا ندارد)، می توانم به سادگی کدهای مورد نیاز را به پروژه‌ی جدیدم کپی کنم و از آن استفاده کنم. اما در این صورت اگر مشکلی در آن کد پیدا کنم، احتمالا آن مشکل را فقط در برنامه‌ای که در حال کار روی آن هستم رفع خواهم کرد و فراموش می کنم که در برنامه‌ی دیگر نیز آن را اصلاح کنم.</p>

<p>به محض اینکه به کپی کردن کدها اقدام کنید متوجه خواهید شد که با جابجا کردن کپی‌ها بین برنامه ها و به روز رسانی آن ها وقت و انرژی خودتان را تلف می کنید.</p>

<p><a class="p_ident" id="p_2K4Iiu6Wk3" href="#p_2K4Iiu6Wk3" tabindex="-1" role="presentation"></a>اینجا‌ است که بسته‌ها <em>packages</em> کاربرد خواهند داشت. یک بسته یک قطعه کد است که می‌تواند توزیع شود (کپی و نصب شود). یک بسته می تواند دارای یک یا چند ماژول باشد و همچنین اطلاعاتی در باره‌ی دیگر بسته‌هایی که به آنها وابسته است دارد. یک بسته همچنین همراه با مستنداتی می آید که کارکرد آن را شرح می دهد، بنابراین کسانی که بسته را ننوشته اند قادر خواهند بود که از آن استفاده کنند.</p>

<p>زمانی که مشکلی در یک بسته شناسایی شود یا ویژگی جدیدی به آن افزوده شود بسته به روز رسانی می گردد. اکنون برنامه‌هایی که به آن وابستگی داشته اند (که خود ممکن است بسته باشند ) می توانند به نسخه جدیدتر به‌روز شوند.</p>

<p id="modules_npm"><a class="p_ident" id="p_HN/3W2IVS2" href="#p_HN/3W2IVS2" tabindex="-1" role="presentation"></a>کارکردن به این روش نیاز به زیرساخت دارد. جایی را نیاز داریم که بسته‌ها را ذخیره و جستجو کنیم و راهی￼ سرراست برای نصب و به روز رسانی آن ها لازم است. در دنیای جاوااسکریپت این زیرساخت توسط NPM در (<a href="https://npmjs.org"><em>https://npmjs.org</em></a>) فراهم شده است.</p>

<p><a class="p_ident" id="p_2Ehj08AuWd" href="#p_2Ehj08AuWd" tabindex="-1" role="presentation"></a>NPM دارای دو بخش است: یک سرویس آنلاین که افراد می توانند به بارگیری و بارگذاری بسته‌ها اقدام کنند و یک برنامه (که به همراه Node.js می آید) که به شما کمک می کند که آن ها را مدیریت کنید.</p>

<p><a class="p_ident" id="p_E1MBXEc91D" href="#p_E1MBXEc91D" tabindex="-1" role="presentation"></a>در زمان نوشتن این کتاب، بیش از نیم میلیون بسته در NPM وجود دارد. باید بگم که بخش زیادی از این بسته‌ها بدرد نخور هستند اما تقریبا هر بسته‌ی مفیدی که عموما در دسترس باشد را می توان آنجا پیدا کرد. به عنوان مثال، یک تجزیه‌گر فایل ini، شبیه به چیزی که خودمان در  <a href="09_regexp.html">فصل 9</a> ساختیم، در بسته‌ای به نام <code>ini</code> وجود دارد.</p>

<p><a href="20_node.html">فصل 20</a> شما را با نحوه‌ی نصب بسته‌ها به صورت محلی و با استفاده از برنامه‌ی خط فرمان <code>npm</code> آشنا خواهد کرد.</p>

<p>در دسترس داشتن بسته‌های باکیفیت قابل دانلود بسیار ارزشمند است. این بدین معناست که می توان از اختراع دوباره یک برنامه در بیشتر مواقع جلوگیری کنیم، برنامه ای که صدها نفر قبل تر نوشته اند و می توان آن را با چند حرکت به صورت استوار و تست شده پیاده سازی کرد.</p>

<p>کپی کردن یک نرم افزار آسان است، بنابراین اگر کسی آن را نوشته باشد، انتشار آن بین دیگر افراد روند کارآمدی محسوب می شود. اما به عنوان فرد اول نوشتن آن کار می برد و پاسخ دادن به افرادی که مشکلاتی را در کد پیدا می‌کنند یا درخواست ویژگی جدیدی را دارند، کار بیشتری می طلبد.</p>

<p><a class="p_ident" id="p_WSnlilqh/e" href="#p_WSnlilqh/e" tabindex="-1" role="presentation"></a>به صورت پیش فرض، شما مالک کپی‌رایت کدی هستید که می نویسید و دیگر افراد فقط با اجازه‌ی شما می توانند از آن استفاده کنند. اما به دلیل اینکه بعضی افراد باحال (nice) هستند و اینکه انتشار یک نرم افزار خوب باعث کمی شهرت بین برنامه نویسان می شود، خیلی از بسته‌ها تحت مجوزی منتشر می شوند که به صراحت اجازه استفاده دیگران از برنامه را می دهد.</p>

<p><a class="p_ident" id="p_fZTrvwf1QX" href="#p_fZTrvwf1QX" tabindex="-1" role="presentation"></a>بیشتر کدهایی که در NPM وجود دارند دارای چنین مجوزی هستند. بعضی از مجوزها از شما می خواهند که کدی که با استفاده از بسته نوشته‌اید را با همان مجوز منتشر کنید. بعضی دیگر کمتر درخواستی دارند و فقط لازم است که مجوزی که همراه بسته وجود دارد را در هنگام توزیع کنار آن نگه دارید. بیشتر جامعه‌ی برنامه نویسی جاوااسکریپت از این نوع مجوز استفاده می کنند. زمانی که از بسته‌های دیگر افراد استفاده می کنید، مطمئن شوید که از مجوز آن آگاهی دارید.</p>

<h2><a class="h_ident" id="h_/lUKS6kqAJ" href="#h_/lUKS6kqAJ" tabindex="-1" role="presentation"></a>فراهم ساختن ماژول‌ها</h2>

<p><a class="p_ident" id="p_nN2mfe0/JY" href="#p_nN2mfe0/JY" tabindex="-1" role="presentation"></a>قبل از 2015 در جاوااسکریپت سیستم ماژول داخلی وجود نداشت. با این وجود برنامه نویسان برای بیشتر از یک دهه، سیستم های بزرگی را برنامه نویسی می کردند درحالیکه <em>نیاز</em> به ماژول‌ها وجود داشت.</p>

<p>بنابراین آن ها سیستم ماژول خودشان را با استفاده از خود زبان طراحی کردند. می توان از توابع جاوااسکریپت برای ایجاد حوزه‌های محلی و از اشیاء به عنوان رابط‌های ماژول استفاده کرد.</p>

<p>مثال زیر یک ماژول برای انتخاب بین نام روزها و عددشان است ( که از متد <code>getDay</code> مربوط به <code>Date</code> استفاده می کند). رابط آن از <bdo><code>weekDay.name</code></bdo> و <bdo><code>weekDay.number</code></bdo> تشکیل شده است و متغیر محلی <code>names</code> را در حوزه‌ی یک تابع که بلادرنگ فراخوانی می شود پنهان می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_m+yRMF5NXw" href="#c_m+yRMF5NXw" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">weekDay</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">const</span> <span class="cm-def">names</span> <span class="cm-operator">=</span> [<span class="cm-string">&quot;Sunday&quot;</span>, <span class="cm-string">&quot;Monday&quot;</span>, <span class="cm-string">&quot;Tuesday&quot;</span>, <span class="cm-string">&quot;Wednesday&quot;</span>,
                 <span class="cm-string">&quot;Thursday&quot;</span>, <span class="cm-string">&quot;Friday&quot;</span>, <span class="cm-string">&quot;Saturday&quot;</span>];
  <span class="cm-keyword">return</span> {
    <span class="cm-property">name</span>(<span class="cm-def">number</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>[<span class="cm-variable-2">number</span>]; },
    <span class="cm-property">number</span>(<span class="cm-def">name</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">name</span>); }
  };
}();

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">name</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">number</span>(<span class="cm-string">&quot;Sunday&quot;</span>)));
<span class="cm-comment">// → Sunday</span></pre>

<p>این سبک از ماژول‌ها، تا حدی ایزوله کردن را فراهم می کند، اما وابستگی را پشتیبانی نمی کند. به جای آن، رابطش را در حوزه‌ی سراسری قرار می دهد، و انتظار دارد که در صورت وجود، وابستگی‌هایش تعریف شده باشند تا بتواند کاری مشابه سیستم وابستگی‌ها انجام دهد. برای مدتی طولانی این روش در برنامه نویسی وب استفاده می شد اما الان تقریبا از رده خارج شده است.</p>

<p>اگر قصد دارید ارتباطات مربوط به وابستگی را به عنوان بخشی از کد داشته باشید، بایستی مدیریت بارگیری وابستگی‌ها را به عهده بگیرید. برای این کار لازم است بتوانیم رشته‌ها را به عنوان کد اجرا کنیم. این کار در جاوااسکریپت قابل اجرا است.</p>

<h2 id="eval"><a class="h_ident" id="h_E7w8weTT/n" href="#h_E7w8weTT/n" tabindex="-1" role="presentation"></a>ارزیابی داده‌ها به عنوان کد‌های اجرایی</h2>

<p>راه‌های متعددی برای گرفتن داده‌ها (یک رشته از کد) و اجرای آن به عنوان بخشی از برنامه کنونی وجود دارد.</p>

<p><a class="p_ident" id="p_qs0xA/Px/K" href="#p_qs0xA/Px/K" tabindex="-1" role="presentation"></a>روشن ترین راه، استفاده از عملگر <code>eval</code> است که رشته‌ای را در قلمروی (scope) <em>فعلی</em> اجرا می کند. این ایده معمولا ایده‌ی بدی محسوب می شود چرا که باعث از بین رفتن بعضی از خاصیت‌هایی می شود که در قلمرو‌ها به صورت نرمال وجود دارند، مثل حدس زدن آسان متغیری که یک نام مشخص به آن ارجاع می دهد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_14x3bOXX9G" href="#c_14x3bOXX9G" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
<span class="cm-keyword">function</span> <span class="cm-def">evalAndReturnX</span>(<span class="cm-def">code</span>) {
  <span class="cm-variable">eval</span>(<span class="cm-variable-2">code</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable">x</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">evalAndReturnX</span>(<span class="cm-string">&quot;var x = 2&quot;</span>));
<span class="cm-comment">// → 2</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">x</span>);
<span class="cm-comment">// → 1</span></pre>

<p>یک راه کم‌خطرتر تفسیر داده به عنوان کد، استفاده از سازنده <code>Function</code> است. این تابع دو آرگومان دریافت می کند: یک رشته که حاوی یک لیست جدا شده با ویرگول از نام آرگومان‌ها است و یک رشته که حاوی بدنه تابع است. این تابع کد را درون یک مقدار تابع می‌پوشاند بنابراین قلمروی مختص به خودش خواهد داشت و تداخلی با دیگر قلمروها نخواهد داشت.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Mc9BAi4AVK" href="#c_Mc9BAi4AVK" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">plusOne</span> <span class="cm-operator">=</span> <span class="cm-variable">Function</span>(<span class="cm-string">&quot;n&quot;</span>, <span class="cm-string">&quot;return n + 1;&quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">plusOne</span>(<span class="cm-number">4</span>));
<span class="cm-comment">// → 5</span></pre>

<p>این دقیقا همان‌ چیزی است که برای یک سیستم ماژول نیاز داریم. می توانیم کدهای ماژول را درون یک تابع قرار دهیم و از قلمروی مربوط به تابع به عنوان قلمروی ماژول استفاده نماییم.</p>

<h2><a class="h_ident" id="h_N33QHgUxbG" href="#h_N33QHgUxbG" tabindex="-1" role="presentation"></a>CommonJS</h2>

<p id="commonjs"><a class="p_ident" id="p_FQuYAj9Pbx" href="#p_FQuYAj9Pbx" tabindex="-1" role="presentation"></a>رایج ترین شیوه‌ای که برای اضافه کردن ماژول‌ها به جاوااسکریپت استفاده می شود، ماژول‌های <em>CommonJS</em> می‌باشد. <bdo>Node.js</bdo> از آن استفاده می کند و سیستمی است که بیشتر بسته‌های NPM از آن استفاده می کنند.</p>

<p><a class="p_ident" id="p_N33QHgUxbG" href="#p_N33QHgUxbG" tabindex="-1" role="presentation"></a>مفهوم اصلی در ماژول‌های CommonJS تابعی به نام <code>‌require</code> است. زمانی که از این تابع به همراه نام ماژول یک وابستگی استفاده می کنید، این تابع اطمینان حاصل می کند که ماژول مورد نظر بارگیری شده است و رابط آن را برمی گرداند.</p>

<p><a class="p_ident" id="p_xX4IryjIXn" href="#p_xX4IryjIXn" tabindex="-1" role="presentation"></a>به دلیل اینکه بارگیرنده‌ (loader)، ماژول مورد نظر را درون یک تابع قرار می دهد، ماژول‌ها به صورت خودکار قلمروی‌ محلی خودشان را می گیرند. تنها کاری که بایستی بکنند این است که تابع <code>require</code> را فراخوانی کنند تا به وابستگی های آن ها دسترسی داشته باشند و رابطشان را در شیئی که به <code>exports</code> تخصیص یافته قرار دهند.</p>

<p><a class="p_ident" id="p_+7R7Wno/9p" href="#p_+7R7Wno/9p" tabindex="-1" role="presentation"></a>این ماژول به عنوان مثال، یک تابع ویرایش تاریخ فراهم می سازد (date-formatting). اینجا از دو بسته از NMP استفاده می شود – بسته‌ی <code>ordinal</code> برای تبدیل اعداد به رشته‌های شبیه <code>&quot;1st&quot;</code> و <code>&quot;2nd&quot;</code> , و بسته‌ی <bdo><code>date-names</code></bdo> برای گرفتن نام‌های انگلیسی روزهای هفته و ماه‌ها. این ماژول یک تابع به نام <code>fomatDate</code> را صادر (export) می کند که یک شیء <code>Date</code> و یک رشته به عنوان قالب دریافت‌ می کند.</p>

<p><a class="p_ident" id="p_zo2zifU/qh" href="#p_zo2zifU/qh" tabindex="-1" role="presentation"></a>رشته‌ی قالب می تواند حاوی کدهایی باشد که فرمت تاریخ را مشخص می کند مثل <code>YYYY</code> برای نمایش سال به صورت کامل و <code>‌Do</code> برای نام‌های ترتیبی روزهای ماه. می توانید به آن رشته‌ای به شکل <bdo><code>&quot;MMMM Do YYYY&quot;</code></bdo> برای دریافت چیزی شبیه <bdo>“November 22nd 2017”</bdo> ارسال کنید.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_hEFnba6fud" href="#c_hEFnba6fud" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">ordinal</span> <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;ordinal&quot;</span>);
<span class="cm-keyword">const</span> {<span class="cm-def">days</span>, <span class="cm-def">months</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;date-names&quot;</span>);

<span class="cm-variable">exports</span>.<span class="cm-property">formatDate</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">date</span>, <span class="cm-def">format</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">format</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/YYYY|M(MMM)?|Do?|dddd/g</span>, <span class="cm-def">tag</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">tag</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;YYYY&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">date</span>.<span class="cm-property">getFullYear</span>();
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">tag</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;M&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">date</span>.<span class="cm-property">getMonth</span>();
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">tag</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;MMMM&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-variable">months</span>[<span class="cm-variable-2">date</span>.<span class="cm-property">getMonth</span>()];
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">tag</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;D&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">date</span>.<span class="cm-property">getDate</span>();
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">tag</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;Do&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-variable">ordinal</span>(<span class="cm-variable-2">date</span>.<span class="cm-property">getDate</span>());
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">tag</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;dddd&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-variable">days</span>[<span class="cm-variable-2">date</span>.<span class="cm-property">getDay</span>()];
  });
};</pre>

<p><a class="p_ident" id="p_B372u36cp6" href="#p_B372u36cp6" tabindex="-1" role="presentation"></a>رابط <code>ordinal</code> یک تابع ساده است در حالیکه <bdo><code>date-names</code></bdo> یک شیء را که حاوی چند چیز متفاوت است صادر می کند- دو مقداری که در نام های آرایه‌ها استفاده کردیم. استفاده از روش تخریب (Destructuring) برای ایجاد متغیر برای رابط‌های وارد شده بسیار مناسب است.</p>

<p>ماژول تابع رابط خودش را به <code>exports</code> اضافه می کند در نتیجه ماژول‌های وابسته، به آن دسترسی خواهند داشت. می توانیم از این ماژول به این صورت استفاده کنیم:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_pWURcHuHTt" href="#c_pWURcHuHTt" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">formatDate</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;./format-date&quot;</span>);

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">formatDate</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2017</span>, <span class="cm-number">9</span>, <span class="cm-number">13</span>),
                       <span class="cm-string">&quot;dddd the Do&quot;</span>));
<span class="cm-comment">// → Friday the 13th</span></pre>

<p id="require">می توان <code>require</code> را در کوتاه ترین شکل خودش  تعریف کرد:</p>

<pre class="snippet cm-s-default" data-language="javascript"  data-sandbox="require"><a class="c_ident" id="c_CSMfqoYOzp" href="#c_CSMfqoYOzp" tabindex="-1" role="presentation"></a><span class="cm-variable">require</span>.<span class="cm-property">cache</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);

<span class="cm-keyword">function</span> <span class="cm-def">require</span>(<span class="cm-def">name</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span>(<span class="cm-variable-2">name</span> <span class="cm-keyword">in</span> <span class="cm-variable">require</span>.<span class="cm-property">cache</span>)) {
    <span class="cm-keyword">let</span> <span class="cm-def">code</span> <span class="cm-operator">=</span> <span class="cm-variable">readFile</span>(<span class="cm-variable-2">name</span>);
    <span class="cm-keyword">let</span> <span class="cm-def">module</span> <span class="cm-operator">=</span> {<span class="cm-property">exports</span>: {}};
    <span class="cm-variable">require</span>.<span class="cm-property">cache</span>[<span class="cm-variable-2">name</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">module</span>;
    <span class="cm-keyword">let</span> <span class="cm-def">wrapper</span> <span class="cm-operator">=</span> <span class="cm-variable">Function</span>(<span class="cm-string">&quot;require, exports, module&quot;</span>, <span class="cm-variable-2">code</span>);
    <span class="cm-variable-2">wrapper</span>(<span class="cm-variable">require</span>, <span class="cm-variable-2">module</span>.<span class="cm-property">exports</span>, <span class="cm-variable-2">module</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable">require</span>.<span class="cm-property">cache</span>[<span class="cm-variable-2">name</span>].<span class="cm-property">exports</span>;
}</pre>

<p><a class="p_ident" id="p_Kzh6PibMf8" href="#p_Kzh6PibMf8" tabindex="-1" role="presentation"></a>در این کد، <code>readFile</code> یک تابع ساختگی است که یک فایل را خوانده و محتوای آن را به صورت رشته برمی‌گرداند. جاوااسکریپت استاندارد، این قابلیت را فراهم نمی کند – اما محیط‌های متفاوت جاوااسکریپت مثل مرورگر و <bdo>Node.js</bdo>، راه‌های خودشان را برای دسترسی به فایل‌ها فراهم می سازند. مثال بالا فقط وانمود می کند که <code>readFile</code> وجود دارد.</p>

<p>برای جلوگیری از بارگیری چندباره‌ی یک ماژول ، <code>require</code> ماژول‌هایی که تاکنون بارگیری شده اند را جایی (در حافظه‌ی نهان) نگه داری می کند. در زمان فراخوانی، ابتدا بارگیری ماژول خواسته شده را در گذشته بررسی می کند و در صورت نبود، آن را بارگیری می کند. این روند شامل خواندن کد ماژول، قرار دادن آن درون یک تابع و فراخوانی آن می شود.</p>

<p>رابط بسته‌ی <code>ordinal</code> که قبل تر دیدیم یک شیء نیست بلکه یک تابع است. یک ایراد وارده به ماژول‌های CommonJS این است که اگرچه سیستم ماژول، یک رابط به صورت شیئی خالی برای شما ایجاد می کند (که در <code>exports</code> قرار می گیرد)، می توانید آن را با هر مقداری که بخواهید به وسیله‌ی بازنویسی خاصیت <bdo><code>module.exports</code></bdo> جایگزین کنید. این کار را خیلی از ماژول ها انجام می دهند تا بتوانند یک مقدار ساده را به جای یک شیء رابط صادر کنند.</p>

<p>با تعریف <code>require</code>، <code>exports</code>، و <code>module</code> به عنوان پارامترهای تابع پوشش دهنده‌ی تولید شده (و ارسال مقدارهای مناسب در هنگام فراخوانی)، بارگیرنده‌ اطمینان حاصل می کند که این متغیرها در قلمروی مربوط به ماژول در دسترس خواهند بود.</p>

<p>روشی که در آن، رشته‌ی داده شده به <code>require</code> به یک نام فایل واقعی یا یک آدرس وب تفسیر می شود، در سیستم های مختلف متفاوت است. زمانی که این رشته با <bdo><code>&quot;./&quot;</code></bdo> یا <bdo><code>&quot;../&quot;</code></bdo> شروع می شود عموما نسبت به نام فایل ماژول فعلی در نظر گرفته می شود. بنابراین <bdo><code>&quot;./<wbr>format-date&quot;</code></bdo> فایلی به نام <bdo><code>format-date.js</code></bdo> که در همان پوشه قرار دارد در نظر گرفته می شود.</p>

<p><a class="p_ident" id="p_XY1RLgBv7D" href="#p_XY1RLgBv7D" tabindex="-1" role="presentation"></a>زمانی که نام نسبی نیست، <bdo>Node.js</bdo> به جستجوی بسته ای با همان نام اقدام می کند. در کد مثال این فصل، ما این گونه نام‌ها را به عنوان بسته‌های NPM تفسیر می کنیم. در <a href="20_node.html">فصل 20</a> به جزئیات نصب و استفاده از ماژول‌های NPM خواهیم پرداخت.</p>

<p id="modules_ini"><a class="p_ident" id="p_uDGpTokBLh" href="#p_uDGpTokBLh" tabindex="-1" role="presentation"></a>اکنون به جای نوشتن تجزیه‌گر فایل INI خودمان، می توانیم از یکی از بسته‌های موجود در NPM استفاده کنیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_LfcCXOMZGr" href="#c_LfcCXOMZGr" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">parse</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;ini&quot;</span>);

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">parse</span>(<span class="cm-string">&quot;x = 10\ny = 20&quot;</span>));
<span class="cm-comment">// → {x: &quot;10&quot;, y: &quot;20&quot;}</span></pre>

<h2><a class="h_ident" id="h_9mUT8reb1B" href="#h_9mUT8reb1B" tabindex="-1" role="presentation"></a>ماژول‌های ECMASCRIPT</h2>

<p><a class="p_ident" id="p_TQD7q+ypOS" href="#p_TQD7q+ypOS" tabindex="-1" role="presentation"></a>ماژول‌های CommonJS به خوبی کار می کنند و ترکیب آن ها با NPM به جامعه‌ی برنامه‌نویسان جاوااسکریپت اجازه داده است که کدها را در مقیاس بزرگ به اشتراک بگذارند.</p>

<p>اما کمی لازم است تا دستی به سر و روی آن‌ها کشید. ظاهر نوشتاری آن اندکی مشکل دارد – به عنوان مثال چیزهایی که به <code>exports</code> اضافه می کند در قلمروی محلی در دسترس نیستند. و به دلیل اینکه <code>require</code> یک فراخوانی به یک تابع معمولی است که هر نوع آرگومانی را قبول می کند، نه فقط مقادیر رشته‌ای، تشخیص وابستگی‌های یک ماژول بدون اجرای کدهای آن می توان سخت شود.</p>

<p id="es"><a class="p_ident" id="p_0cKp9Xub+L" href="#p_0cKp9Xub+L" tabindex="-1" role="presentation"></a>به همین علت است که جاوااسکریپت استاندارد از 2015 سیستم ماژول متفاوت خودش را معرفی کرد که معمولا <em>ES modules</em> نامیده می شود. <em>ES</em> مخفف <em>ECMAScript</em> است. مفاهیم اصلی وابستگی‌ها و رابط‌ها به همان صورت باقی می ماند اما جزئیات آن‌ها متفاوت است. برای یک مورد ، نشان‌گذاری اکنون درون زبان یکپارچه شده است. به جای فراخوانی یک تابع برای دسترسی به یک وابستگی، از کلید‌واژه‌ی مخصوصی به نام <code>import</code> استفاده می کنید.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_EpiH8qOAcJ" href="#c_EpiH8qOAcJ" tabindex="-1" role="presentation"></a><span class="cm-keyword">import</span> <span class="cm-def">ordinal</span> <span class="cm-keyword">from</span> <span class="cm-string">&quot;ordinal&quot;</span>;
<span class="cm-keyword">import</span> {<span class="cm-def">days</span>, <span class="cm-def">months</span>} <span class="cm-keyword">from</span> <span class="cm-string">&quot;date-names&quot;</span>;

<span class="cm-keyword">export</span> <span class="cm-keyword">function</span> <span class="cm-def">formatDate</span>(<span class="cm-def">date</span>, <span class="cm-def">format</span>) { <span class="cm-comment">/* ... */</span> }</pre>

<p>به طور مشابه، کلیدواژه‌ی <code>export</code> برای صدور استفاده می شود. می توان از آن در ابتدای یک تابع، کلاس، یا تعریف متغیر استفاده کرد <bdo>(<code>let</code>, <code>const</code>, یا <code>var</code>)</bdo></p>

<p><a class="p_ident" id="p_neuruqAaGQ" href="#p_neuruqAaGQ" tabindex="-1" role="presentation"></a>یک رابط ماژول ES، یک مقدار واحد نیست بلکه مجموعه‌ای از متغیرهای نامگذاری شده است. ماژولی که در بالا آمده است <code>formatDate</code> را به یک تابع تخصیص می دهد. زمانی که از یک ماژول دیگر اقدام به <em>وارد کردن</em> می کنید شما متغیر را وارد می کنید نه مقدار آن را که معنای آن این است که یک صدور ماژول ممکن است مقدار یک متغیر را در هر زمانی تغییر دهد و ماژول‌هایی که آن را وارد کرده اند، مقدار جدیدش را خواهند دید.</p>

<p>زمانی که متغیری به نام <code>default</code> وجود داشته باشد، آن به عنوان مقدار صادر شده‌ی اصلی ماژول در نظر گرفته می شود. اگر ماژولی مانند <code>ordinal</code> را که در مثال آمد، بدون استفاده از براکت‌ها دور نام متغیر وارد کنید، متغیر￼ <code>default</code> آن ماژول را دریافت می کنید. این گونه ماژول‌ها می توانند در کنار صدور <code>default</code>، متغیرهای دیگری را هم با نام‌های مختلف صادر کنند.</p>

<p><a class="p_ident" id="p_dQXWSlTgYb" href="#p_dQXWSlTgYb" tabindex="-1" role="presentation"></a>برای ایجاد یک صدور پیش فرض (default) می توانید از <bdo><code>export default</code></bdo> قبل از یک عبارت، تعریف تابع یا کلاس استفاده کنید.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Y6Wnu9X+/W" href="#c_Y6Wnu9X+/W" tabindex="-1" role="presentation"></a><span class="cm-keyword">export</span> <span class="cm-keyword">default</span> [<span class="cm-string">&quot;Winter&quot;</span>, <span class="cm-string">&quot;Spring&quot;</span>, <span class="cm-string">&quot;Summer&quot;</span>, <span class="cm-string">&quot;Autumn&quot;</span>];</pre>

<p>می توان نام متغیرهایی که وارد شده اند را با استفاده از <code>as</code> تغییر داد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_I7jPaQvsXj" href="#c_I7jPaQvsXj" tabindex="-1" role="presentation"></a><span class="cm-keyword">import</span> {<span class="cm-def">days</span> <span class="cm-keyword">as</span> <span class="cm-def">dayNames</span>} <span class="cm-keyword">from</span> <span class="cm-string">&quot;date-names&quot;</span>;

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dayNames</span>.<span class="cm-property">length</span>);
<span class="cm-comment">// → 7</span></pre>

<p>یک تفاوت مهم دیگر این است که عمل وارد کردن ماژول ES قبل از این که اجرای اسکریپت ماژول شروع شود اتفاق می‌افتد. یعنی تعریف <code>import</code> درون تابع یا بلوک‌ها ظاهر نمی شود و نام وابستگی‌ها باید به صورت رشته محصور در نقل قول باشد نه عبارت‌های دلخواه.</p>

<p><a class="p_ident" id="p_JO4Dywzaop" href="#p_JO4Dywzaop" tabindex="-1" role="presentation"></a>در زمان نوشتن این کتاب، جامعه‌ی برنامه‌نویسان جاوااسکریپت در مسیر استفاده از این سبک ماژول‌ها هستند. اما این روند به آهستگی اتفاق می افتد. چند سالی طول کشید بعد از مشخص شدن فرمت جدید، که مرورگرها و Node.js شروع به پشتیبانی از آن کردند. و اگرچه آن‌ها تقریبا از آن پشتیبانی کامل می کنند اما این پشتیبانی هنوز با ایراداتی روبرو است و بحث‌هایی پیرامون شیوه‌ی توزیع این گونه ماژول ها در NPM هنوز در جریان است.</p>

<p>خیلی از برنامه‌ها را با ماژول‌های ES می نویسند و به صورت خودکار به دیگر فرمت‌ها در هنگام انتشار تبدیل می کنند. ما در دوره‌ی گذار به سر می بریم که در آن دو سیستم مدیریت ماژول همزمان استفاده می شوند و خوب است که قادر باشیم کدها را در هر دو سیستم بنویسیم و بخوانیم.</p>

<h2><a class="h_ident" id="h_hODOUYQ6ls" href="#h_hODOUYQ6ls" tabindex="-1" role="presentation"></a>ساخت و بسته‌بندی</h2>

<p>در واقع خیلی از پروژه‌های جاوااسکریپت حتی ، از لحاظ فنی، در زبان جاوااسکریپت نوشته نمی شوند. افزونه‌هایی وجود دارد که به طور گسترده استفاده می شوند مانند همان گویشی از جاوااسکریپت که به انواع داده حساس بود و در <a href="08_error.html#typing">فصل 8</a> ذکر شد. برنامه نویسان اغلب شروع به استفاده از افزونه‌هایی می کنند که خیلی پیش‌تر برای اضافه شدن به پلتفرم‌ها برنامه ریزی شده اند.</p>

<p>برای اجرایی کردن این کار، کدهایشان را کامپایل می کنند، کد را از گویش جاوااسکریپت مورد نظرشان به جاوااسکریپت ساده ترجمه می کنند – یا حتی به یک نسخه‌ی قدیمی از جاوااسکریپت ترجمه می کنند که مرورگرهای قدیمی بتوانند آن را اجرا کنند.</p>

<p><a class="p_ident" id="p_GgZhex5Gzo" href="#p_GgZhex5Gzo" tabindex="-1" role="presentation"></a>قرار دادن یک برنامه‌ی ماژولار (پیمانهای) که از 200 فایل متفاوت تشکیل شده است در یک صفحه‌ی وب مشکلات خودش را خواهد داشت. اگر دریافت و استفاده از یک فایل در شبکه 50 هزارم ثانیه زمان بگیرد، کل برنامه ده ثانیه زمان خواهد گرفت یا شاید نیمی از آن زمان اگر بتوانیم چندین فایل را همزمان بارگیری کنید. این زمان زیادی را تلف خواهد کرد. به دلیل اینکه بارگیری یک فایل بزرگ واحد، از تعداد زیادی فایل کوچک، عموما سریع تر اتفاق می افتد. برنامه نویسان وب به سراغ ابزارهایی رفته اند که برنامه‌هایشان را (که با زحمت به ماژول ها تقسیم کرده اند) گرفته و تبدیل به یک فایل بزرگ کند قبل از اینکه بخواهند برنامه را در وب منتشر کنند. این ابزار￼ را بسته‌ساز می نامند <em>bundlers</em>.</p>

<p><a class="p_ident" id="p_WchYnejdba" href="#p_WchYnejdba" tabindex="-1" role="presentation"></a>و می توانیم پارا فراتر بگذاریم. جدا از تعداد فایل‌ها، حجم این فایل‌ها هم در سرعت انتقالشان در شبکه تعیین کننده است. بنابراین، جامعه‌ی جاوااسکریپت کاران، ابزارهای فشرده ساز را اختراع کردند (minifier). این ابزار یک برنامه‌ی جاوااسکریپت را گرفته و با حذف توضیحات، فضاهای خالی، تغییر نام متغیرها و جایگزینی بعضی کدها با معادل‌های کوچک تر، حجم آن را کاهش می دهند.</p>

<p><a class="p_ident" id="p_UAhsGLYB2Z" href="#p_UAhsGLYB2Z" tabindex="-1" role="presentation"></a>پس اصلا دور از انتظار نیست که که کدی که در یک بسته‌ی NPM یافته اید یا در یک صفحه‌ی وب اجرا می شود پیش از آن مراحل مختلفی از تبدیل را طی کرده باشد – تبدیل از جاوااسکریپت مدرن به جاوااسکریپت قدیمی‌تر، از ماژول‌های ES به CommonJS، بسته‌بندی شده و فشرده شده باشد. در این کتاب به جزئیات مربوط به این ابزار نمی پردازیم، چون هم کسل کننده خواهد بود هم به سرعت تغییر می کنند. فقط حواستان باشد که کدی که شما معمولا اجرا می کنید اغلب همانی نیست که نوشته شده است.</p>

<h2><a class="h_ident" id="h_w+msYeXVHp" href="#h_w+msYeXVHp" tabindex="-1" role="presentation"></a>طراحی ماژول</h2>

<p>ساختاردهی به یک برنامه یکی از جنبه‌های حساس و ظریف از برنامه نویسی محسوب می شود. هر قطعه‌ی معناداری از قابلیت‌ها را می توان به اشکال مختلفی مدلسازی کرد.</p>

<p>طراحی یک برنامه‌ی خوب، سلیقه‌ای  است – مصالحه‌هایی پیش می‌آید که سلیقه در آن دخیل است. بهترین راه برای یادگیری ارزش یک طراحی دارای ساختار خوب، این است که برنامه‌های زیادی را مورد مطالعه قرار دهید یا با آن ها کار کنید تا متوجه شوید که چه چیزی مفید و چه چیز نادرست است. تصور نکنید که درهم‌ریختگی و آشفتگی به هر حال پیش خواهد آمد. تقریبا هر چیزی را با صرف کمی تفکر بیشتر می توان با سازماندهی بهتر کرد.</p>

<p>یکی از جنبه‌های طراحی ماژول که باید رعایت شود، آسانی استفاده است. اگر چیزی را می سازید که قرار است توسط کاربران متعددی استفاده شود (یا حتی توسط خودتان، طی مدت سه ماه، زمانی که دیگر جزئیات کاری که انجام داده اید را به خاطر نمی آورید) اگر رابط برنامه‌ی شما ساده و قابل تشخیص باشد کمک زیادی می کند.</p>

<p><a class="p_ident" id="p_5+sfP6l0gN" href="#p_5+sfP6l0gN" tabindex="-1" role="presentation"></a>ممکن است معنای آن این باشد که از قرارداد‌های موجود پیروی کنید. یک مثال خوب می تواند بسته‌ی <code>ini</code> باشد. این ماژول کار بسته‌ی استاندارد <code>JSON</code> را با فراهم نمودن <code>parse</code> و <code>stringify</code> (برای نوشتن یک فایل INI) تقلید می کند و شبیه <code>JSON</code> عمل تبدیل بین رشته‌ها و اشیاء ساده را انجام می دهد. بنابراین رابط در اینجا کوچک و آشنا است و بعد از اینکه برای اولین بار از آن استفاده کنید احتمالا روش استفاده از آن را به خاطر خواهید داشت.</p>

<p><a class="p_ident" id="p_I5scgYLK4v" href="#p_I5scgYLK4v" tabindex="-1" role="presentation"></a>حتی اگر هیچ تابع استاندارد یا بسته‌ای که به طور گسترده استفاده می شود برای تقلید وجود نداشت، می توانید با￼ استفاده از ساختارهای داده‌ی ساده و تمرکز بر انجام یک کار، ماژول های خودتان را قابل پیشبینی کنید. به عنوان مثال، خیلی از بسته‌های تجزیه‌ی فایل INI در NPM تابعی دارند که مستقیما یک فایل ini را از دیسک سخت خوانده و تجزیه می کند. این کار باعث می شود که نتوان از این ماژول‌ها در مرورگر استفاده کرد، به دلیل اینکه در مرورگر به طور مستقیم به سیستم فایل دسترسی نداریم و پیچیدگی ای اضافه می کند که بهتر بود با ترکیب ماژول با یک تابع خواندن فایل دیگر، حل می شد.</p>

<p>این موضوع به یکی دیگر از جنبه‌های مفیدی که در طراحی ماژول وجود دارد اشاره می کند – آسانی ترکیب با کدهای دیگر. ماژول‌هایی که تمرکز روی کار خاصی دارند و مقدارها را محاسبه می کنند در طیف گسترده‌تری از برنامه ها کاربرد دارند نسبت به ماژول‌های بزرگتری که کارهای پیچیده‌ای انجام می دهند و دارای اثرات جانبی هستند. خواننده‌ی فایل INIای که اصرار به خواندن فایل از دیسک سخت را دارد در مواردی که محتوای فایل از دیگر منابع می آید بدون کاربرد خواهد بود.</p>

<p><a class="p_ident" id="p_btxtSvBXyC" href="#p_btxtSvBXyC" tabindex="-1" role="presentation"></a>همچنین، اشیاء دارای وضعیت (stateful) گاهی اوقات مفید هستند یا حتی لازم اند اما اگر چیزی را بتوان با یک تابع انجام داد، از تابع استفاده کنید. تعدادی از بسته‌های خواننده‌ی فایل INI در NPM، سبکی را برای رابط خود استفاده کرده اند که ابتدا از شما می خواهند که یک شیء ایجاد کنید، بعد فایل مورد نظر را درون شیء بارگیری کنید و درنهایت از متدهای خاصی برای گرفتن نتایج استفاده کنید. این کار در سنت شیء گرایی رایج است و باید گفت بسیار بد است. به جای ساختن یک فراخوانی تابع و ادامه حرکت، باید تشریفات حرکت شیء تان بین وضعیت‌های مختلف را انجام دهید. و به دلیل اینکه داده‌ها اکنون در یک نوع خاصی از شیء قرار گرفته اند، تمام کدی که با آن در ارتباط است باید آن نوع را بداند که باعث ایجاد وابستگی‌های درونی بی‌فایده می شود.</p>

<p><a class="p_ident" id="p_N3Re16DwBf" href="#p_N3Re16DwBf" tabindex="-1" role="presentation"></a>اغلب نمی‌توان توان از تعریف ساختارهای داده‌ی جدید صرف نظر کرد – فقط تعداد کمی از موارد اساسی و پایه‌ای توسط زبان استاندارد فراهم شده است و خیلی از انواع داده می بایست پیچیده تر از یک آرایه یا یک نگاشت (map) باشد. اما زمانی که یک آرایه کافی است، از همان استفاده کنید.</p>

<p>یک نمونه از ساختار داده‌های کمی پیچیده تر، گراف است که در <a href="07_robot.html">فصل 7</a> ذکر شد. یک راه یکسان و مشخص برای نمایش یک گراف در جاوااسکریپت وجود ندارد. در آن فصل، ما از یک شیء که خاصیت‌هایش آرایه‌هایی از رشته‌ها را نگه داری می کردند استفاده کردیم – گره‌هایی که از یک گره قابل دستیابی بودند.</p>

<p>بسته‌های متعددی در باره‌ی مسیریابی در NPM وجود دارند اما هیچ کدامشان از این فرمت گراف استفاده نمی کنند. معمولا این بسته ها به لبه‌های گراف امکان داشتن وزن را می دهند، که همان فاصله یا هزینه‌ای است که به آن‌ها اختصاص داده شده است. در نمایش ما این‌کار ممکن نیست.</p>

<p>به عنوان مثال، بسته‌ای به نام <code>dijkstrajs</code> وجود دارد. یک راه حل شناخته شده برای مسیریابی، که نسبتا شبیه به تابع <code>findRoute</code> ما است، <em>الگوریتم دیکسترا</em> است که ادسخر دیکسترا آن را نوشت. پسوند <code>js</code> معمولا به انتهای￼ بسته‌ها اضافه می شود تا نشان دهد که آن ها به زبان جاوااسکریپت نوشته شده اند. بسته‌ی <code>dijkstrajs</code> از یک فرمت گراف شبیه به فرمت ما استفاده می کند اما به جای آرایه‌ها از اشیاء استفاده می کند که مقدارهای خاصیت‌هایش از جنس اعداد هستند – وزن وزن‌ لبه‌ها.</p>

<p>بنابراین اگر بخواهیم از آن بسته استفاده کنیم، بایستی اطمینان حاصل کنیم که گراف ما در فرمتی که بسته پشتیبانی می کند ذخیره شده باشد. همه‌ی لبه‌ها وزن یکسانی می گیرند زیرا مدل ساده‌شده‌ی ما برای هر مسیر هزینه‌ی یکسانی در نظر می گیرد (یک دور).</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_NyRXVpwPYN" href="#c_NyRXVpwPYN" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">find_path</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;dijkstrajs&quot;</span>);

<span class="cm-keyword">let</span> <span class="cm-def">graph</span> <span class="cm-operator">=</span> {};
<span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">node</span> <span class="cm-keyword">of</span> <span class="cm-variable">Object</span>.<span class="cm-property">keys</span>(<span class="cm-variable">roadGraph</span>)) {
  <span class="cm-keyword">let</span> <span class="cm-def">edges</span> <span class="cm-operator">=</span> <span class="cm-variable">graph</span>[<span class="cm-variable">node</span>] <span class="cm-operator">=</span> {};
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">dest</span> <span class="cm-keyword">of</span> <span class="cm-variable">roadGraph</span>[<span class="cm-variable">node</span>]) {
    <span class="cm-variable-2">edges</span>[<span class="cm-variable-2">dest</span>] <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  }
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">find_path</span>(<span class="cm-variable">graph</span>, <span class="cm-string">&quot;Post Office&quot;</span>, <span class="cm-string">&quot;Cabin&quot;</span>));
<span class="cm-comment">// → [&quot;Post Office&quot;, &quot;Alice's House&quot;, &quot;Cabin&quot;]</span></pre>

<p>این خود مانعی برای ترکیب پذیری محسوب می شود – زمانی که بسته‌های متنوع از ساختارهای متفاوتی برای توصیف چیزهای یکسان استفاده می کنند، ترکیب آن ها سخت خواهد شد. بنابراین، اگر قصد دارید ترکیب پذیری را هم در طراحی لحاظ کنید، توجه کنید که چه ساختارهای داده‌ای دیگر برنامه نویسان استفاده می کنند و هر وقت ممکن شد از روش آن ها استفاده کنید.</p>

<h2><a class="h_ident" id="h_ErccPg/l98" href="#h_ErccPg/l98" tabindex="-1" role="presentation"></a>Summary</h2>

<p><a class="p_ident" id="p_OX2jY0nGFw" href="#p_OX2jY0nGFw" tabindex="-1" role="presentation"></a>Modules provide structure to bigger programs by separating the code into pieces with clear interfaces and dependencies. The interface is the part of the module that’s visible from other modules, and the dependencies are the other modules that it makes use of.</p>

<p><a class="p_ident" id="p_sYCJxIhCEI" href="#p_sYCJxIhCEI" tabindex="-1" role="presentation"></a>Because JavaScript historically did not provide a module system, the CommonJS system was built on top of it. Then at some point it <em>did</em> get a built-in system, which now coexists uneasily with the CommonJS system.</p>

<p><a class="p_ident" id="p_wDM2Q8HBcB" href="#p_wDM2Q8HBcB" tabindex="-1" role="presentation"></a>A package is a chunk of code that can be distributed on its own. NPM is a repository of JavaScript packages. You can download all kinds of useful (and useless) packages from it.</p>

<h2><a class="h_ident" id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe" tabindex="-1" role="presentation"></a>Exercises</h2>

<h3><a class="i_ident" id="i_CJKk6NIC0T" href="#i_CJKk6NIC0T" tabindex="-1" role="presentation"></a>A modular robot</h3>

<p id="modular_robot"><a class="p_ident" id="p_nPAEnO4pep" href="#p_nPAEnO4pep" tabindex="-1" role="presentation"></a>These are the bindings that the project from <a href="07_robot.html">Chapter 7</a> creates:</p>

<pre class="snippet cm-s-default" data-language="text/plain" ><a class="c_ident" id="c_/nxTd1W0Sy" href="#c_/nxTd1W0Sy" tabindex="-1" role="presentation"></a>roads
buildGraph
roadGraph
VillageState
runRobot
randomPick
randomRobot
mailRoute
routeRobot
findRoute
goalOrientedRobot</pre>

<p><a class="p_ident" id="p_0LdymcLoV8" href="#p_0LdymcLoV8" tabindex="-1" role="presentation"></a>If you were to write that project as a modular program, what modules would you create? Which module would depend on which other module, and what would their interfaces look like?</p>

<p><a class="p_ident" id="p_hU/u/IPER+" href="#p_hU/u/IPER+" tabindex="-1" role="presentation"></a>Which pieces are likely to be available prewritten on NPM? Would you prefer to use an NPM package or write them yourself?</p>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_o3MT4wM7DB" href="#p_o3MT4wM7DB" tabindex="-1" role="presentation"></a>Here’s what I would have done (but again, there is no single <em>right</em> way to design a given module):</p>

<p><a class="p_ident" id="p_56/CQgKTat" href="#p_56/CQgKTat" tabindex="-1" role="presentation"></a>The code used to build the road graph lives in the <code>graph</code> module. Because I’d rather use <code>dijkstrajs</code> from NPM than our own pathfinding code, we’ll make this build the kind of graph data that <code>dijkstajs</code> expects. This module exports a single function, <code>buildGraph</code>. I’d have <code>buildGraph</code> accept an array of two-element arrays, rather than strings containing hyphens, to make the module less dependent on the input format.</p>

<p><a class="p_ident" id="p_B6Z6VXRXv9" href="#p_B6Z6VXRXv9" tabindex="-1" role="presentation"></a>The <code>roads</code> module contains the raw road data (the <code>roads</code> array) and the <code>roadGraph</code> binding. This module depends on <code>./graph</code> and exports the road graph.</p>

<p><a class="p_ident" id="p_JLwefzFde0" href="#p_JLwefzFde0" tabindex="-1" role="presentation"></a>The <code>VillageState</code> class lives in the <code>state</code> module. It depends on the <code>./roads</code> module because it needs to be able to verify that a given road exists. It also needs <code>randomPick</code>. Since that is a three-line function, we could just put it into the <code>state</code> module as an internal helper function. But <code>randomRobot</code> needs it too. So we’d have to either duplicate it or put it into its own module. Since this function happens to exist on NPM in the <code>random-item</code> package, a good solution is to just make both modules depend on that. We can add the <code>runRobot</code> function to this module as well, since it’s small and closely related to state management. The module exports both the <code>VillageState</code> class and the <code>runRobot</code> function.</p>

<p><a class="p_ident" id="p_wJDmndPhIc" href="#p_wJDmndPhIc" tabindex="-1" role="presentation"></a>Finally, the robots, along with the values they depend on such as <code>mailRoute</code>, could go into an <code>example-robots</code> module, which depends on <code>./roads</code> and exports the robot functions. To make it possible for <code>goalOrientedRobot</code> to do route-finding, this module also depends on <code>dijkstrajs</code>.</p>

<p><a class="p_ident" id="p_jU189+mtkS" href="#p_jU189+mtkS" tabindex="-1" role="presentation"></a>By offloading some work to NPM modules, the code became a little smaller. Each individual module does something rather simple and can be read on its own. Dividing code into modules also often suggests further improvements to the program’s design. In this case, it seems a little odd that the <code>VillageState</code> and the robots depend on a specific road graph. It might be a better idea to make the graph an argument to the state’s constructor and make the robots read it from the state object—this reduces dependencies (which is always good) and makes it possible to run simulations on different maps (which is even better).</p>

<p><a class="p_ident" id="p_rfGj5/gdUx" href="#p_rfGj5/gdUx" tabindex="-1" role="presentation"></a>Is it a good idea to use NPM modules for things that we could have written ourselves? In principle, yes—for nontrivial things like the pathfinding function you are likely to make mistakes and waste time writing them yourself. For tiny functions like <code>random-item</code>, writing them yourself is easy enough. But adding them wherever you need them does tend to clutter your modules.</p>

<p><a class="p_ident" id="p_shhnxYPdPj" href="#p_shhnxYPdPj" tabindex="-1" role="presentation"></a>However, you should also not underestimate the work involved in <em>finding</em> an appropriate NPM package. And even if you find one, it might not work well or may be missing some feature you need. On top of that, depending on NPM packages means you have to make sure they are installed, you have to distribute them with your program, and you might have to periodically upgrade them.</p>

<p><a class="p_ident" id="p_UgTNT3/2gd" href="#p_UgTNT3/2gd" tabindex="-1" role="presentation"></a>So again, this is a trade-off, and you can decide either way depending on how much the packages help you.</p>

</div></div>

<h3><a class="i_ident" id="i_+pU//gQmZ8" href="#i_+pU//gQmZ8" tabindex="-1" role="presentation"></a>Roads module</h3>

<p><a class="p_ident" id="p_U88wPDSl2i" href="#p_U88wPDSl2i" tabindex="-1" role="presentation"></a>Write a CommonJS module, based on the example from <a href="07_robot.html">Chapter 7</a>, that contains the array of roads and exports the graph data structure representing them as <code>roadGraph</code>. It should depend on a module <code>./graph</code>, which exports a function <code>buildGraph</code> that is used to build the graph. This function expects an array of two-element arrays (the start and end points of the roads).</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_FPEwj7xDOs" href="#c_FPEwj7xDOs" tabindex="-1" role="presentation"></a><span class="cm-comment">// Add dependencies and exports</span>

<span class="cm-keyword">const</span> <span class="cm-def">roads</span> <span class="cm-operator">=</span> [
  <span class="cm-string">&quot;Alice's House-Bob's House&quot;</span>,   <span class="cm-string">&quot;Alice's House-Cabin&quot;</span>,
  <span class="cm-string">&quot;Alice's House-Post Office&quot;</span>,   <span class="cm-string">&quot;Bob's House-Town Hall&quot;</span>,
  <span class="cm-string">&quot;Daria's House-Ernie's House&quot;</span>, <span class="cm-string">&quot;Daria's House-Town Hall&quot;</span>,
  <span class="cm-string">&quot;Ernie's House-Grete's House&quot;</span>, <span class="cm-string">&quot;Grete's House-Farm&quot;</span>,
  <span class="cm-string">&quot;Grete's House-Shop&quot;</span>,          <span class="cm-string">&quot;Marketplace-Farm&quot;</span>,
  <span class="cm-string">&quot;Marketplace-Post Office&quot;</span>,     <span class="cm-string">&quot;Marketplace-Shop&quot;</span>,
  <span class="cm-string">&quot;Marketplace-Town Hall&quot;</span>,       <span class="cm-string">&quot;Shop-Town Hall&quot;</span>
];</pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_KWk09Gyhem" href="#p_KWk09Gyhem" tabindex="-1" role="presentation"></a>Since this is a CommonJS module, you have to use <code>require</code> to import the graph module. That was described as exporting a <code>buildGraph</code> function, which you can pick out of its interface object with a destructuring <code>const</code> declaration.</p>

<p><a class="p_ident" id="p_zdT6jLwIjp" href="#p_zdT6jLwIjp" tabindex="-1" role="presentation"></a>To export <code>roadGraph</code>, you add a property to the <code>exports</code> object. Because <code>buildGraph</code> takes a data structure that doesn’t precisely match <code>roads</code>, the splitting of the road strings must happen in your module.</p>

</div></div>

<h3><a class="i_ident" id="i_E/zWqBFdy8" href="#i_E/zWqBFdy8" tabindex="-1" role="presentation"></a>Circular dependencies</h3>

<p><a class="p_ident" id="p_fl2MZMonQV" href="#p_fl2MZMonQV" tabindex="-1" role="presentation"></a>A circular dependency is a situation where module A depends on B, and B also, directly or indirectly, depends on A. Many module systems simply forbid this because whichever order you choose for loading such modules, you cannot make sure that each module’s dependencies have been loaded before it runs.</p>

<p><a class="p_ident" id="p_b5sTJIUt38" href="#p_b5sTJIUt38" tabindex="-1" role="presentation"></a>CommonJS modules allow a limited form of cyclic dependencies. As long as the modules do not replace their default <code>exports</code> object and don’t access each other’s interface until after they finish loading, cyclic dependencies are okay.</p>

<p><a class="p_ident" id="p_s/oDnu78Ko" href="#p_s/oDnu78Ko" tabindex="-1" role="presentation"></a>The <code>require</code> function given <a href="10_modules.html#require">earlier in this chapter</a> supports this type of dependency cycle. Can you see how it handles cycles? What would go wrong when a module in a cycle <em>does</em> replace its default <code>exports</code> object?</p>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_nf2U1lY9dq" href="#p_nf2U1lY9dq" tabindex="-1" role="presentation"></a>The trick is that <code>require</code> adds modules to its cache <em>before</em> it starts loading the module. That way, if any <code>require</code> call made while it is running tries to load it, it is already known, and the current interface will be returned, rather than starting to load the module once more (which would eventually overflow the stack).</p>

<p><a class="p_ident" id="p_QAZLbqVKnV" href="#p_QAZLbqVKnV" tabindex="-1" role="presentation"></a>If a module overwrites its <code>module.exports</code> value, any other module that has received its interface value before it finished loading will have gotten hold of the default interface object (which is likely empty), rather than the intended interface value.</p>

</div></div><nav><a href="09_regexp.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="11_async.html" title="next chapter">▶</a></nav>
</article>
