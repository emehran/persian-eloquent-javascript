<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>باگ‌ها و خطاها :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 8;var sandboxLoadFiles = ["code/chapter/08_error.js"];</script><script>var clicky_site_ids = clicky_site_ids || []; clicky_site_ids.push(101171577);</script>
  <script async src="//static.getclicky.com/js"></script>

</head>

<article>
<nav><a href="07_robot.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="09_regexp.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>فصل 8</span>باگ‌ها و خطاها</h1>

<blockquote>

<p><a class="p_ident" id="p_2jmj7l5rSw" href="#p_2jmj7l5rSw" tabindex="-1" role="presentation"></a>رفع‌ باگ دوبرابر سخت‌تر از خود کدنویسی ابتدایی است. پس اگر کدی که نوشته‌اید خیلی هوشمندانه‌است، با توجه به تعریف، از پس رفع باگ آن برنخواهید آمد.</p>

<footer>Brian Kernighan and P.J. Plauger, <cite>The Elements of Programming Style</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_8.jpg" alt="Picture of a collection of bugs"></figure>

<p>معمولا در برنامه‌های کامپیوتری، به خطاها <em>باگ به معنای حشره</em> می گویند. این نام‌گذاری حس خوبی به برنامه‌‌نویسان می دهد چون ایراد‌های برنامه را مانند حشرات کوچکی تصور می‌کنند که درون برنامه خزیده اند. البته که در حقیقت خود ما این باگ‌ها را ایجاد کرده ایم.</p>

<p>در یک برنامه که به تدریج ساخته شده است، تقریبا توانید باگ‌ها را به آن هایی که از اشتباه در منطق برنامه رخ داده اند و آن هایی که از اشتباه در هنگام تبدیل منطق برنامه به کد به وجود آمده اند، تقسیم بندی کنید. تشخیص و برطرف کردن  باگ‌های دسته‌ی اول معمولا با سختی بیشتری نسبت به دسته دوم همراه است.</p>

<h2><a class="h_ident" id="h_2hhsuhF8bd" href="#h_2hhsuhF8bd" tabindex="-1" role="presentation"></a>زبان</h2>

<p>در هنگام برنامه‌نویسی، در صورتی که کامپیوتر به اندازه‌ی کافی از کاری که سعی در انجامش داریم بداند، می تواند خیلی از اشتباهات را به صورت خودکار شناسایی و به ما نشان دهد. اما سیستم تسامح محور جاوااسکریپت، خود یک مانع محسوب می شود. مفاهیم متغیرها و خاصیت‌ها در جاوااسکریپت به اندازه‌ی کافی ابهام دارند که جاوااسکریپت، به ندرت پیش از اجرای برنامه، می تواند به اشتباهات تایپی پی ببرد. و حتی بعد از آن نیز، به شما اجازه می دهد که بعضی کارهای کاملا بدون معنی مانند محاسبه <bdo><code>true * &quot;monkey&quot;</code></bdo> را بدون تولید خطا انجام دهید.</p>

<p>مواردی وجود دارد که در صورت بروز، جاوااسکریپت نسبت به آن ها واکنش نشان می‌دهد. مثلا، نوشتن برنامه‌ای که از قواعد دستوری زبان پیروی نکند باعث بروز خطا می شود. دیگر موارد، مانند فراخوانی چیزی که از نوع تابع نیست یا اشاره به یک خاصیت روی یک مقدار تعریف نشده، باعث بروز خطایی می شود که در هنگام انجام آن دستور، گزارش می شود.</p>

<p><a class="p_ident" id="p_1dTNB2FqVC" href="#p_1dTNB2FqVC" tabindex="-1" role="presentation"></a>اما اغلب، انجام محاسبات بی‌معنا باعث تولید <code>NaN</code> (مقدار غیر عددی) می شود یا مقدار undefined را تولید می کند و برنامه با شادمانی ادامه می یابد و فرض می کند که آن محاسبه عمل معناداری بوده است. این اشتباه در آینده خودش را بروز می دهد زمانی که آن مقدار ناخواسته (جعلی) در طول برنامه بین توابع متعدد حرکت می کند. ممکن است اصلا خطایی تولید نکند اما به صورت چراغ‌خاموش باعث تولید خروجی غلط در برنامه می‌شود. پیدا کردن منبع این گونه خطاها می‌تواند واقعا سخت باشد.</p>

<p>روند پیدا کردن خطاها – باگ‌ها – را در برنامه‌ها، دیباگ کردن <em>اشکال زدایی</em> می نامند.</p>

<h2><a class="h_ident" id="h_SfWG2EdQ3b" href="#h_SfWG2EdQ3b" tabindex="-1" role="presentation"></a>حالت سخت‌گیرانه (Strict Mode)</h2>

<p><a class="p_ident" id="p_Qeqrh3yjoO" href="#p_Qeqrh3yjoO" tabindex="-1" role="presentation"></a>به وسیله‌ی فعال کردن حالت strict یا سخت‌گیرانه، می توان جاوااسکریپت را <em>کمی</em> بیشتر سخت‌گیر کرد. این کار را می توان با قرار دادن رشته‌ی <code>&quot;use strict&quot;</code> در بالای یک فایل یا بدنه‌ی یک تابع انجام داد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_tKCBneE0vw" href="#c_tKCBneE0vw" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">canYouSpotTheProblem</span>() {
  <span class="cm-string">&quot;use strict&quot;</span>;
  <span class="cm-keyword">for</span> (<span class="cm-variable">counter</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable">counter</span> <span class="cm-operator">&lt;</span> <span class="cm-number">10</span>; <span class="cm-variable">counter</span><span class="cm-operator">++</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Happy happy&quot;</span>);
  }
}

<span class="cm-variable">canYouSpotTheProblem</span>();
<span class="cm-comment">// → ReferenceError: counter is not defined</span></pre>

<p><a class="p_ident" id="p_vfjOZTPo5o" href="#p_vfjOZTPo5o" tabindex="-1" role="presentation"></a>در حالت عادی، اگر فراموش کنید که <code>let</code> را ابتدای متغیر خود بگذارید، مثل متغیر <code>counter</code> در مثال، جاوااسکریپت بی سروصدا متغیری با همین نام در فضای عمومی (global) ایجاد کرده و از آن استفاده می کند. در حالت strict، به جای این کار یک خطا به شما نشان داده می شود. این کار خیلی مفید است. البته باید توجه داشت که اگر متغیر قبلا در فضای عمومی تعریف شده باشد دیگر خطایی تولید نمی شود، و مقدار آن توسط متغیر همنام در حلقه دوباره مقدار دهی می شود.</p>

<p><a class="p_ident" id="p_ty6B/SFr3I" href="#p_ty6B/SFr3I" tabindex="-1" role="presentation"></a>یک تفاوت دیگر در حالت strict این است که در توابعی که به صورت متد فراخوانی نمی‌شوند،  متغیر <code>this</code> مقدار <code>undefined</code> را خواهد داشت. بیرون از این حالت (strict)، متغیر <code>this</code> به شی‌ء فضای سراسری (global) اشاره می کند، شیئی که خاصیت‌هایش همان متغیرهای سراسری می‌باشند. بنابراین، اگر به صورت تصادفی متدی یا سازنده‌ای را به شکل نادرست در حالت strict فراخوانی کنید، جاوااسکریپت به محض اینکه به قسمت خواندن مقدار <code>this</code> برسد به جای رجوع به فضای سراسری ، خطا تولید می کند.</p>

<p>به عنوان مثال، کد پیش رو را در نظر بگیرید، کدی که یک تابع سازنده را بدون استفاده از کلیدواژه‌ی <code>new</code> فراخوانی می کند که در نتیجه <code>this</code> مربوط به آن، به شیء تازه ساخته شده، اشاره <em>نخواهد</em> کرد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_FPKrb2F1C3" href="#c_FPKrb2F1C3" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">Person</span>(<span class="cm-def">name</span>) { <span class="cm-keyword">this</span>.<span class="cm-property">name</span> <span class="cm-operator">=</span> <span class="cm-variable-2">name</span>; }
<span class="cm-keyword">let</span> <span class="cm-def">ferdinand</span> <span class="cm-operator">=</span> <span class="cm-variable">Person</span>(<span class="cm-string">&quot;Ferdinand&quot;</span>); <span class="cm-comment">// oops</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">name</span>);
<span class="cm-comment">// → Ferdinand</span></pre>

<p><a class="p_ident" id="p_sAagZLxjZ4" href="#p_sAagZLxjZ4" tabindex="-1" role="presentation"></a>بنابراین این فراخوانی جعلی <code>Person</code> اجرا خواهد شد اما مقدار undefined را تولید کرده و متغیر <code>name</code> را در فضای سراسری ایجاد می کند. در حالت strict نتیجه متفاوت خواهد بود.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_HFy5dGOOh4" href="#c_HFy5dGOOh4" tabindex="-1" role="presentation"></a><span class="cm-string">&quot;use strict&quot;</span>;
<span class="cm-keyword">function</span> <span class="cm-def">Person</span>(<span class="cm-def">name</span>) { <span class="cm-keyword">this</span>.<span class="cm-property">name</span> <span class="cm-operator">=</span> <span class="cm-variable-2">name</span>; }
<span class="cm-keyword">let</span> <span class="cm-def">ferdinand</span> <span class="cm-operator">=</span> <span class="cm-variable">Person</span>(<span class="cm-string">&quot;Ferdinand&quot;</span>); <span class="cm-comment">// forgot new</span>
<span class="cm-comment">// → TypeError: Cannot set property 'name' of undefined</span></pre>

<p>بلافاصله به ما اعلام می شود که خطایی وجود دارد که این اعلام بسیار سودمند است.</p>

<p>خوشبختانه، سازنده‌هایی که با دستور  <code>class</code> ایجاد می شوند اگر بدون <code>new</code> فراخوانی شوند، خطا تولید می کنند که این باعث می شود کمی از مشکل حتی در حالت غیر strict کاسته شود.</p>

<p>در حالت strict چند اتفاق دیگر نیز می افتد. در این حالت نمی توان تابعی تعریف کرد که پارامتر‌های مختلف آن نام یکسانی داشته باشند. همچنین بعضی از قسمت‌های مشکل‌ساز زبان را نیز به طور کلی حذف می کند. (مثل دستور <code>with،</code> که به علت بدرد نخور بودن در این کتاب بحث نمی شود.).</p>

<p>کوتاه اینکه، قرار دادن <code>&quot;use strict&quot;</code>  در بالای برنامه به ندرت مشکل ایجاد می کند و ممکن است به شما در پیدا کردن و رفع یک مشکل کمک کند.</p>

<h2><a class="h_ident" id="h_Ugp0DS1qYd" href="#h_Ugp0DS1qYd" tabindex="-1" role="presentation"></a>انواع</h2>

<p>بعضی زبان‌های برنامه‌نویسی علاقمند هستند نوع متغیر‌ها و عبارت‌ها را قبل از اجرای برنامه در اختیار داشته باشند. با این کار، به محض استفاده‌ی نادرست از یک نوع داده، شما را از آن آگاه می کنند. جاوااسکریپت انواع داده را فقط زمانی در نظر می گیرد که برنامه را اجرا می کند، حتی در همان زمان هم سعی می کند که به صورت ضمنی مقدارها را به نوعی که انتظارش را دارد تبدیل کند، که این کار زیاد سودمند نیست.</p>

<p>با این حال، انواع داده چارچوب مفیدی برای بحث در مورد برنامه ها فراهم می کنند. خیلی از اشتباهات از آنجا ناشی می شود که در مورد نوع داده‌ای که به یک تابع ارسال می شود یا از آن دریافت می شود ابهام وجود دارد. اگر این گونه اطلاعات را مکتوب داشته باشید، کمتر دچار سردرگمی خواهید شد.</p>

<p>می توانید توضیحی شبیه زیر به بالای تابع <code>goalOrientedRobot</code> مربوط به فصل پیش، اضافه کنید و نوع آن را توصیف کنید:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_30eJTz3eQP" href="#c_30eJTz3eQP" tabindex="-1" role="presentation"></a><span class="cm-comment">// (VillageState, Array) → {direction: string, memory: Array}</span>
<span class="cm-keyword">function</span> <span class="cm-def">goalOrientedRobot</span>(<span class="cm-def">state</span>, <span class="cm-def">memory</span>) {
  <span class="cm-comment">// ...</span>
}</pre>

<p>سبک‌های گوناگونی برای یادداشت کردن انواع داده در برنامه‌های جاوااسکریپت وجود دارد.</p>

<p><a class="p_ident" id="p_NbPqZp+MCg" href="#p_NbPqZp+MCg" tabindex="-1" role="presentation"></a>یک نکته که در مورد انواع داده وجود دارد این است که لازم است پیچیدگی خودشان را داشته باشند زیرا تنها در صورتی مفید‌ هستند که بتوانند کدهای کافی را توصیف کنند. به نظر شما نوع داده‌ی تابع <code>randomPick</code>  که یک عنصر تصادفی را از آرایه برمی گرداند چیست؟ لازم است تا یک متغیر نوع معرفی کنید، <em>T</em>، که بتواند برای هر نوعی استفاده شود؛ در نتیجه بتوانید به تابع <code>randomPick</code> یک نوع شبیه <bdo><code>([T]) → T</code></bdo> اختصاص دهید ( تابعی از آرایه‌ای از <em>T</em>ها به یک <em>T</em>).</p>

<p id="typing"><a class="p_ident" id="p_1KhsuUbUr0" href="#p_1KhsuUbUr0" tabindex="-1" role="presentation"></a>زمانی که انواع داده‌ی یک برنامه شناخته شدند، اکنون می توان از کامپیوتر برای <em>بررسی</em> آن‌ها استفاده نمود تا بتوانیم اشتباهات را قبل از اجرا تشخصی دهیم. گویش‌های متعددی از جاوااسکریپت وجود دارد که انواع داده را به زبان اضافه کرده و بررسی می کنند. محبوب ترین آن ها <a href="https://www.typescriptlang.org/">TypeScript</a> است. اگر علاقه دارید تا صلابت و استحکام بیشتری به برنامه هایتان اضافه کنید، پیشنهاد می کنم که با آن آشنا شوید.</p>

<p>در این کتاب ما از همان کدهای خام مشکل‌زای و بدون نوع جاوااسکریپت استفاده خواهیم کرد.</p>

<h2><a class="h_ident" id="h_d/M4m8Qmoq" href="#h_d/M4m8Qmoq" tabindex="-1" role="presentation"></a>آزمودن (Testing)</h2>

<p>اگر زبان برنامه نویسی قرار نیست کمک خاصی به ما در پیدا کردن اشتباهات بکند، بایستی آن ها را از راهی سخت تر پیدا کنیم: با اجرای برنامه و مشاهده‌ی اینکه آیا درست کار می کند یا خیر.</p>

<p>انجام این کار به صورت دستی و به تعداد زیاد واقعا ایده بدی است. نه تنها آزاردهنده است، بلکه در حقیقت غیر موثر خواهد بود؛ به این دلیل که با هر تغییر کوچک، زمان زیادی برای آزمودن همه چیز از ابتدا صرف می شود.</p>

<p>کامپیوترها کارهای تکراری را خیلی خوب انجام می دهند، و آزمودن یک کار تکراری ایده‌آل محسوب می شود. آزمودن خودکار روندی است که در آن برنامه‌ای نوشته می شود تا یک برنامه‌ی دیگر را بیازماید. نوشتن یک آزمون کار بیشتری از آزمودن دستی یک برنامه نیاز دارد، اما به محض اینکه آن را نوشتید به نوعی یک قدرت ماورایی بدست خواهید آورد: فقط چند ثانیه لازم است تا مطمئن شوید برنامه‌تان در همه‌ی شرایطی که برایش آزمون نوشته اید درست کار می کند یا خیر. زمانی که قسمتی از برنامه با مشکل روبرو می شود، بلافاصله متوجه آن خواهید شد، تا اینکه در آینده به صورت تصادفی با آن روبرو شوید.</p>

<p>آزمون‌ها معمولا به شکل برنامه‌های کوچکی که هر کدام برچسبی دارند نوشته می شوند که بعضی از جنبه‌های کد شما را بازبینی می کنند. به عنوان مثال، یک مجموعه‌ی آزمون برای متد <code>toUpperCase</code> (متدهای استاندارد احتمالا توسط افراد دیگر آزموده شده اند.) ممکن است به شکل زیر باشد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_WrGyqyPbp3" href="#c_WrGyqyPbp3" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">test</span>(<span class="cm-def">label</span>, <span class="cm-def">body</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">body</span>()) <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Failed: ${</span><span class="cm-variable-2">label</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
}

<span class="cm-variable">test</span>(<span class="cm-string">&quot;convert Latin text to uppercase&quot;</span>, () <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">return</span> <span class="cm-string">&quot;hello&quot;</span>.<span class="cm-property">toUpperCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;HELLO&quot;</span>;
});
<span class="cm-variable">test</span>(<span class="cm-string">&quot;convert Greek text to uppercase&quot;</span>, () <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">return</span> <span class="cm-string">&quot;Χαίρετε&quot;</span>.<span class="cm-property">toUpperCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;ΧΑΊΡΕΤΕ&quot;</span>;
});
<span class="cm-variable">test</span>(<span class="cm-string">&quot;don't convert case-less characters&quot;</span>, () <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">return</span> <span class="cm-string">&quot;مرحبا&quot;</span>.<span class="cm-property">toUpperCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;مرحبا&quot;</span>;
});</pre>

<p><a class="p_ident" id="p_OUBG726B37" href="#p_OUBG726B37" tabindex="-1" role="presentation"></a>نوشتن آزمون هایی شبیه بالا باعث می شود که کدهای تکراری و نسبتا نامناسبی تولید شود. خوشبختانه نرم‌افزارهایی وجود دارد که به شما در ساختن و اجرای مجموعه‌های آزمون، <em>سری آزمون‌ها</em>، کمک می کنند. این کار با فراهم نمودن یک زبان (به شکل توابع و متدها) که برای تولید آزمون مناسب هستند، صورت می گیرد که  اطلاعات مفیدی در زمان شکست خوردن یک آزمون تولید می‌کنند. به این نرم‌افزارها معمولا مجری آزمون (<em>test runner</em>) می گویند.</p>

<p>آزمودن بعضی کدها آسان‌تر است. عموما، هر چه بیشتر کد برنامه با اشیاء بیرونی در ارتباط باشد، به وجود آوردن فضایی که آزمون در آن صورت پذیرد سخت تر می شود. سبک برنامه‌نویسی‌ای که در <a href="07_robot.html">فصل پیش</a> آمد، که از مقدارهای پایای مستقل استفاده می کرد، نسبت به استفاده از اشیاء تغییر پذیر،  قابلیت آزمودن آسان‌تری دارد.</p>

<h2><a class="h_ident" id="h_JsXJjW/unw" href="#h_JsXJjW/unw" tabindex="-1" role="presentation"></a>اشکال‌ زدایی</h2>

<p>بعد از اینکه متوجه وجود مشکلی در برنامه‌تان شدید چه به علت کارکرد اشتباه یا نمایش خطا، گام بعدی پیدا کردن مشکل است.</p>

<p>گاهی اوقات مشکل واضح است. متن خطا به خط خاصی از برنامه اشاره می کند و اگر به توضیحاتی که در خطا آمده و خطی که خطا در آن رخ داده است دقت کنید، معمولا مشکل را پیدا می کنید.</p>

<p>اما همیشه این طور نیست. گاهی اوقات خطی که مشکل را بروز داده فقط اولین جایی بوده است که مقدار مشکل‌دار، که خود در جای دیگری تولید شده، به صورت نادرستی به کار گرفته شده است. اگر تمرین‌هایی که در فصل‌ها پیش آمده است را حل کرده باشید حتما با موارد اینچنینی روبرو شده اید.</p>

<p>برنامه‌ی زیر سعی می کند یک عدد صحیح را بر اساس مبنای داده شده (دهدهی، دودویی،…)، به یک رشته تبدیل کند. برای این کار تابع به صورت مداوم، آخرین رقم را می گیرد و عدد را تقسیم می‌کند تا از آن رقم خلاص شود. اما خروجی عجیب غریب آن نشان می دهد که برنامه باگ دارد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_8tOR9x4PzT" href="#c_8tOR9x4PzT" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">numberToString</span>(<span class="cm-def">n</span>, <span class="cm-def">base</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;&quot;</span>, <span class="cm-def">sign</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;&quot;</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span>) {
    <span class="cm-variable-2">sign</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;-&quot;</span>;
    <span class="cm-variable-2">n</span> <span class="cm-operator">=</span> <span class="cm-operator">-</span><span class="cm-variable-2">n</span>;
  }
  <span class="cm-keyword">do</span> {
    <span class="cm-variable-2">result</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">n</span> <span class="cm-operator">%</span> <span class="cm-variable-2">base</span>) <span class="cm-operator">+</span> <span class="cm-variable-2">result</span>;
    <span class="cm-variable-2">n</span> <span class="cm-operator">/=</span> <span class="cm-variable-2">base</span>;
  } <span class="cm-keyword">while</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">sign</span> <span class="cm-operator">+</span> <span class="cm-variable-2">result</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">numberToString</span>(<span class="cm-number">13</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → 1.5e-3231.3e-3221.3e-3211.3e-3201.3e-3191.3e-3181.3…</span></pre>

<p>اگر ایراد برنامه را پیدا کرده‌اید، فعلا فرض کنید از آن خبر ندارید. می دانیم که برنامه‌ی ما درست کار نمی کند و مایلیم علت آن را کشف کنیم.</p>

<p>این زمان دقیقا لحظه‌ای است که باید در مقابل وسوسه‌ی انجام تغییرات تصادفی برای حل مشکل، ایستادگی کنید. به جای آن، کمی <em>فکر</em> کنید. آنچه در حال رخ دادن است را موشکافی کنید و نظریه‌ای پیدا کنید که بتواند این عملکرد را توضیح دهد. بعد، مشاهدات بیشتری برای آزمایش این نظریه ترتیب بدهید – یا اگر هنوز هیچ نظریه‌ای ندارید، مشاهدات بیشتری انجام دهید تا به شما در پیدا کردن یک نظریه کمک کند.</p>

<p>قرار دادن چند <bdo><code>console.log</code></bdo> استراتژیک در برنامه راه خوبی برای بدست آوردن اطلاعات بیشتر درباره‌ی شیوه‌ی عملکرد برنامه است. در این مورد، می خواهیم که <code>n</code> مقدار <code>13</code>، <code>1</code>، و سپس <code>0</code> را بگیرد. بیایید مقدار‌های این متغیر را در ابتدای حلقه چاپ کنیم.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_nB/OeL8UNa" href="#c_nB/OeL8UNa" tabindex="-1" role="presentation"></a>13
1.3
0.13
0.013
…
1.5e-323</pre>

<p><em>درست</em> است. تقسیم <code>13</code> بر <code>10</code> عدد صحیح تولید نمی کند. بجای استفاده از <bdo><code>n /= base</code></bdo>،  چیزی که در واقع نیاز داریم <bdo><code>n = Math.<wbr>floor(n /<wbr> base)</code></bdo>  است که در این صورت عدد به درستی به سمت را “شیفت” داده می شود.</p>

<p><a class="p_ident" id="p_Pa4EG7x9Fo" href="#p_Pa4EG7x9Fo" tabindex="-1" role="presentation"></a>راه جایگزین استفاده از <bdo><code>console.log</code></bdo> در برنامه برای دانستن رفتار برنامه، استفاده از ابزارهای <em>اشکال‌زدایی</em> مرورگر است. مرورگرها قابلیتی دارند که می توان با استفاده از آن در یک خط خاص از کد، یک نقطه‌ی توقف (<em>breakpoint</em>) ایجاد کرد. زمانی که اجرای برنامه به آن خط که دارای نقطه‌ی توقف است برسد ، برنامه متوقف می شود و می توانید مقادیر متغیرها را در آن نقطه بررسی کنید. قصد ندارم وارد جزئیات شوم زیرا ابزارهای رفع خطا در مرورگرهای مختلف متفاوت هستند ، می توانید به قسمت ابزارهای توسعه‌دهنده‌ی (Developer Tools) مرورگر خودتان رجوع کنید یا در اینترنت در باره‌ی آن جستجو کنید.</p>

<p>روش دیگر برای ایجاد یک نقطه‌ توقف استفاده از دستور <code>debugger</code> در برنامه است ( همین دستور با همین کلیدواژه). اگر ابزارهای توسعه‌دهنده مرورگر شما فعال است برنامه به محض اینکه به این دستور برسد متوقف می گردد.</p>

<h2><a class="h_ident" id="h_obxyOFzDIm" href="#h_obxyOFzDIm" tabindex="-1" role="presentation"></a>انتشار خطا (Error propagation)</h2>

<p>متاسفانه نمی‌توان به‌وسیله‌ی برنامه‌نویس از بروز همه‌ی مشکلات برنامه جلوگیری کرد. اگر برنامه شما با جهان بیرون به هر شکلی در ارتباط باشد، ممکن است ورودی ناقصی دریافت کند که باعث کار اضافی و بیش از حد شود یا ارتباط با شبکه مختل شود.</p>

<p>اگر تنها برای خودتان برنامه نویسی می کنید، می توانید این گونه مشکلات را تا زمانی که رخ نداده اند، در نظر نگیرید. اما اگر چیزی می سازید که قرار است توسط دیگران استفاده شود، معمولا لازم است که در صورت بروز مشکل، برنامه به طور کامل از کار نیفتد و واکنش بهتری بروز دهد. گاهی کار درست این است که با وجود دریافت ورودی نامناسب به اجرای برنامه ادامه دهیم. در دیگر شرایط، خوب است گزارش علت مشکل را پیش از بستن برنامه به کاربر نشان دهیم. به هر حال در هر دو موقعیت، برنامه بایستی به صورت فعال کاری نسبت به مشکل به وجود آمده انجام دهد.</p>

<p><a class="p_ident" id="p_7w67t3KY4f" href="#p_7w67t3KY4f" tabindex="-1" role="presentation"></a>فرض کنید تابعی به نام <code>promptNumber</code> دارید که از کاربر می خواهد تا عددی را وارد کند تا آن را برگرداند. اگر کاربر ورودی “orange” را بفرستد، خروجی تابع چه خواهد بود.؟</p>

<p><a class="p_ident" id="p_NWoZK3kTsE" href="#p_NWoZK3kTsE" tabindex="-1" role="presentation"></a>یک گزینه میتواند بازگرداندن یک مقدار خاص باشد. انتخاب رایج برای این شرایط،  <bdo><code>null،</code></bdo>  <bdo><code>undefined</code></bdo> یا <bdo>-1</bdo> است.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ssOc2pf47/" href="#c_ssOc2pf47/" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">promptNumber</span>(<span class="cm-def">question</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable">Number</span>(<span class="cm-variable">prompt</span>(<span class="cm-variable-2">question</span>));
  <span class="cm-keyword">if</span> (<span class="cm-variable">Number</span>.<span class="cm-property">isNaN</span>(<span class="cm-variable-2">result</span>)) <span class="cm-keyword">return</span> <span class="cm-atom">null</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">promptNumber</span>(<span class="cm-string">&quot;How many trees do you see?&quot;</span>));</pre>

<p>اکنون هر کدی که تابع <code>promptNumber</code> را فراخوانی می کند، باید بررسی کند که یک عدد واقعی خوانده شده باشد و در غیر این صورت، به نحوی باید آن را پوشش دهد – شاید با درخواست دوباره یا ارسال یک مقدار عددی پیش فرض. همچنین می تواند دوباره یک مقدار خاص را به فراخواننده خود برگرداند تا نشان دهد که مشکلی رخ داده است.</p>

<p>در بسیاری از موقعیت ها، مخصوصا زمانی که خطاها رایج هستند و تابع فراخواننده باید صراحتا آن‌ها را در نظر بگیرد، بازگرداندن یک مقدار خاص راه خوبی برای شناسایی بروز یک خطا محسوب می شود. روش خوبی است اما مشکلات خود را نیز دارد. اول اینکه اگر تابع می توانست هر نوع ممکنی از مقدار را برگرداند چه خواهد شد؟ در تابعی با این ویژگی، برای اینکه بتوانید بین موفقیت و شکست تمایز ایجاد کنید، باید کاری انجام دهید؛ مانند قراردادن نتیجه‌ی تابع درون یک شیء.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_aQW8dfZcRx" href="#c_aQW8dfZcRx" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">lastElement</span>(<span class="cm-def">array</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">array</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
    <span class="cm-keyword">return</span> {<span class="cm-property">failed</span>: <span class="cm-atom">true</span>};
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">return</span> {<span class="cm-property">element</span>: <span class="cm-variable-2">array</span>[<span class="cm-variable-2">array</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>]};
  }
}</pre>

<p><a class="p_ident" id="p_tMQ5huxh9h" href="#p_tMQ5huxh9h" tabindex="-1" role="presentation"></a>مشکل بعدی با بازگرداندن مقدار‌های خاص این است که این کار می تواند منجر به کدی  نامناسب بشود. اگر کدی تابع <code>promptNumber</code> را 10 مرتبه فراخوانی کند، باید 10 بار چک کند که آیا <code>null</code> برگردانده شده یا خیر. و اگر حاصل بررسی <code>null</code>، خود با برگرداندن <code>null</code> مشخص شود، فراخواننده این تابع باید به آن نیز رسیدگی کند و الی آخر.</p>

<h2><a class="h_ident" id="h_bb4D5YcqaY" href="#h_bb4D5YcqaY" tabindex="-1" role="presentation"></a>استثناءها (Exception)</h2>

<p>زمانی که یک تابع نمی تواند به صورت عادی به کار خود ادامه‌ دهد، کار درست این است که تابع متوقف شده و بلافاصله کنترل برنامه به قسمتی منتقل شود که برای حل این مشکل پیش بینی شده است. این کاری است که <em>مدیریت استثناء</em> انجام می دهد.</p>

<p>استثناءها مکانیزمی هستند که برای کدی که دچار مشکل شده است این امکان را فراهم می کنند تا بتواند یک استثناء تولید (<em>صادر</em>) کند. یک استثناء می تواند هر مقداری باشد. صدور یک استثناء تاحدی شبیه به یک ابرخروجی از یک تابع است: نه تنها از تابع بیرون می آید بلکه از فراخواننده تابع نیز خارج می شود تا به اولین فراخوانی‌ای برسد که اجرای فعلی را شروع کرده است. به این کار بازکردن پشته می گویند.  شاید پشته‌ی فراخوانی توابع را که در <a href="03_functions.html#stack">فصل 3</a> بحث شد به یاد داشته باشید. یک استثناء، این پشته را باز کرده و تمامی زمینه‌های فراخوانی‌ای را که می بیند از پشته بیرون می‌کشد.</p>

<p><a class="p_ident" id="p_nrrWTl0rlU" href="#p_nrrWTl0rlU" tabindex="-1" role="presentation"></a>اگر استثناءها همیشه تا انتهای پشته‌ حرکت کنند، کار مفیدی صورت نداده‌اند. با این کار فقط راهی جدید برای بهم ریختن برنامه‌تان فراهم ساخته اند. قدرت آن ها در این واقعیت است که می توانید “موانعی” را در پشته ایجاد کنید تا بتوانید این استثناءها را هنگامی که در حال درنوردیدن پشته هستند <em>بگیرید</em> (<em>catch</em>) (به دام بیاندازید). به محض اینکه یک استثناء را بگیرید، می توانید کاری برای حل مشکل انجام دهید و بعد از آن، برنامه به اجرای خود ادامه دهد.</p>

<p>به مثال توجه کنید:</p>

<pre id="look" class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_0VA94HjY2e" href="#c_0VA94HjY2e" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">promptDirection</span>(<span class="cm-def">question</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable">prompt</span>(<span class="cm-variable-2">question</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">toLowerCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;left&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-string">&quot;L&quot;</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">toLowerCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;right&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-string">&quot;R&quot;</span>;
  <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Invalid direction: &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">result</span>);
}

<span class="cm-keyword">function</span> <span class="cm-def">look</span>() {
  <span class="cm-keyword">if</span> (<span class="cm-variable">promptDirection</span>(<span class="cm-string">&quot;Which way?&quot;</span>) <span class="cm-operator">==</span> <span class="cm-string">&quot;L&quot;</span>) {
    <span class="cm-keyword">return</span> <span class="cm-string">&quot;a house&quot;</span>;
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">return</span> <span class="cm-string">&quot;two angry bears&quot;</span>;
  }
}

<span class="cm-keyword">try</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;You see&quot;</span>, <span class="cm-variable">look</span>());
} <span class="cm-keyword">catch</span> (<span class="cm-def">error</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Something went wrong: &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">error</span>);
}</pre>

<p>کلیدواژه‌ی <code>throw</code> برای صدور یک استثناء استفاده می شود.  گرفتن یک استثناء نیز با قراردادن کدها درون یک بلاک <code>try</code> صورت می گیرد که بعد از آن  <code>catch</code> می آید . اگر کدی که در بلاک <code>try</code> قرار دارد  باعث تولید یک استثناء شود، بلاک <code>catch</code> ارزیابی خواهد شد و نامی که درون پرانتز قرار گرفته به مقدار استثناء اختصاص می یابد.  بعد از این که اجرای بلاک <code>catch</code> اتمام یافت – یا در صورتی که بلاک <code>try</code> بدون مشکل اجرا شد – برنامه با اجرای کدهایی که زیر دستور <bdo><code>try/catch</code></bdo> قرار دارند، ادامه می یابد.</p>

<p><a class="p_ident" id="p_9j/tR832WP" href="#p_9j/tR832WP" tabindex="-1" role="presentation"></a>در این مثال، ما از سازنده‌ی <code>Error</code> استفاده کرده ایم تا مقدار استثناء را تولید کنیم. این تابع یک سازنده‌ی استاندارد جاوااسکریپت است که یک شیء با خاصیتی به نام <code>message</code> تولید می کند. در اکثر محیط‌های جاوااسکریپت، نمونه‌هایی که با این سازنده ایجاد می شوند،  اطلاعاتی درباره‌ی پشته‌ی فراخوانی دارند که در هنگام بروز استثناء وجود داشته است که اصطلاحا به آن ردپای پشته (<em>stack trace</em>) می گویند. این اطلاعات در خاصیت <code>stack</code> ذخیره می گردند و می توانند در زمان اشکال‌زدایی مفید باشند: تابعی که مشکل در آن رخ داده و توابعی که آن فراخوانی مشکل‌دار را انجام داده اند، به ما نشان داده می شوند.</p>

<p>توجه داشته‌باشید که تابع <code>look</code> احتمال به مشکل خوردن تابع <code>promptDirection</code> را اصلا در نظر نمی‌گیرد. این یک مزیت بزرگ استفاده از استثناءها است: کد مدیریت خطا فقط جایی که خطا رخ می دهد یا جایی که خطا مدیریت می شود مورد نیاز است. توابع بین این دو می توانند اصلا به آن نپردازند.</p>

<p>بسیارخوب، تقریبا …</p>

<h2><a class="h_ident" id="h_vyjpwZ6IEm" href="#h_vyjpwZ6IEm" tabindex="-1" role="presentation"></a>پاکسازی بعد از استثناءها</h2>

<p>تاثیر یک استثناء در برنامه، نوعی دیگر از جریان کنترل است. هر عملی که باعث تولید یک استثناء بشود، تقریبا هر فراخوانی تابع و دسترسی به خاصیت، ممکن است کنترل برنامه را از کد شما بگیرد.</p>

<p>این یعنی وقتی یک کد اثرات جانبی متعددی دارد، حتی اگر جریان کنترل عادی آن به نظر برسد که همیشه برقرار خواهد بود، بروز یک استثناء ممکن است از اجرای بعضی از آن ها جلوگیری کند.</p>

<p>در اینجا کد بانکی بسیار بدی را مشاهده خواهید کرد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_e3XosnGG47" href="#c_e3XosnGG47" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">accounts</span> <span class="cm-operator">=</span> {
  <span class="cm-property">a</span>: <span class="cm-number">100</span>,
  <span class="cm-property">b</span>: <span class="cm-number">0</span>,
  <span class="cm-property">c</span>: <span class="cm-number">20</span>
};

<span class="cm-keyword">function</span> <span class="cm-def">getAccount</span>() {
  <span class="cm-keyword">let</span> <span class="cm-def">accountName</span> <span class="cm-operator">=</span> <span class="cm-variable">prompt</span>(<span class="cm-string">&quot;Enter an account name&quot;</span>);
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">accounts</span>.<span class="cm-property">hasOwnProperty</span>(<span class="cm-variable-2">accountName</span>)) {
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string-2">`No such account: ${</span><span class="cm-variable-2">accountName</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">accountName</span>;
}

<span class="cm-keyword">function</span> <span class="cm-def">transfer</span>(<span class="cm-def">from</span>, <span class="cm-def">amount</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">accounts</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">&lt;</span> <span class="cm-variable-2">amount</span>) <span class="cm-keyword">return</span>;
  <span class="cm-variable">accounts</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">-=</span> <span class="cm-variable-2">amount</span>;
  <span class="cm-variable">accounts</span>[<span class="cm-variable">getAccount</span>()] <span class="cm-operator">+=</span> <span class="cm-variable-2">amount</span>;
}</pre>

<p>تابع <code>transfer</code> عمل انتقال مقداری پول را از یک حساب داده شده به حسابی دیگر  انجام می دهد و نام حساب دیگر را در حین روند کار درخواست می کند. اگر نامی غیرمعتبر به آن داده شود، <code>getAccount</code> یک استثناء صادر می کند.</p>

<p>اما تابع  <code>transfer</code> <em>ابتدا</em> پول را از حساب کم می کند، <em>بعد</em> تابع <code>getAccount</code> را قبل از اضافه نمودن پول به حساب دیگر فراخوانی می کند. اگر این تابع در آن نقطه، به وسیله‌ی یک استثناء متوقف شود، پول مورد نظر ناپدید خواهد شد.</p>

<p>این کد را می توان کمی هوشمندانه تر نوشت، به عنوان مثال، می توان تابع<code>getAccount</code> را قبل از عمل انتقال پول فراخوانی نمود. معمولا مشکلاتی از این دست، به صورت نامحسوس رخ می دهند. حتی توابعی که ظاهرا قرار نیست یک استثناء تولید کنند،  در شرایطی خاص یا در مواردی با اشتباه برنامه نویس، ممکن است این کار را انجام دهند.</p>

<p>یکی از راه‌های عبور از این مشکل استفاده کمتر از اثرات جانبی است. بازهم سبک برنامه‌نویسی‌ای که در آن به جای تغییر دادن داده‌های موجود، محاسبات روی مقادیر جدید انجام می شود، بسیار مفید خواهد بود. اگر کدی در میانه‌ی تولید یک مقدار جدید متوقف شود، کسی یک مقدار نیمه تمام را دریافت نخواهد کرد و مشکلی به وجود نمی آید.</p>

<p>اما این کار همیشه هم شدنی نیست. بنابراین برای آن قابلیت دیگری در دستور <code>try</code> در نظر گرفته شده است. می توان بعد از <code>try</code>، به جای بلاک <code>catch</code> یا علاوه بر آن، از یک بلاک <code>finally</code> استفاده کرد. یک بلاک <code>finally</code> فارغ از این که چه اتفاقی می افتد همیشه بعد از اجرای کد بلاک <code>try‌</code>، اجرا می شود.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_brWpzDAy4+" href="#c_brWpzDAy4+" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">transfer</span>(<span class="cm-def">from</span>, <span class="cm-def">amount</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">accounts</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">&lt;</span> <span class="cm-variable-2">amount</span>) <span class="cm-keyword">return</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">progress</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
  <span class="cm-keyword">try</span> {
    <span class="cm-variable">accounts</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">-=</span> <span class="cm-variable-2">amount</span>;
    <span class="cm-variable-2">progress</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
    <span class="cm-variable">accounts</span>[<span class="cm-variable">getAccount</span>()] <span class="cm-operator">+=</span> <span class="cm-variable-2">amount</span>;
    <span class="cm-variable-2">progress</span> <span class="cm-operator">=</span> <span class="cm-number">2</span>;
  } <span class="cm-keyword">finally</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">progress</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>) {
      <span class="cm-variable">accounts</span>[<span class="cm-variable-2">from</span>] <span class="cm-operator">+=</span> <span class="cm-variable-2">amount</span>;
    }
  }
}</pre>

<p>این نسخه از تابع، پیشرفت خود را رصد می کند، و در صورت بروز مشکل و خروج، متوجه ناتمام بودن وضعیت برنامه خواهد شد و آن را سامان می‌دهد.</p>

<p>توجه داشته باشید که با وجود اینکه کد مربوط به بلاک <code>finally</code> زمانی اجرا می‌شود که یک استثناء در بلاک <code>try</code> رخ می دهد، تداخلی با خود استثناء نخواهد داشت. بعد از اجرای بلاک  <code>finally،</code> پشته به بازشدن خود ادامه می دهد.</p>

<p>نوشتن برنامه‌هایی که همیشه به شکل ایده‌آل عمل کند حتی زمانی که یک استثناء در موقعیت‌های پیش بینی نشده رخ می دهد، کار بسیار دشواری است. بسیار از برنامه‌نویسان خودشان را به زحمت نمی اندازند و چون معمولا استثناءها در شرایط خاصی رخ می دهند، این مشکل به ندرت به وجود می‌آید و کسی متوجه‌ آن نمی شود. خوب یا بد بودن آن بستگی به میزان خسارتی دارد که در صورت بروز به بار خواهد آورد.</p>

<h2><a class="h_ident" id="h_+BdCo+rAg0" href="#h_+BdCo+rAg0" tabindex="-1" role="presentation"></a>گرفتن استثناءها به صورت گزینشی</h2>

<p><a class="p_ident" id="p_RlZHvnCyxo" href="#p_RlZHvnCyxo" tabindex="-1" role="presentation"></a>زمانی که یک استثناء تا انتهای پشته بدون اینکه جایی گرفته شود حرکت می کند، در انتها توسط محیط اجرایی مدیریت می شود. معنای این عبارت برای محیط‌های مختلف متفاوت است. در مرورگرها، توصیفی از خطا معمولا در کنسول جاوااسکریپت نوشته می شود (که می توان در قسمت ابزار مروگر یا منوی توسعه‌دهنده (Developer Menu) آن را پیدا کرد). در node.js، محیط بدون مرورگر مبتنی بر جاوااسکریپت که در <a href="20_node.html">فصل 20</a> به آن خواهیم پرداخت، دقت بیشتری درباره‌ی خرابی داده‌ها لحاظ می شود. در صورت وجود یک استثناء مدیریت نشده، تمامی روند برنامه متوقف می شود.</p>

<p>برای اشتباهات برنامه نویس، اغلب بهتر است بگذارید که خطا مسیر خودش را طی کند. یک استثناء مدیریت نشده، دلیل خوبی برای مشکل دار بودن یک برنامه است و کنسول جاوااسکریپت در مرورگرهای مدرن، اطلاعاتی در مورد فراخوانی‌هایی که در پشته در هنگام بروز مشکل وجود داشته اند، برای شما فراهم می کند.</p>

<p>برای مشکلاتی که <em>پیش بینی می شود</em> در هنگام استفاده از برنامه رخ دهد، متوقف شدن برنامه به خاطر یک استثناء مدیریت نشده، استراتژی وحشتناکی است.</p>

<p>استفاده‌های نادرست از زبان مانند ارجاع به متغیری که وجود ندارد، درخواست خاصیتی از مقدار <code>null</code> یا فراخوانی چیزی که از نوع تابع نیست، نیز باعث تولید استثناء می شود. این گونه استثناءها را نیز می توان گرفت و مدیریت کرد.</p>

<p>زمانی که اجرای برنامه به بدنه‌ی <code>catch</code> می رسد، می دانیم که چیزی در بلاک <code>try</code> باعث تولید استثناء شده است. اما نمی دانیم چه چیزی یا کدام استثناء رخ داده است.</p>

<p>جاوااسکریپت (نسبتا در یک غفلت آشکار) از امکان گزینش مدیریت استثناءها به صورت رسمی پشتیبانی نمی کند: یا همه‌ی استثناءها را می گیرید یا هیچ کدام را نمی‌گیرد. این باعث می شود که در زمان نوشتن بلاک <code>catch</code> <em>تصور</em> کنید استثنائی که دریافت کرده اید همانی هست که به آن فکر می کردید.</p>

<p>اما ممکن است آن نباشد. شاید این استثناء از فرض‌های اشتباه دیگری پدید آمده باشد یا ممکن است باگی را به‌وجود آورده باشید که باعث تولید یک استثناء شده است. در اینجا مثالی را مشاهده‌ می کنید که <em>سعی</em> می کند فراخوانی تابع <code>promptDirection</code> را تا زمانی که یک پاسخ معتبر دریافت کند ادامه دهد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ZxDKrGLCQ3" href="#c_ZxDKrGLCQ3" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (;;) {
  <span class="cm-keyword">try</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">dir</span> <span class="cm-operator">=</span> <span class="cm-variable">promtDirection</span>(<span class="cm-string">&quot;Where?&quot;</span>); <span class="cm-comment">// ← typo!</span>
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;You chose &quot;</span>, <span class="cm-variable-2">dir</span>);
    <span class="cm-keyword">break</span>;
  } <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Not a valid direction. Try again.&quot;</span>);
  }
}</pre>

<p><a class="p_ident" id="p_+OpeYcr13V" href="#p_+OpeYcr13V" tabindex="-1" role="presentation"></a>ساختار <bdo><code>for (;;)</code></bdo> روشی است که عامدانه حلقه‌ای ایجاد می‌کنیم که توسط خودش پایان نمی یابد. زمانی حلقه را می شکنیم که تابع یک جهت معتبر دریافت کند. اما <code>promptDirection</code> اشتباه تایپ شده است و خطای “undefined variable” را تولید می‌کند. بلاک <code>catch</code> در اینجا مقدار استثناء (<code>e</code>) را بررسی نمی کند و فرض می کند که از آن خبر دارد، در نتیجه خطای مربوط به اشتباه تایپی را به عنوان خطای ورودی نامعتبر در نظر می گیرد. این کار نه‌تنها یک حلقه‌ی بی‌نهایت تولید می کند، بلکه نمایش خطای مربوط به اشتباه‌ تایپی را نیز پنهان می کند.</p>

<p>به عنوان یک قاعده عمومی، روی استثناءها را نپوشانید مگر اینکه قصد داشته باشید آن‌ها را به جایی دیگر هدایت کنید – مثلا در شبکه برای اعلان خرابی برنامه به سیستمی دیگر. حتی در این صورت نیز، با دقت در مورد پنهان کردن اطلاعات فکر کنید.</p>

<p>خوب قصد داریم تا یک نوع خاص از استثناء را بگیریم. می‌توانیم این کار را در بلاک <code>catch</code> انجام دهیم؛ به این صورت که استثناء دریافتی را بررسی می کنیم تا ببینیم همان چیزی است که انتظارش را داریم یا خیر. در غیر این صورت، دوباره استثناء را صادر می‌کنیم. اما چگونه می توان یک استثناء را شناسایی کرد؟</p>

<p>می توانیم خاصیت <code>message</code> آن را با متن خطایی که قرار است دریافت کنیم مقایسه کنیم. اما این روش کدنویسی سست است – با این‌ کار، ما از اطلاعاتی برای تصمیم گیری در برنامه‌نویسی استفاده می کنیم که برای استفاده انسان تولید شده اند (متن خطا). به محض اینکه کسی این متن را تغییر دهد (یا ترجمه کند)، کد ما از کار خواهد افتاد.</p>

<p>در عوض، بیایید تا نوع جدیدی از خطا را ایجاد کنیم و از <code>instanceof</code>  برای شناسایی آن استفاده کنیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_miFD8lvrWj" href="#c_miFD8lvrWj" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">InputError</span> <span class="cm-keyword">extends</span> <span class="cm-variable">Error</span> {}

<span class="cm-keyword">function</span> <span class="cm-def">promptDirection</span>(<span class="cm-def">question</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable">prompt</span>(<span class="cm-variable-2">question</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">toLowerCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;left&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-string">&quot;L&quot;</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">toLowerCase</span>() <span class="cm-operator">==</span> <span class="cm-string">&quot;right&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-string">&quot;R&quot;</span>;
  <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">InputError</span>(<span class="cm-string">&quot;Invalid direction: &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">result</span>);
}</pre>

<p>کلاس جدید خطا، کلاس <code>Error</code> را گسترش می دهد (ارث‌بری). این کلاس، سازنده‌ی خودش را تعریف نمی کند، یعنی سازنده‌ی <code>Error</code> را به ارث می برد، که این سازنده رشته‌ای را به عنوان آرگومان دریافت می کند. در واقع، اصلا هیچ چیز تعریف نمی کند – کلاس تهی است. اشیاء <code>InputError</code> شبیه اشیاء <code>Error</code> رفتار می کنند با این تفاوت که آن ها کلاس متفاوتی دارند که می‌توان از آن برای شناسایی‌شان استفاده شود.</p>

<p>اکنون حلقه می تواند با دقت عمل بیشتری استثناءها را مدیریت کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ab/mR1C1nr" href="#c_ab/mR1C1nr" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (;;) {
  <span class="cm-keyword">try</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">dir</span> <span class="cm-operator">=</span> <span class="cm-variable">promptDirection</span>(<span class="cm-string">&quot;Where?&quot;</span>);
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;You chose &quot;</span>, <span class="cm-variable-2">dir</span>);
    <span class="cm-keyword">break</span>;
  } <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">e</span> <span class="cm-keyword">instanceof</span> <span class="cm-variable">InputError</span>) {
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Not a valid direction. Try again.&quot;</span>);
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">throw</span> <span class="cm-variable-2">e</span>;
    }
  }
}</pre>

<p>در این جا فقط نمونه‌های استثناء <code>InputError</code> گرفته و مدیریت می شوند و دیگر استثناءهای نامربوط به حال خود رها می شوند.  اگر دوباره خطای تایپی را تولید کنید، خطای مربوط به متغیر تعریف نشده به درستی گزارش خواهد شد.</p>

<h2><a class="h_ident" id="h_ZcE+GukeaL" href="#h_ZcE+GukeaL" tabindex="-1" role="presentation"></a>بیانیه‌ها (Assertions)</h2>

<p><em>بیانیه‌ها</em> در واقع آزمون‌هایی هستند که در برنامه قرار می‌گیرند تا صحت عملکرد چیز‌های مختلف را بررسی کنند. از آن ها برای مدیریت شرایطی که در عملیات معمولی رخ می دهد استفاده نمی شود؛ بلکه کاربرد آن‌ها در پیدا کردن اشتباهات برنامه نویس می‌باشد.</p>

<p>به عنوان مثال، <code>firstElement</code> به عنوان یک تابع توصیف شده است که هرگز نباید بر روی آرایه‌های خالی فراخوانی شود. ممکن است که آن را به این شکل بنویسیم:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_gRlHo3tyh8" href="#c_gRlHo3tyh8" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">firstElement</span>(<span class="cm-def">array</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">array</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;firstElement called with []&quot;</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">array</span>[<span class="cm-number">0</span>];
}</pre>

<p>حال، به جای اینکه بی سر و صدا مقدار undefined را برگردانیم‌ ( چیزی که در صورت خواندن خانه‌ای از آرایه که وجود ندارد، دریافت می کنید)، روش بالا باعث می شود که برنامه در صورت استفاده نادرست کلا متوقف شود. استفاده از این روش موجب می شود که اشتباهاتی از این دست کمتر نادیده گرفته شوند و آسان تر بتوان علت‌شان را پیدا کرد.</p>

<p><a class="p_ident" id="p_YFRPEHV2qn" href="#p_YFRPEHV2qn" tabindex="-1" role="presentation"></a>پیشنهاد نمی کنم که از assertion برای هر گونه ورودی نادرست استفاده کنید. این نیاز به کار زیادی دارد و کدی شلوغ تولید می کند.  بهتر است که آن ها را برای اشتباهاتی که انجامشان ساده است (یا شما زیاد مرتکب آن ها می شوید) نگه دارید.</p>

<h2><a class="h_ident" id="h_EzvDUHyjs2" href="#h_EzvDUHyjs2" tabindex="-1" role="presentation"></a>خلاصه</h2>

<p>اشتباهات و ورودی های نادرست واقعیت های زندگی هستند. یکی از بخش های مهم برنامه نویسی، پیداکردن، تشخیص و رفع باگ‌ها و اشکالات است. اگر مجموعه‌ای از آزمون‌های خودکار تعریف کرده باشید یا از assertion ها در برنامه‌هایتان استفاده نمایید، می توانید مشکلات برنامه را آسان‌تر شناسایی کنید.</p>

<p>باید مشکلاتی که توسط عوامل بیرون از کنترل برنامه ایجاد ‌می‌شوند را نیز به خوبی مدیریت کرد. گاهی اوقات، مثلا زمانی که می توان یک مشکل را به صورت محلی مدیریت کرد، استفاده از مقادیر خروجی خاص،‌ روش خوبی برای مدیریت خطاها محسوب می‌شود. در دیگر موارد، استفاده از استثناء‌ها ممکن است گزینه‌ی بهتری باشد.</p>

<p>صدور یک استثناء باعث می شود که پشته‌ی فراخوانی تا زمانی که به بلاک <bdo><code>try/catch</code></bdo> دربرگیرنده‌ی بعدی یا به پایان پشته برسد، باز بماند. مقدار استثناء به درون بلاک <code>catch</code> که آن را گرفته است، فرستاده می شود؛ که باید نوع آن شناسایی شود تا به آن واکنش متناسب داده شود. برای رفع مشکل جریان کنترل غیرقابل پیش‌بینی، که در صورت استفاده از استثناء‌ها به وجود می آید، می توان از بلاک‌های <code>finally</code> استفاده کرد تا اطمینان حاصل شود که یک کد خاص همیشه بعد از اتمام یک بلاک، اجرا خواهد شد.</p>

<h2><a class="h_ident" id="h_ggOFdVwDCk" href="#h_ggOFdVwDCk" tabindex="-1" role="presentation"></a>تمرین‌ها</h2>

<h3><a class="i_ident" id="i_+JPavxqHof" href="#i_+JPavxqHof" tabindex="-1" role="presentation"></a>تلاش مجدد</h3>

<p><a class="p_ident" id="p_51cGCypCAk" href="#p_51cGCypCAk" tabindex="-1" role="presentation"></a>فرض کنید تابعی به نام <code>primitiveMultiply</code> دارید که در 20 درصد از موارد، دو عدد را در هم ضرب می کند و در 80 درصد دیگر، استثنایی از نوع <code>MultiplicatorUnitFailure</code> تولید می کند. تابعی بنویسید که این تابع مشکل‌دار را پوشانده و تا زمانیکه یک فراخوانی موفق داشته باشد، به تلاش خود ادامه می دهد و بعد از آن نتیجه را بر‌می‌گرداند.</p>

<p>اطمینان حاصل کنید که فقط استثناء‌هایی را مدیریت می کنید که باید مدیریت شوند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_E1Acr2VS8k" href="#c_E1Acr2VS8k" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">MultiplicatorUnitFailure</span> <span class="cm-keyword">extends</span> <span class="cm-variable">Error</span> {}

<span class="cm-keyword">function</span> <span class="cm-def">primitiveMultiply</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">&lt;</span> <span class="cm-number">0.2</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">*</span> <span class="cm-variable-2">b</span>;
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">MultiplicatorUnitFailure</span>(<span class="cm-string">&quot;Klunk&quot;</span>);
  }
}

<span class="cm-keyword">function</span> <span class="cm-def">reliableMultiply</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-comment">// Your code here.</span>
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">reliableMultiply</span>(<span class="cm-number">8</span>, <span class="cm-number">8</span>));
<span class="cm-comment">// → 64</span></pre>

<div class="solution"><div class="solution-text">

<p>فراخوانی تابع <code>primitiveMultiply</code> باید قطعا درون یک بلاک <code>try</code> قرار گیرد. بلاک <code>catch</code> مربوط به آن باید استثناء دریافتی را درصورتی که نمونه‌ای از <code>MultiplicatorUnitFailure</code> نباشد، دوباره صادر کند و اطمینان حاصل کند که در صورت وجود استثناء مورد نظر، تابع را دوباره فراخوانی می‌کند.</p>

<p>برای انجام عمل تلاش مجدد، می توانید از یک حلقه استفاده کنید که فقط زمانی متوقف می‌شود که یک فراخوانی، موفق می شود - مانند  <a href="08_error.html#look">مثال <code>look</code></a> که پیش‌تر در این فصل آمد - یا از روش بازگشتی استفاده کنید و امیدوار باشید که با رشته‌ای از شکست روبرو نمی‌شود که در این صورت باعث سرریز پشته خواهد شد.</p>

</div></div>

<h3><a class="i_ident" id="i_cprZvj4T/m" href="#i_cprZvj4T/m" tabindex="-1" role="presentation"></a>جعبه قفل شده</h3>

<p>شیء (ساختگی) زیر را در نظر بگیرید:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_X963W9SHCK" href="#c_X963W9SHCK" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">box</span> <span class="cm-operator">=</span> {
  <span class="cm-property">locked</span>: <span class="cm-atom">true</span>,
  <span class="cm-property">unlock</span>() { <span class="cm-keyword">this</span>.<span class="cm-property">locked</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>; },
  <span class="cm-property">lock</span>() { <span class="cm-keyword">this</span>.<span class="cm-property">locked</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;  },
  <span class="cm-property">_content</span>: [],
  <span class="cm-property">get</span> <span class="cm-property">content</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">locked</span>) <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Locked!&quot;</span>);
    <span class="cm-keyword">return</span> <span class="cm-keyword">this</span>.<span class="cm-property">_content</span>;
  }
};</pre>

<p>این شیء یک جعبه است که دارای یک قفل می‌باشد. درون این جعبه‌، یک آرایه وجود دارد؛ اما فقط زمانی می توانید به آن دسترسی داشته باشید که جعبه قفل نباشد. دسترسی مستقیم به خاصیت خصوصی <bdo><code>_content</code></bdo> ممنوع است.</p>

<p>تابعی به نام <code>withBoxUnlocked</code> بنویسید که یک مقدار تابع را به عنوان آرگومان دریافت می کند، جعبه را باز می کند، تابع را اجرا می کند، و بعد اطمینان حاصل می کند که قبل از برگرداندن آن، جعبه دوباره قفل شده باشد، فارغ از اینکه تابع آرگومان به صورت نرمال برگردانده شده است یا یک استثناء تولید کرده است.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_YP9F77f8HR" href="#c_YP9F77f8HR" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">box</span> <span class="cm-operator">=</span> {
  <span class="cm-property">locked</span>: <span class="cm-atom">true</span>,
  <span class="cm-property">unlock</span>() { <span class="cm-keyword">this</span>.<span class="cm-property">locked</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>; },
  <span class="cm-property">lock</span>() { <span class="cm-keyword">this</span>.<span class="cm-property">locked</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;  },
  <span class="cm-property">_content</span>: [],
  <span class="cm-property">get</span> <span class="cm-property">content</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">locked</span>) <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Locked!&quot;</span>);
    <span class="cm-keyword">return</span> <span class="cm-keyword">this</span>.<span class="cm-property">_content</span>;
  }
};

<span class="cm-keyword">function</span> <span class="cm-def">withBoxUnlocked</span>(<span class="cm-def">body</span>) {
  <span class="cm-comment">// Your code here.</span>
}

<span class="cm-variable">withBoxUnlocked</span>(<span class="cm-keyword">function</span>() {
  <span class="cm-variable">box</span>.<span class="cm-property">content</span>.<span class="cm-property">push</span>(<span class="cm-string">&quot;gold piece&quot;</span>);
});

<span class="cm-keyword">try</span> {
  <span class="cm-variable">withBoxUnlocked</span>(<span class="cm-keyword">function</span>() {
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Pirates on the horizon! Abort!&quot;</span>);
  });
} <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Error raised:&quot;</span>, <span class="cm-variable-2">e</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">box</span>.<span class="cm-property">locked</span>);
<span class="cm-comment">// → true</span></pre>

<p>برای برداشتن گامی بیشتر، مطمئن شود که اگر تابع <code>withBoxUnlocked</code> را در هنگام باز بودن جعبه فراخوانی می کنید، جعبه باز باقی بماند.</p>

<div class="solution"><div class="solution-text">

<p>این تابع به یک بلاک <code>finally</code> نیاز دارد. تابع شما ابتدا باید جعبه را باز کند سپس تابع موجود در آرگومان را از درون یک بلاک <code>try</code> فراخوانی کند.  بلاک <code>finally</code> بعد از آن باید جعبه را دوباره قفل کند.</p>

<p><a class="p_ident" id="p_c0w8Z9ugmb" href="#p_c0w8Z9ugmb" tabindex="-1" role="presentation"></a>برای حصول اطمینان از قفل نکردن جعبه زمانی که پیش از این باز بوده است، قفل بودن‌ آن را در ابتدای تابع چک کنید و فقط زمانی آن را باز و بسته کنید که در ابتدا قفل بوده است. hint}}</p>

</div></div><nav><a href="07_robot.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="09_regexp.html" title="next chapter">▶</a></nav>
</article>
