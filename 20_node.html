<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Node.js :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 20;</script><script>var clicky_site_ids = clicky_site_ids || []; clicky_site_ids.push(101171577);</script>
  <script async src="//static.getclicky.com/js"></script>

</head>

<article>
<nav><a href="19_paint.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="21_skillsharing.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>Chapter 20</span>Node.js</h1>

<blockquote>

<p><a class="p_ident" id="p_5nbvR9GhQC" href="#p_5nbvR9GhQC" tabindex="-1" role="presentation"></a>دانش‌آموزی پرسید، 'برنامه‌نویس‌های قدیم فقط با کامپیوترهای ابتدایی و بدون استفاده از زبان‌های برنامه‌نویسی، توانستند برنامه‌های زیبایی بنویسند. چرا ما از کامپیوترهای پیشرفته و زبان‌های برنامه نویسی استفاده می‌کنیم؟ '. Fu-Tzu پاسخ داد، معمار‌های قدیم هم فقط از خشت و چوب استفاده می‌کردند، البته کلبه‌های زیبایی هم می‌ساختند.’</p>

<footer>استاد Yuan-Ma, <cite>کتاب برنامه‌نویسی</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_20.jpg" alt="Picture of a telephone pole"></figure>

<p><a class="p_ident" id="p_w1tmS90Vcy" href="#p_w1tmS90Vcy" tabindex="-1" role="presentation"></a>تاکنون، از جاوااسکریپت فقط در یک محیط اجرایی استفاده کرده ایم: مرورگر.  در این فصل و همچنین فصل <a href="21_skillsharing.html">بعد</a>، کمی به سراغ معرفی Node.js خواهیم رفت، برنامه‌ای که شما را قادر می سازد تا مهارت‌های کدنویسی‌تان در جاوااسکریپت را به خارج از مرورگر ببرید. به کمک Node می توانید هرچیزی از یک ابزار کوچک برای خط فرمان تا سرویس‌دهنده‌های HTTP برای سایت‌های پویا بسازید.</p>

<p><a class="p_ident" id="p_yIW8y+sKhk" href="#p_yIW8y+sKhk" tabindex="-1" role="presentation"></a>هدف این دو فصل آموزش مفاهیم اصلی Node.js است؛ تا برای نوشتن برنامه‌های Node.js اطلاعات کافی در اختیار داشته باشید. طبیعتا محتوای آن‌ها کامل و جامع نیست.</p>

<p><a class="p_ident" id="p_Jg96jNT2k4" href="#p_Jg96jNT2k4" tabindex="-1" role="presentation"></a>کدهای فصل پیش را می توانستید به طور مستقیم در صفحات اجرا کنید، زیرا آن‌ها یا جاوااسکریپت خام بودند یا برای مرورگر نوشته شده بودند. اما نمونه‌ کدهای این فصل برای محیط Node نوشته شده اند و اغلب در مرورگر قابل اجرا نمی باشند.</p>

<p><a class="p_ident" id="p_yPRrPvdnzK" href="#p_yPRrPvdnzK" tabindex="-1" role="presentation"></a>اگر می خواهید همراه با این فصل کد‌ها را نیز امتحان کنید، لازم است تا Node.js نسخه‌ی 10.1 یا بالاتر را نصب کنید. برای این کار به آدرس <a href="https://nodejs.org"><em>https://nodejs.org</em></a> بروید و طبق دستور راهنما، آن را روی سیستم عامل تان نصب کنید. همچنین در این آدرس مستندات بیشتری برای Node.js موجود است.</p>

<h2><a class="h_ident" id="h_rp9EmlvDs7" href="#h_rp9EmlvDs7" tabindex="-1" role="presentation"></a>پیش‌زمینه</h2>

<p><a class="p_ident" id="p_2jmj7l5rSw" href="#p_2jmj7l5rSw" tabindex="-1" role="presentation"></a>یکی از چالش‌های پررنگ‌تر در برنامه‌نویسی سیستم‌هایی که در شبکه تعامل دارند، مدیریت  ورودی و خروجی  است- که همان خواندن و نوشتن داده‌ها از و به شبکه و دیسک سخت است. جابجایی داده‌ها زمان‌بر است، و زمان‌بندی  هوشمندانه‌ی آن می تواند تفاوت چشم‌گیری در پاسخ‌دهی سریع یک سیستم به کاربر یا درخواست‌های شبکه ایجاد کند.</p>

<p><a class="p_ident" id="p_woPjde2M6/" href="#p_woPjde2M6/" tabindex="-1" role="presentation"></a>در این‌گونه برنامه‌ها، برنامه‌نویسی ناهمگام بیشتر سودمند است. زیرا به برنامه اجازه می‌دهد داده‌ها را از و به چندین دستگاه در یک زمان دریافت و ارسال کند بدون پیچیدگی مدیریت thread و هماهنگ‌سازی آن‌ها.</p>

<p><a class="p_ident" id="p_YUuPQBiKWe" href="#p_YUuPQBiKWe" tabindex="-1" role="presentation"></a>Node در ابتدا به منظور آسان‌سازی برنامه‌نویسی ناهمگام ابداع شد. جاوااسکریپت بسیار مناسب سیستمی مانند Node است. جاوااسکریپت یکی از معدود زبان‌های برنامه‌نویسی است که به صورت درونی و ذاتی راهی برای پشتیبانی  از عملیات  ورودی/خروجی ندارد. بنابراین، می توانست گزینه‌ی مناسبی برای رویکرد نامتعارف Node در مدیریت I/O باشد بدون اینکه در انتها شاهد وجود دو رابط ناسازگار باشیم. در سال 2009، زمانی که Node در حال طراحی شدن بود، برنامه‌نویسی مبتنی بر callback در مرورگر مرسوم بود، بنابراین جامعه‌ی فعال در جاوااسکریپت به سبک برنامه‌نویسی ناهمگام آشنا بودند.</p>

<h2><a class="h_ident" id="h_XhZA2oM1dd" href="#h_XhZA2oM1dd" tabindex="-1" role="presentation"></a>دستور node</h2>

<p><a class="p_ident" id="p_Kzh6PibMf8" href="#p_Kzh6PibMf8" tabindex="-1" role="presentation"></a>پس از نصب Node.js روی یک سیستم، برنامه‌ای به نام <code>node</code> در دسترس خواهد بود، که برای اجرای فایل‌های جاوااسکریپت استفاده می شود. فرض کنید فایلی به نام <code>hello.js</code> دارید، که کد زیر را دارد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Ys/5/PYPJK" href="#c_Ys/5/PYPJK" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">message</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;Hello world&quot;</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">message</span>);</pre>

<p>می توانید <code>node</code> را از خط فرمان مانند مثال زیر برای اجرای برنامه استفاده کنید.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_+NijqTTZNf" href="#c_+NijqTTZNf" tabindex="-1" role="presentation"></a>$ node hello.js
Hello world</pre>

<p><a class="p_ident" id="p_doZBzPzjj9" href="#p_doZBzPzjj9" tabindex="-1" role="presentation"></a>متد <code>console.log</code> در محیط Node، کاربردی شبیه به عملکردش در مرورگر دارد. چاپ یک رشته‌ی متنی. اما در Node، این متن به جای اینکه به کنسول جاوااسکریپت مرورگر داده شود، به استریم خروجی استاندارد پروسه‌  (process) ارسال می‌شود . در هنگام اجرای <code>node</code> از طریق خط فرمان، گزارش‌های تولیدی توسط این متد را می‌توانید در ترمینال خط‌ فرمانتان مشاهده  کنید.</p>

<p>اگر دستور <code>node</code> را بدون مشخص نمودن یک فایل اجرا کنید، به شما فضایی برای نوشتن کد جاوااسکریپت خواهد داد، تا بتوانید نتیجه را بلافاصله مشاهده کنید.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_d/9k6S5oD+" href="#c_d/9k6S5oD+" tabindex="-1" role="presentation"></a>$ node
&gt; 1 + 1
2
&gt; [-1, -2, -3].map(Math.abs)
[1, 2, 3]
&gt; process.exit(0)
$</pre>

<p>متغیر <code>process</code> درست مثل  <code>console</code>، به صورت سراسری در Node در دسترس است. این متغیر روش‌هایی برای بررسی و دستکاری برنامه‌ی فعلی را در اختیارتان می‌گذارد. متد <code>exit</code> باعث به اتمام رساندن پروسه‌ی فعلی می‌شود که یک کد وضعیت خروج را نیز می‌تواند دریافت کند؛ کدی که به برنامه‌ی اجرا‌کننده‌ی <code>node</code> (در اینجا پوسته‌ی خط فرمان) اطلاع می‌دهد که برنامه‌ی مورد نظر با موفقیت به اتمام رسیده است (کد صفر ) یا با خطایی روبرو شده است (هر کد دیگری).</p>

<p><a class="p_ident" id="p_2kuSN7rMzf" href="#p_2kuSN7rMzf" tabindex="-1" role="presentation"></a>برای دستیابی به آرگومان‌هایی که توسط خط فرمان به اسکریپت شما داده‌ می‌شود، می توانید ‍<code>process.argv</code> را بخوانید، که آرایه‌ای از رشته‌ است. توجه داشته باشید که نام اسکریپت شما و دستور <code>node‍</code> را نیز در بر دارد. بنابراین آرگومان‌های مورد نظر از خانه‌ی 2  آرایه شروع می شوند. اگر <code>showargv.js</code> حاوی دستور  <br><bdo><code>console.<wbr>log(process.<wbr>argv)</code></bdo> باشد، می‌توانید به شکل زیر آن را اجرا نمایید:</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_WCisDZr57g" href="#c_WCisDZr57g" tabindex="-1" role="presentation"></a>$ node showargv.js one --and two
[&quot;node&quot;, &quot;/tmp/showargv.js&quot;, &quot;one&quot;, &quot;--and&quot;, &quot;two&quot;]</pre>

<p>تمامی متغیر‌های سراسری جاوااسکریپت استاندارد، مانند <code>Array</code>، <code>Math</code>، و <code>JSON</code>، همه در محیط Node نیز در دسترس هستند. اما آن موارد مخصوص به مروگر مثل <code>document</code> یا <code>prompt</code> طبیعتا وجود ندارند.</p>

<h2><a class="h_ident" id="h_3Uyo5Wx/hs" href="#h_3Uyo5Wx/hs" tabindex="-1" role="presentation"></a>ماژول‌ها</h2>

<p><a class="p_ident" id="p_Yxh4AqLbfn" href="#p_Yxh4AqLbfn" tabindex="-1" role="presentation"></a>Node علاوه بر متغیرهایی که معرفی شد، مانند <code>console</code> و <code>process</code>، چند متغیر دیگر را نیز در فضای سراسری قرار داده است. اگر بخواهید به امکانات و ویژگی‌های درونی دسترسی داشته باشید، باید از سیستم ماژول Node کمک بگیرید.</p>

<p><a class="p_ident" id="p_sA4x7oJIob" href="#p_sA4x7oJIob" tabindex="-1" role="presentation"></a>سیستم ماژول CommonJS، که بر اساس تابع <code>require</code> می‌باشد، در <a href="10_modules.html#commonjs">فصل 10</a> توصیف شد. این سیستم به صورت درونی در Node قرار داده شده است و برای بارگیری ماژول‌ها چه درونی چه بارگیری شده به صورت بسته و همچنین فایل‌های موجود در برنامه‌ی شما استفاده می ‌شود.</p>

<p><a class="p_ident" id="p_vLcqHr9quw" href="#p_vLcqHr9quw" tabindex="-1" role="presentation"></a>زمانی که تابع <code>require</code> فراخوانی می‌شود، Node باید رشته‌ی داده‌شده را به فایلی که بتوان بارگیری کرد تفسیر کند.  مسیر‌هایی که با <code>/</code> ، <bdo><code>./</code></bdo> یا <bdo><code>../</code></bdo> شروع می شوند با توجه به مسیر ماژول فعلی به صورت نسبی تفسیر می شوند. که <code>.</code> نماینده‌ی پوشه‌ی فعلی، <bdo><code>../</code></bdo> به معنای یک پوشه بالاتر و <code>/</code> به معنای root یا ریشه‌ در سیستم فایل می‌باشد. بنابراین اگر درخواست <bdo><code>&quot;./<wbr>graph&quot;</code></bdo> را از درون <bdo><code>/<wbr>tmp/<wbr>robot/<wbr>robot.<wbr>js</code></bdo> داشته باشید، Node به دنبال بارگیری <bdo><code>/<wbr>tmp/<wbr>robot/<wbr>graph.<wbr>js</code></bdo> خواهد بود.</p>

<p>می توان از نوشتن پسوند <bdo><code>.js</code></bdo> صرف نظر کرد، زیرا Node در صورت وجود فایل مورد نظر، آن را خود در نظر خواهد گرفت. اگر مسیر خواسته شده به یک پوشه اشاره کند، Node سعی می کند تا فایلی به نام <code>index.js</code> را از آن پوشه بارگیری کند.</p>

<p><a class="p_ident" id="p_6geZ8EzF1v" href="#p_6geZ8EzF1v" tabindex="-1" role="presentation"></a>زمانی که یک رشته‌ی متنی که شباهتی به یک مسیر نسبی یا مطلق ندارد به تابع <code>require</code> داده می‌شود، فرض بر آن است که یا یک ماژول درونی، مورد نظر است یا ماژولی که در پوشه‌ی <code>node_modules</code> نصب شده است. به عنوان مثال، <code>require(&quot;fs&quot;)</code> به شما ماژول مدیریت سیستم فایل  درونی Node را خواهد داد. و <code>require(&quot;robot&quot;)</code> نیز سعی خواهد کرد تا بسته‌ای که در <bdo><code>node_modules/<wbr>robot/<wbr></code></bdo> وجود دارد را بارگیری کند. روش رایج نصب این گونه‌ بسته‌ها یا کتابخانه‌ها، استفاده از NPM است که به زودی آن را توضیح خواهیم داد.</p>

<p>بیایید یک پروژه‌ی کوچک شامل دو فایل ایجاد کیم. فایل اول <code>main.js</code> است که اسکریپتی است که می توان آن را از خط فرمان اجرا کرد و رشته‌ای را وارونه می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_P0yKauuaN8" href="#c_P0yKauuaN8" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">reverse</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;./reverse&quot;</span>);

<span class="cm-comment">// Index 2 holds the first actual command line argument</span>
<span class="cm-keyword">let</span> <span class="cm-def">argument</span> <span class="cm-operator">=</span> <span class="cm-variable">process</span>.<span class="cm-property">argv</span>[<span class="cm-number">2</span>];

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">reverse</span>(<span class="cm-variable">argument</span>));</pre>

<p>فایل بعدی <code>reverse.js</code> یک کتابخانه برای وارونه‌کردن رشته‌ها تعریف می کند، که می توان از آن هم برای این ابزار خط فرمان بهره برد و هم دیگر اسکریپت‌هایی که نیاز به دسترسی مستقیم به تابعی برای وارونه‌سازی رشته‌ها دارند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_xPNlH3e9Ye" href="#c_xPNlH3e9Ye" tabindex="-1" role="presentation"></a><span class="cm-variable">exports</span>.<span class="cm-property">reverse</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">string</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">Array</span>.<span class="cm-property">from</span>(<span class="cm-variable-2">string</span>).<span class="cm-property">reverse</span>().<span class="cm-property">join</span>(<span class="cm-string">&quot;&quot;</span>);
};</pre>

<p><a class="p_ident" id="p_IZQKtxE5GA" href="#p_IZQKtxE5GA" tabindex="-1" role="presentation"></a>به خاطر داشته باشید که افزودن خاصیت‌ها به <code>exports</code> باعث می‌شود که آن‌ها به رابط ماژول اضافه شوند. به دلیل اینکه Node.js فایل‌ها را به عنوان ماژول‌های CommonJs در نظر می‌گیرد، <code>main.js</code> می تواند تابع صادر شده‌ی (exported) <code>reverse</code> را از فایل <code>reverse.js</code> بردارد.</p>

<p>اکنون می توانیم ابزارمان را به شکل زیر فراخوانی کنیم:</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_k81NC+cAsi" href="#c_k81NC+cAsi" tabindex="-1" role="presentation"></a>$ node main.js JavaScript
tpircSavaJ</pre>

<h2><a class="h_ident" id="h_f+ft+UI15z" href="#h_f+ft+UI15z" tabindex="-1" role="presentation"></a>نصب به وسیله‌ی NPM</h2>

<p><a class="p_ident" id="p_wrloFpKb51" href="#p_wrloFpKb51" tabindex="-1" role="presentation"></a>NPM، که در<a href="10_modules.html#modules_npm">فصل 10</a> معرفی شد، مخزنی آنلاین از ماژول‌های جاوااسکریپت است که خیلی از آن‌ها به طور خاص برای Node نوشته شده اند. زمانی که Node را روی کامپیوترتان نصب می کنید، دستور <code>npm</code> نیز در دسترس شما قرار می‌گیرد که به کمک آن می توانید با این مخزن تعامل کنید.</p>

<p><a class="p_ident" id="p_HfYoGdoaSL" href="#p_HfYoGdoaSL" tabindex="-1" role="presentation"></a>کاربرد اصلی NPM بارگیری بسته‌ها می باشد. با بسته‌ی <code>ini</code> در <a href="10_modules.html#modules_ini">فصل 10</a> آشنا شدیم. می توانیم با استفاده از NPM آن را دریافت و روی کامپیوترمان نصب کنیم.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_BggMWensXe" href="#c_BggMWensXe" tabindex="-1" role="presentation"></a>$ npm install ini
npm WARN enoent ENOENT: no such file or directory,
         open '/tmp/package.json'
+ ini@1.3.5
added 1 package in 0.552s

$ node
&gt; const {parse} = require(&quot;ini&quot;);
&gt; parse(&quot;x = 1\ny = 2&quot;);
{ x: '1', y: '2' }</pre>

<p><a class="p_ident" id="p_fZTrvwf1QX" href="#p_fZTrvwf1QX" tabindex="-1" role="presentation"></a>پس از اجرای <code>npm install</code>، برنامه‌ی NPM یک پوشه به نام <code>node_modules</code> ایجاد خواهد کرد. درون آن پوشه، پوشه‌ای دیگر به نام <code>ini</code> خواهد بود که حاوی کتابخانه‌ی مورد نظر می باشد. می‌توانید آن را باز کنید و نگاهی به کدهایش بیاندازید. زمانی که <code>require(&quot;ini&quot;)</code> را فراخوانی می‌کنیم، این کتابخانه بارگیری می شود و می‌توانیم خاصیت <code>parse</code> آن را فراخوانی کنیم تا فایل تنظیمات ما خوانده شود.</p>

<p>به صورت پیش‌فرض NPM بسته‌ها را در پوشه‌ی فعلی نصب می کند، نه در یک جای مرکزی. اگر به دیگر مدیریت‌ بسته‌ها عادت کرده اید، ممکن است برای‌تان جدید باشد، اما این‌کار مزیت‌های خودش را دارد- هر اپلیکیشن کنترل کامل روی بسته‌هایی که نصب می کند خواهد داشت و آسان‌تر می‌توان نسخه‌هایش را مدیریت کرد و در هنگام حذف اپلیکیشن آن‌ها را حذف نمود.</p>

<h3><a class="i_ident" id="i_GEmGvekCx7" href="#i_GEmGvekCx7" tabindex="-1" role="presentation"></a>فایل‌های بسته</h3>

<p>در مثال <code>npm install</code>، یه پیام هشدار در مورد نبود فایل ‍<code>package.json</code> را مشاهده کردید. ساخت این فایل برای هر پروژه توصیه می‌شود، چه به صورت دستی چه با استفاده از دستور <code>npm init</code>. این فایل حاوی اطلاعاتی درباره‌ی پروژه می باشد مانند نام پروژه، نسخه‌ی آن و لیست وابستگی‌های آن.</p>

<p>شبیه‌سازی ربات از فصل <a href="07_robot.html">فصل 7</a> ، که در تمرین مربوط به فصل <a href="10_modules.html#modular_robot">فصل 10</a> ماژولار شد، می تواند یک فایل ‍<code>package.json</code> شبیه این داشته باشد:</p>

<pre class="snippet cm-s-default" data-language="application/json" ><a class="c_ident" id="c_K51zuXso4A" href="#c_K51zuXso4A" tabindex="-1" role="presentation"></a>{
  <span class="cm-string cm-property">&quot;author&quot;</span>: <span class="cm-string">&quot;Marijn Haverbeke&quot;</span>,
  <span class="cm-string cm-property">&quot;name&quot;</span>: <span class="cm-string">&quot;eloquent-javascript-robot&quot;</span>,
  <span class="cm-string cm-property">&quot;description&quot;</span>: <span class="cm-string">&quot;Simulation of a package-delivery robot&quot;</span>,
  <span class="cm-string cm-property">&quot;version&quot;</span>: <span class="cm-string">&quot;1.0.0&quot;</span>,
  <span class="cm-string cm-property">&quot;main&quot;</span>: <span class="cm-string">&quot;run.js&quot;</span>,
  <span class="cm-string cm-property">&quot;dependencies&quot;</span>: {
    <span class="cm-string cm-property">&quot;dijkstrajs&quot;</span>: <span class="cm-string">&quot;^1.0.1&quot;</span>,
    <span class="cm-string cm-property">&quot;random-item&quot;</span>: <span class="cm-string">&quot;^1.0.0&quot;</span>
  },
  <span class="cm-string cm-property">&quot;license&quot;</span>: <span class="cm-string">&quot;ISC&quot;</span>
}</pre>

<p>زمانی که دستور <code>npm install</code> را بدون نام بردن یک بسته برای نصب اجرا می کنید، NPM به سراغ لیست وابستگی‌های موجود در <code>package.json‍</code> می رود. زمانی که یک بسته‌ی مشخص را نصب می کنید که پیش از این به عنوان یک وابستگی لیست نشده است، NPM آن را به <code>package.json</code> اضافه می کند.</p>

<h3><a class="i_ident" id="i_DL5xVDxHxq" href="#i_DL5xVDxHxq" tabindex="-1" role="presentation"></a>نسخه‌ها</h3>

<p>یک فایل <code>package.json</code> هم نسخه‌ی خود برنامه را نگه‌داری می کند هم نسخه‌های وابستگی‌هایش را. نسخه‌ها روشی‌ هستند که می توان به وسیله‌ی آن‌ها، با این واقعیت که بسته‌ها جداگانه تغییر می‌کنند و کدی که مثلا نوشته شده تا با بسته‌ای کار کند، ممکن است با نسخه‌ی بعدی آن یا نسخه‌ای ویرایش شده از آن کار نکند.</p>

<p><a class="p_ident" id="p_aataPSoIdb" href="#p_aataPSoIdb" tabindex="-1" role="presentation"></a>بر طبق NPM بسته‌ها باید از شمایی موسوم به semantic versioning یا نسخه‌بندی معنایی پیروی کنند، که اطلاعاتی در مورد نسخه‌هایی که سازگار هستند (به این معنا که رابط قبلی را پشتیبانی می‌کنند) را در شماره‌ی نسخه لحاظ می کند. یک نسخه‌ی معنایی از سه عدد تشکیل می‌شود، که هر کدام با نقطه جدا می شوند، مانند <code>2.3.0</code>. هربار که یک ویژگی جدید به بسته اضافه می‌شود، به عدد میانی باید افزوده شود. هربار که سازگاری شکسته شود، که در این صورت کد موجود ممکن است با این نسخه دیگر کار نکند، عدد ابتدایی باید تغییر یابد.</p>

<p><a class="p_ident" id="p_rhM5I1Lnah" href="#p_rhM5I1Lnah" tabindex="-1" role="presentation"></a>کاراکتر (<code>^</code>) در ابتدای عدد نسخه برای یک وابستگی در <code>package.json</code>، به این معنا است که هر نسخه‌ای که با عدد داده شده سازگار است می تواند نصب شود. بنابراین، به عنوان مثال، <bdo><code>&quot;^2.<wbr>3.<wbr>0&quot;</code></bdo> به این معنا است که هر نسخه‌ای بالاتر یا برابر با 2.3.0 و پایین تر از 3.0.0 قابل قبول است.</p>

<p><a class="p_ident" id="p_8BKIGbH5wc" href="#p_8BKIGbH5wc" tabindex="-1" role="presentation"></a>دستور <code>npm</code> همچنین برای انتشار بسته‌های جدید یا نسخه‌های جدید بسته‌ها استفاده می‌شود. اگر دستور <code>npm publish</code> را در یک پوشه‌ی حاوی فایل <code>package.json</code>  اجرا کنید، باعث می شود بسته‌ای با نام و شماره‌ نسخه‌ی موجود در فایل JSON در مخزن منتشر شود. هر کسی می‌تواند در NPM بسته منتشر کند البته که نام بسته نباید قبلا استفاده شده باشد.</p>

<p>با توجه به اینکه برنامه‌ی <code>npm</code> نرم‌افزاری است که با یک سیستم باز تعامل دارد - مخزن بسته‌ها - کاری که می‌کند منحصر به فرد نیست. برنامه‌ای دیگر که <code>yarn</code> نام دارد، نیز می‌تواند از طریق NPM نصب شود که کاری شبیه به ‍<code>npm</code> انجام می دهد ولی با دستورات و استراتژی متفاوت.</p>

<p><a class="p_ident" id="p_HN/3W2IVS2" href="#p_HN/3W2IVS2" tabindex="-1" role="presentation"></a>این کتاب به سراغ جزئیات بیشتر مربوط به NPM نمی‌رود. برای اطلاعات بیشتر و جستجوی بسته‌ها به <a href="https://npmjs.org"><em>https://npmjs.org</em></a> مراجعه کنید.</p>

<h2><a class="h_ident" id="h_joDR+2zBLl" href="#h_joDR+2zBLl" tabindex="-1" role="presentation"></a>ماژول سیستم فایل</h2>

<p><a class="p_ident" id="p_N9R+h06Z38" href="#p_N9R+h06Z38" tabindex="-1" role="presentation"></a>یکی از پراستفاده‌ترین ماژول‌های درونی در Node، ماژول <code>fs</code> می‌باشد، که سرنام <em>file system</em> است. این ماژول توابعی را برای کار با فایل‌ها و پوشه‌ها فراهم می‌سازد.</p>

<p><a class="p_ident" id="p_tNWze/ephs" href="#p_tNWze/ephs" tabindex="-1" role="presentation"></a>به عنوان مثال، تابع <code>readFile</code> فایلی را می‌خواند و سپس یک تابع callback را با محتوای فایل خوانده شده فراخوانی می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_JolDdwagNc" href="#c_JolDdwagNc" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> {<span class="cm-def">readFile</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>);
<span class="cm-variable">readFile</span>(<span class="cm-string">&quot;file.txt&quot;</span>, <span class="cm-string">&quot;utf8&quot;</span>, (<span class="cm-def">error</span>, <span class="cm-def">text</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span>) <span class="cm-keyword">throw</span> <span class="cm-variable-2">error</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;The file contains:&quot;</span>, <span class="cm-variable-2">text</span>);
});</pre>

<p><a class="p_ident" id="p_tE4qQCZNWF" href="#p_tE4qQCZNWF" tabindex="-1" role="presentation"></a>ورودی دوم تابع <code>readFile</code> مشخص کننده‌ی کدبندی کاراکتر (character encoding) است که برای رمزگشایی و تبدیل محتوای فایل به رشته استفاده می‌شود. راه‌های متعددی برای کدگذاری متون به داده‌های باینری وجود دارد، اما بیشتر سیستم‌های مدرن از UTF-8 استفاده می کنند. بنابراین اگر دلیلی برای استفاده از یک کدبندی دیگر ندارید، همان <code>&quot;utf8&quot;</code> را در هنگام خواندن یک فایل استفاده کنید. اگر کدبندی را به تابع ارسال نکنید، Node بنا را بر این می‌گذارد که شما به محتوای دودویی علاقمند هستید و یک شیء <code>Buffer</code> به جای رشته‌ی متنی برمی‌گرداند که شیئی آرایه‌گونه است و اعدادی دارد که نمایانگر بایت‌ها در فایل‌ها می‌باشند (قطعات 8 بیتی داده) .</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_D3dLtJ/8n6" href="#c_D3dLtJ/8n6" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">readFile</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>);
<span class="cm-variable">readFile</span>(<span class="cm-string">&quot;file.txt&quot;</span>, (<span class="cm-def">error</span>, <span class="cm-def">buffer</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span>) <span class="cm-keyword">throw</span> <span class="cm-variable-2">error</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;The file contained&quot;</span>, <span class="cm-variable-2">buffer</span>.<span class="cm-property">length</span>, <span class="cm-string">&quot;bytes.&quot;</span>,
              <span class="cm-string">&quot;The first byte is:&quot;</span>, <span class="cm-variable-2">buffer</span>[<span class="cm-number">0</span>]);
});</pre>

<p>تابعی مشابه به نام <code>writeFile</code> وجود دارد که برای نوشتن یک فایل روی دیسک استفاده می شود.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_lbylD3zyw8" href="#c_lbylD3zyw8" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">writeFile</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>);
<span class="cm-variable">writeFile</span>(<span class="cm-string">&quot;graffiti.txt&quot;</span>, <span class="cm-string">&quot;Node was here&quot;</span>, <span class="cm-def">err</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">err</span>) <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Failed to write file: ${</span><span class="cm-variable-2">err</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  <span class="cm-keyword">else</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;File written.&quot;</span>);
});</pre>

<p><a class="p_ident" id="p_6VXly4cVEf" href="#p_6VXly4cVEf" tabindex="-1" role="presentation"></a>در اینجا لازم نبود تا کدبندی مشخص شود-<code>writeFile</code> زمانی که به جای <code>Buffer‍</code>، یک رشته دریافت می کند، آن را به صورت رشته و با کدبندی پیش‌فرض که همان UTF-8 است، می نویسد.</p>

<p><a class="p_ident" id="p_8AvCp4tfZL" href="#p_8AvCp4tfZL" tabindex="-1" role="presentation"></a>ماژول <code>fs‍</code>، توابع مفید دیگری نیز دارد: <code>readdire</code> فایل‌های موجود در یک پوشه‌ را به صورت یک آرایه‌ی رشته‌ای برمی‌گرداند، <code>stat</code> اطلاعاتی در درباره‌ی یک فایل برمی‌گرداند، <code>rename</code> نام یک فایل را تغییر می‌دهد، <code>unlink</code> فایلی را حذف می کند و الی آخر. می توانید مستندات آن را در <a href="https://nodejs.org"><em>https://nodejs.org</em></a> مشاهده کنید.</p>

<p><a class="p_ident" id="p_JOwUeHI78r" href="#p_JOwUeHI78r" tabindex="-1" role="presentation"></a>بیشتر این توابع یک تابع callback به عنوان آخرین ورودی دریافت می کنند، که یا با یک error (آرگومان اول) یا با یک نتیجه‌ی موفق (آرگومان دوم) آن‌ را فراخوانی‌ می کنند.  همانطور که در <a href="11_async.html">فصل 11</a> دیدیم، این سبک از برنامه‌نویسی ایراداتی دارد که بزرگترین آن مدیریت خطاها‌ است که شلوغ و دردسرساز می شود.</p>

<p><a class="p_ident" id="p_rUFC0C59kY" href="#p_rUFC0C59kY" tabindex="-1" role="presentation"></a>اگرچه promise ها مدتی است که بخشی از جاوااسکریپت هستند، اما در زمان نوشتن این کتاب، پیاده‌سازی آن‌ها هنوز در جریان است. شیئی به نام <code>promises</code>  توسط بسته‌ی <code>fs</code> از نسخه‌ی 10.1 صادر می‌شود که همان توابع موجود در <code>fs</code> را دارد با این تفاوت که از promiseها به جای توابع callback استفاده می کنند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_wosbb7EfU3" href="#c_wosbb7EfU3" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">readFile</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>).<span class="cm-property">promises</span>;
<span class="cm-variable">readFile</span>(<span class="cm-string">&quot;file.txt&quot;</span>, <span class="cm-string">&quot;utf8&quot;</span>)
  .<span class="cm-property">then</span>(<span class="cm-def">text</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;The file contains:&quot;</span>, <span class="cm-variable-2">text</span>));</pre>

<p>گاهی نیازی به ناهمگامی ندارید و فقط با توجه به پیش‌فرض بودن آن‌ها مورد استفاده قرار می‌گیرند . خیلی از توابع موجود در <code>fs</code> یک نسخه‌ی همگام نیز دارند که نامشان یکسان است با این تفاوت که <code>Sync</code> به انتهایشان اضافه شده است. به عنوان مثال، نسخه‌ی همگام <code>readFile</code> به صورت <code>readFileSync</code> در دسترس است.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_odA0N1psD0" href="#c_odA0N1psD0" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">readFileSync</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;The file contains:&quot;</span>,
            <span class="cm-variable">readFileSync</span>(<span class="cm-string">&quot;file.txt&quot;</span>, <span class="cm-string">&quot;utf8&quot;</span>));</pre>

<p>حواستان باشد که وقتی یک عمل همگام در حال اجرا است، برنامه‌ی شما در آن لحظه متوقف است. اگر قرار است به یک  کاربر یا ماشین‌های دیگر در شبکه پاسخ بدهید، توقف روی یک عمل همگام ممکن است تاخیر در پاسخگویی برنامه به وجود بیاورد.</p>

<h2><a class="h_ident" id="h_1OHL1zNa+q" href="#h_1OHL1zNa+q" tabindex="-1" role="presentation"></a>ماژول HTTP</h2>

<p><a class="p_ident" id="p_byYn9eS4lD" href="#p_byYn9eS4lD" tabindex="-1" role="presentation"></a>یکی دیگر از ماژول‌های اصلی <code>http</code> است. این ماژول امکاناتی برای اجرای سرویس‌دهنده‌های HTTP و ساختن درخواست‌های HTTP فراهم می کند.</p>

<p><a class="p_ident" id="p_9Asn1ri5pP" href="#p_9Asn1ri5pP" tabindex="-1" role="presentation"></a>تمام آنچه برای راه‌اندازی یک سرویس‌دهنده‌ی HTTP لازم است:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_87+jSJqVtw" href="#c_87+jSJqVtw" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">createServer</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;http&quot;</span>);
<span class="cm-keyword">let</span> <span class="cm-def">server</span> <span class="cm-operator">=</span> <span class="cm-variable">createServer</span>((<span class="cm-def">request</span>, <span class="cm-def">response</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable-2">response</span>.<span class="cm-property">writeHead</span>(<span class="cm-number">200</span>, {<span class="cm-string cm-property">&quot;Content-Type&quot;</span>: <span class="cm-string">&quot;text/html&quot;</span>});
  <span class="cm-variable-2">response</span>.<span class="cm-property">write</span>(<span class="cm-string-2">`</span>
    <span class="cm-string-2">&lt;h1&gt;Hello!&lt;/h1&gt;</span>
    <span class="cm-string-2">&lt;p&gt;You asked for &lt;code&gt;${</span><span class="cm-variable-2">request</span>.<span class="cm-property">url</span><span class="cm-string-2">}</span><span class="cm-string-2">&lt;/code&gt;&lt;/p&gt;`</span>);
  <span class="cm-variable-2">response</span>.<span class="cm-property">end</span>();
});
<span class="cm-variable">server</span>.<span class="cm-property">listen</span>(<span class="cm-number">8000</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Listening! (port 8000)&quot;</span>);</pre>

<p><a class="p_ident" id="p_5GB3R171iI" href="#p_5GB3R171iI" tabindex="-1" role="presentation"></a>اگر این اسکریپت را در کامپیوتر خودتان اجرا کنید، می‌توانید در مروگر آدرس  <a href="http://localhost:8000/hello"><em>http://localhost:8000/hello</em></a> را باز کنید تا یک درخواست به سرویس‌دهنده‌تان ارسال کنید. پاسخ سرویس‌دهنده یک صفحه‌ی ساده‌ی HTML خواهد بود.</p>

<p><a class="p_ident" id="p_Di2bB3ekhc" href="#p_Di2bB3ekhc" tabindex="-1" role="presentation"></a>تابعی که به عنوان آرگومان به <code>createServer</code> داده‌ می‌شود هر بار که کلاینت (سرویس‌گیرنده) به سرویس‌دهنده متصل می شود، فراخوانی می شود. دو متغیر <code>request</code> و <code>response</code> اشیائی هستند که نمایانگر داده‌های ورودی و برگشتی می‌باشند. شیء اول دربردارنده‌ی اطلاعاتی درباره‌ی درخواست است مانند <code>url</code> درخواست، که مشخص می‌کند درخواست به کدام URL ارسال شده است.</p>

<p>بنابراین، وقتی شما آن صفحه را در مرورگرتان باز می کنید، مرورگر درخواستی به کامپیوتر خودتان ارسال می کند. این کار باعث می‌شود که تابع سرویس‌دهنده اجرا شود و پاسخی برگرداند، که می توانید آن را در مرورگر ببینید.</p>

<p><a class="p_ident" id="p_xqt9vCfbnY" href="#p_xqt9vCfbnY" tabindex="-1" role="presentation"></a>برای اینکه چیزی برگردانید، متدهایی روی شیء <code>response</code> فراخوانی می کنید. اولین متد، متد <code>writeHead</code> است که سرنام‌های پاسخ یا headers را می‌نویسد، به <a href="18_http.html#headers">فصل 18</a> مراجعه کنید. به این متد یک کد وضعیت (مثل 200 یا “OK” در این مورد) و یک شیء حاوی مقادیر سرنام‌ها داده می‌شود. در مثال، سرنام <code>Content-Type</code> تنظیم می‌شود تا کلاینت باخبر شود که ما قرار است یک سند HTML برگردانیم.</p>

<p>سپس، بدنه‌ی اصلی پاسخ (که محتوای سند است) به وسیله‌ی <code>response.write</code> ارسال می‌شود. می توانید این متد را چندین بار فراخوانی کنید اگر دوست دارید تا پاسخ را بخش بخش ارسال کنید، مثلا استریم کردن داده ها به کلاینت همزمان با آماده شدن آن‌ها. در آخر، <code>response.end</code> پایان پاسخ را مشخص می کند.</p>

<p><a class="p_ident" id="p_33+86TuT2S" href="#p_33+86TuT2S" tabindex="-1" role="presentation"></a>فراخوانی <code>server.listen</code> باعث می‌شود که سرویس‌دهنده منتظر ارتباطات روی پورت 8000 بماند. به همین علت است که شما باید به <em>localhost:8000</em> متصل شوید تا بتوانید با سرویس‌دهنده تعامل کنید زیرا <em>localhost</em> به صورت پیش‌فرض از پورت 80 استفاده می کند.</p>

<p><a class="p_ident" id="p_fJLbKyMZ+H" href="#p_fJLbKyMZ+H" tabindex="-1" role="presentation"></a>هنگامی که این اسکریپت را اجرا می کنید، پروسه‌ی مورد نظر اجرا و منتظر درخواست‌ها می ماند. زمانی که یک اسکریپت منتظر رخداد‌ها می‌باشد-در این مثال، ارتباطات شبکه- <code>node</code> به صورت خودکار پس از رسیدن به پایان اسکریپت متوقف نمی‌شود. برای متوقف کردن آن باید کلید‌های <span class="keyname">control</span>-C را فشار دهید.</p>

<p>یک سرویس‌دهنده‌ی وب واقعی معمولا کارهای بیشتری از آنچه در مثال نشان‌داده شد انجام می دهد- به متد درخواست توجه می کند (خاصیت <code>method</code>) تا متوجه منظور کلاینت از ارسال درخواست بشود و  به URL درخواست نگاه می کند تا منبع مورد نظر این درخواست برای اعمال را بداند. <a href="20_node.html#file_server">در ادامه‌ی این فصل</a>، یک سرویس‌دهنده‌ی پیش‌رفته‌تر را مشاهده خواهیم کرد.</p>

<p>برای اینکه مانند یک کلاینت HTTP عمل کنیم، می توانیم از تابع <code>request</code> ماژول <code>http</code> استفاده کنیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_qPo2Gq+u4e" href="#c_qPo2Gq+u4e" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">request</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;http&quot;</span>);
<span class="cm-keyword">let</span> <span class="cm-def">requestStream</span> <span class="cm-operator">=</span> <span class="cm-variable">request</span>({
  <span class="cm-property">hostname</span>: <span class="cm-string">&quot;eloquentjavascript.net&quot;</span>,
  <span class="cm-property">path</span>: <span class="cm-string">&quot;/20_node.html&quot;</span>,
  <span class="cm-property">method</span>: <span class="cm-string">&quot;GET&quot;</span>,
  <span class="cm-property">headers</span>: {<span class="cm-property">Accept</span>: <span class="cm-string">&quot;text/html&quot;</span>}
}, <span class="cm-def">response</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Server responded with status code&quot;</span>,
              <span class="cm-variable-2">response</span>.<span class="cm-property">statusCode</span>);
});
<span class="cm-variable">requestStream</span>.<span class="cm-property">end</span>();</pre>

<p>آرگومان اول <code>request</code>، درخواست را تنظیم می کند، مشخص می کند به کدام سرویس‌دهنده باید تماس حاصل شود، چه مسیری از آن سرویس‌دهنده مورد درخواست قرار بگیرد، چه متدی استفاده شود و از این قبیل. آرگومان دوم تابعی است که زمانی باید فراخوانی شود که پاسخ از راه می‌رسد. به این تابع  شیئ داده‌ می‌شود که به ما امکان بررسی محتوای پاسخ را می‌دهد، مثلا دریافت کد وضعیت.</p>

<p><a class="p_ident" id="p_CI4psKsAeV" href="#p_CI4psKsAeV" tabindex="-1" role="presentation"></a>درست شبیه به <code>response</code> که پیش‌تر در سرویس‌دهنده‌ دیدیم، شیئی که توسط <code>request</code> برگردانده‌ می‌شود به ما این امکان را می‌دهد تا داده‌ها را به وسیله‌ی متد <code>write</code> درون request استریم کنیم و به وسیله‌ی متد <code>end</code> آن، آن را به پایان برسانیم.  در مثال، از متد <code>write</code> استفاده نشده است زیرا درخواست‌های نوع <code>GET</code> نباید داده‌ای در بدنه‌ی درخواست داشته باشند.</p>

<p>در ماژول <code>https</code> تابع مشابهی به نام <code>request</code> وجود دارد که می‌تواند برای درخواست‌هایی که به URL‌های <code>https:</code> می باشند استفاده شود.</p>

<p><a class="p_ident" id="p_rmk7pvRi3L" href="#p_rmk7pvRi3L" tabindex="-1" role="presentation"></a>ساخت درخواست‌ها به وسیله‌ی امکانات خام Node، نسبتا زیادنویسی است. در NPM بسته‌های پوششی بسیار ساده‌تر برای این کار وجود دارد. به عنوان مثال، بسته‌ی <code>node-fetch</code> رابط <code>fetch</code> را به صورت مبتنی بر promise ها فراهم می‌سازد که ما با آن در موضوع مرورگرها آشنا شدیم.</p>

<h2><a class="h_ident" id="h_msGaN6dg75" href="#h_msGaN6dg75" tabindex="-1" role="presentation"></a>استریم یا جریان</h2>

<p>دو نمونه از استریم‌های قابل نوشتن را در مثال‌های HTTP مشاهده کرده ایم: شیء پاسخ که سرویس‌دهنده می توانست در آن بنویسد و شیء درخواستی که از <code>request</code> برگردانده می‌شد.</p>

<p><a class="p_ident" id="p_CDAkrmNW6K" href="#p_CDAkrmNW6K" tabindex="-1" role="presentation"></a>استریم‌های قابل نوشتن (<em>Writable streams</em>) مفهومی پراستفاده در Node می‌باشند. این‌گونه اشیاء متدی به نام <code>write</code> دارند که یک رشته یا یک <code>Buffer</code> برای نوشتن چیزی در استریم دریافت می کند. متد <code>end‍</code> ‌آن‌ها، باعث می‌شود که استریم بسته شود و می‌توان به صورت اختیاری مقداری را به آن داد که قبل از بستن استریم آن را در آن بنویسید. هر دوی این متد‌ها همچنین یک تابع callback به عنوان آرگومان اضافی قبول می‌کنند که آن را هنگامی که عمل نوشتن یا بستن پایان پذیرفت، فراخوانی می کنند.</p>

<p>همچنین این امکان وجود دارد که به وسیله‌ی تابع <code>createWriteStream</code> ماژول <code>fs</code> یک استریم قابل نوشتن ایجاد کرد که به یک فایل اشاره می کند. سپس می‌توانید از متد <code>write</code> موجود در شیء حاصل استفاده کنید تا فایل را به‌جای نوشتن در یک حرکت با <code>writeFile</code>، به صورت گام به گام بنویسید.</p>

<p><a class="p_ident" id="p_yburwy0Xo0" href="#p_yburwy0Xo0" tabindex="-1" role="presentation"></a>استریم‌های قابل‌خواندن اندکی پیچیده‌تر هستند. هر دوی متغیرهای <code>request</code> و ‍<code>response</code> که به callback مربوط به کلاینت HTTP داده می‌شوند، استریم‌های قابل‌خواندن هستند- یک سرویس‌دهنده درخواست‌ها را می‌خواند و سپس  پاسخ‌ها را می‌نویسد، درحالی‌که که کلاینت ابتدا یک درخواست می‌نویسد و سپس یک پاسخ را می‌خواند. خواندن از یک استریم به وسیله‌ی استفاده از گرداننده‌های رخداد صورت می‌گیرد نه متد‌ها.</p>

<p>در Node، اشیائی که رخداد‌ها را تولید‌ می‌کنند متدی به نام <code>on</code> دارند که شبیه به متد <code>addEventListener</code> موجود در مرورگر است. نام رخداد و یک تابع به آن می‌دهید، و این متد تابع دریافتی را ثبت کرده و هنگامی که رخداد داده شده اتفاق افتاد، آن را فراخوانی می‌کند.</p>

<p><a class="p_ident" id="p_OjEPbsch5r" href="#p_OjEPbsch5r" tabindex="-1" role="presentation"></a>استریم‌های قابل خواندن دارای رخداد‌های <code>&quot;data&quot;</code> و <code>&quot;end&quot;</code> می‌باشند. اولین رخداد با هربار ورود داده ایجاد می‌شود، و دومین هنگامی که استریم به پایان می‌رسد فراخوانی می‌شود. این مدل بسیار مناسب داده‌های جریان‌داری (streaming) که می‌توانند بلافاصله پردازش شوند می‌باشد، حتی هنگامی که کل سند هنوز در دسترس نیست. یک فایل را می‌توان با استفاده از تابع <code>createReadStream</code> ماژول <code>fs</code>  به صورت یک استریم قابل‌خواندن خواند.</p>

<p>کد زیر یک سرویس‌دهنده ایجاد می‌کند که بدنه‌های درخواست را می‌خواند و آن‌ها را به کلاینت به صورت حروف بزرگ استریم می ‌کند:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_vUewhc4MbF" href="#c_vUewhc4MbF" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">createServer</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;http&quot;</span>);
<span class="cm-variable">createServer</span>((<span class="cm-def">request</span>, <span class="cm-def">response</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable-2">response</span>.<span class="cm-property">writeHead</span>(<span class="cm-number">200</span>, {<span class="cm-string cm-property">&quot;Content-Type&quot;</span>: <span class="cm-string">&quot;text/plain&quot;</span>});
  <span class="cm-variable-2">request</span>.<span class="cm-property">on</span>(<span class="cm-string">&quot;data&quot;</span>, <span class="cm-def">chunk</span> <span class="cm-operator">=&gt;</span>
    <span class="cm-variable-2">response</span>.<span class="cm-property">write</span>(<span class="cm-variable-2">chunk</span>.<span class="cm-property">toString</span>().<span class="cm-property">toUpperCase</span>()));
  <span class="cm-variable-2">request</span>.<span class="cm-property">on</span>(<span class="cm-string">&quot;end&quot;</span>, () <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">response</span>.<span class="cm-property">end</span>());
}).<span class="cm-property">listen</span>(<span class="cm-number">8000</span>);</pre>

<p><a class="p_ident" id="p_Bc5vOoRajT" href="#p_Bc5vOoRajT" tabindex="-1" role="presentation"></a>مقدار <code>chunk</code> که به گرداننده‌ی data ارسال‌ می‌شود یک ‍‍<code>Buffer</code> دودویی خواهد بود. می‌توانیم این را با کدگشایی آن به عنوان کاراکتر‌های کدگذاری شده با UTF-8 به وسیله‌ی متد <code>toString</code> به یک رشته تبدیل کنیم.</p>

<p>کد زیر، زمانی که با سرویس‌دهنده بزرگ کننده‌ی حروف اجرا شود، درخواستی به آن سرویس‌دهنده ارسال می کند و پاسخی را که دریافت می‌کند در خروجی می‌نویسد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_tqlbzAFLXQ" href="#c_tqlbzAFLXQ" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">request</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;http&quot;</span>);
<span class="cm-variable">request</span>({
  <span class="cm-property">hostname</span>: <span class="cm-string">&quot;localhost&quot;</span>,
  <span class="cm-property">port</span>: <span class="cm-number">8000</span>,
  <span class="cm-property">method</span>: <span class="cm-string">&quot;POST&quot;</span>
}, <span class="cm-def">response</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable-2">response</span>.<span class="cm-property">on</span>(<span class="cm-string">&quot;data&quot;</span>, <span class="cm-def">chunk</span> <span class="cm-operator">=&gt;</span>
    <span class="cm-variable">process</span>.<span class="cm-property">stdout</span>.<span class="cm-property">write</span>(<span class="cm-variable-2">chunk</span>.<span class="cm-property">toString</span>()));
}).<span class="cm-property">end</span>(<span class="cm-string">&quot;Hello server&quot;</span>);
<span class="cm-comment">// → HELLO SERVER</span></pre>

<p><a class="p_ident" id="p_wuLWYhM03I" href="#p_wuLWYhM03I" tabindex="-1" role="presentation"></a>در مثال عمل نوشتن در <code>process.stdout</code> (خروجی استاندارد process، که یک استریم قابل نوشتن است) صورت گرفته است؛ نه <code>console.log</code>. نمی‌توانیم از <code>console.log</code> استفاده کنیم زیرا این متد یک کاراکتر خط جدید بعد از هر بخش از متنی که می‌نویسد اضافه می‌کند، که مناسب اینجا نیست زیرا پاسخ ممکن است به صورت چند تکه دریافت شود.</p>

<h2 id="file_server"><a class="h_ident" id="h_hpdktTwpqr" href="#h_hpdktTwpqr" tabindex="-1" role="presentation"></a>یک سرویس‌دهنده‌ی فایل</h2>

<p>بیایید دانش جدیدمان در مورد سرویس‌دهنده‌های HTTP و کار کردن با سیستم فایل را ترکیب کنیم تا پلی بین این دو بسازیم: یک سرویس‌دهنده‌ی HTTP که اجازه‌ی دسترسی به سیستم فایل از راه دور را فراهم می‌سازد. این سرویس‌دهنده‌ کاربرد‌های زیاد و متنوعی دارد-به اپلیکیشن‌های وب امکان ذخیره و به اشتراک‌گذاری داده‌ها را می‌دهد، یا می‌تواند به گروهی از کاربران دسترسی مشترک به تعدادی فایل را بدهد.</p>

<p>زمانی که فایل‌ها را به عنوان منبع‌های HTTP در نظر می‌گیریم، متد‌های <code>GET</code>، <code>PUT</code>، و <code>DELETE</code> در HTTP را می‌توان برای خواندن، نوشتن و حذف فایل‌ها به کار برد. ما بخش مسیر در درخواست را به عنوان مسیر فایل مورد درخواست تفسیر خواهیم کرد.</p>

<p>احتمالا قصد نداریم کل سیستم فایلمان را به اشتراک بگذاریم، پس این مسیر‌ها را به عنوان شروع در پوشه‌ی کاری  سرویس‌دهنده که همان پوشه‌ای است که در آن اجرا شده است، تفسیر می‌کنیم.  اگر من سرویس‌دهنده را از <code>/tmp/public/</code> (یا <bdo><code>C:\tmp\public\</code></bdo> در ویندوز) اجرا کنم، سپس درخواستی برای فایل <bdo><code>/file.txt</code></bdo>ارسال کنم، باید به <bdo><code>/<wbr>tmp/<wbr>public/<wbr>file.<wbr>txt</code></bdo> (یا <bdo><code>C:\tmp\public\file.<wbr>txt</code></bdo>) اشاره شود.</p>

<p><a class="p_ident" id="p_SoLS1byDyt" href="#p_SoLS1byDyt" tabindex="-1" role="presentation"></a>برنامه‌ را قطعه به قطعه خواهیم نوشت، و از شیئی به نام <code>methods</code> برای ذخیره توابعی که متد‌های متنوع HTTP را مدیریت می‌کنند، استفاده خواهیم کرد.  گرداننده‌های ما از نوع توابع <code>async</code> می‌باشند که شیء درخواست را به عنوان ورودی دریافت می کنند و یک promise برمی‌گردانند که  منجر به یک شیء می‌شود که آن شیء توصیف کننده پاسخ می‌باشد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_W/1zaB21gr" href="#c_W/1zaB21gr" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">createServer</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;http&quot;</span>);

<span class="cm-keyword">const</span> <span class="cm-def">methods</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);

<span class="cm-variable">createServer</span>((<span class="cm-def">request</span>, <span class="cm-def">response</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">let</span> <span class="cm-def">handler</span> <span class="cm-operator">=</span> <span class="cm-variable">methods</span>[<span class="cm-variable-2">request</span>.<span class="cm-property">method</span>] <span class="cm-operator">|</span><span class="cm-operator">|</span> <span class="cm-variable">notAllowed</span>;
  <span class="cm-variable-2">handler</span>(<span class="cm-variable-2">request</span>)
    .<span class="cm-property">catch</span>(<span class="cm-def">error</span> <span class="cm-operator">=&gt;</span> {
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span>.<span class="cm-property">status</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">error</span>;
      <span class="cm-keyword">return</span> {<span class="cm-property">body</span>: <span class="cm-variable">String</span>(<span class="cm-variable-2">error</span>), <span class="cm-property">status</span>: <span class="cm-number">500</span>};
    })
    .<span class="cm-property">then</span>(({<span class="cm-property">body</span>, <span class="cm-property">status</span> <span class="cm-operator">=</span> <span class="cm-number">200</span>, <span class="cm-variable">type</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;text/plain&quot;</span>}) <span class="cm-operator">=&gt;</span> {
       <span class="cm-variable-2">response</span>.<span class="cm-property">writeHead</span>(<span class="cm-variable">status</span>, {<span class="cm-string cm-property">&quot;Content-Type&quot;</span>: <span class="cm-variable">type</span>});
       <span class="cm-keyword">if</span> (<span class="cm-variable">body</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span> <span class="cm-variable">body</span>.<span class="cm-property">pipe</span>) <span class="cm-variable">body</span>.<span class="cm-property">pipe</span>(<span class="cm-variable-2">response</span>);
       <span class="cm-keyword">else</span> <span class="cm-variable-2">response</span>.<span class="cm-property">end</span>(<span class="cm-variable">body</span>);
    });
}).<span class="cm-property">listen</span>(<span class="cm-number">8000</span>);

<span class="cm-keyword">async</span> <span class="cm-keyword">function</span> <span class="cm-def">notAllowed</span>(<span class="cm-def">request</span>) {
  <span class="cm-keyword">return</span> {
    <span class="cm-property">status</span>: <span class="cm-number">405</span>,
    <span class="cm-property">body</span>: <span class="cm-string-2">`Method ${</span><span class="cm-variable-2">request</span>.<span class="cm-property">method</span><span class="cm-string-2">}</span> <span class="cm-string-2">not allowed.`</span>
  };
}</pre>

<p><a class="p_ident" id="p_fuUdlYLvPT" href="#p_fuUdlYLvPT" tabindex="-1" role="presentation"></a>این کد یک سرویس‌دهنده اجرا می‌کند که پاسخ‌های خطای 405 برمی‌گرداند، که این شماره در صورت عدم پذیرش متد داده شده توسط سرویس‌دهنده استفاده می‌شود.</p>

<p><a class="p_ident" id="p_jC/YRC/GWd" href="#p_jC/YRC/GWd" tabindex="-1" role="presentation"></a>زمانی که یک promise گرداننده‌ی درخواست لغو یا رد می‌شود، فراخوانی <code>catch</code>، خطای موجود را به یک شیء پاسخ تبدیل می‌کند، البته اگر خود به آن صورت نبود، بنابراین سرویس‌دهنده می‌تواند پاسخ خطا را بازگرداند و کلاینت را از ناموفق بودن درخواستش باخبر کند.</p>

<p><a class="p_ident" id="p_gaWM+ev5/h" href="#p_gaWM+ev5/h" tabindex="-1" role="presentation"></a>فیلد <code>status</code> در پاسخ ممکن است از قلم بیفتد، که در این صورت معادل <bdo>200 (OK)</bdo> در نظر گرفته می‌شود. نوع محتوا (content type)، در خاصیت <code>type</code> را نیز می‌توان از قلم انداخت که در این صورت پاسخ به صورت رشته‌ی معمولی در نظر گرفته می‌شود.</p>

<p>هنگامی که مقدار <code>body</code> یک استریم قابل خواندن است، یک متد ‍‍<code>pipe</code> خواهد داشت که برای انتقال همه‌ی محتوا از یک استریم قابل خواندن به یک استریم قابل نوشتن استفاده می‌شود. اگر اینچنین نبود، فرض می‌شود که یا <code>null</code> (بدون بدنه)، یا رشته، یا بافر باشد  و مستقیما به متد <code>end</code> پاسخ  داده می‌شود.</p>

<p><a class="p_ident" id="p_Y/9kqYIGKg" href="#p_Y/9kqYIGKg" tabindex="-1" role="presentation"></a>برای اینکه مشخص کنیم کدام مسیر فایل به یک URL درخواست متناظر می‌شود، تابع <code>urlPath</code> از ماژول درونی <code>url</code> در Node بهره می‌برد تا URL را تجزیه کند. این تابع نام مسیررا که چیزی مثل <bdo><code>&quot;/<wbr>file.<wbr>txt&quot;</code></bdo> می‌باشد می‌گیرد، آن را کدگشایی می‌کند تا <code>%20</code> یا کد‌های گریز را حذف کند، و آن را نسبت به پوشه‌ی فعال برنامه‌ نتیجه‌یابی کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_vgzzr4jj34" href="#c_vgzzr4jj34" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">parse</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;url&quot;</span>);
<span class="cm-keyword">const</span> {<span class="cm-def">resolve</span>, <span class="cm-def">sep</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;path&quot;</span>);

<span class="cm-keyword">const</span> <span class="cm-def">baseDirectory</span> <span class="cm-operator">=</span> <span class="cm-variable">process</span>.<span class="cm-property">cwd</span>();

<span class="cm-keyword">function</span> <span class="cm-def">urlPath</span>(<span class="cm-def">url</span>) {
  <span class="cm-keyword">let</span> {<span class="cm-def">pathname</span>} <span class="cm-operator">=</span> <span class="cm-variable">parse</span>(<span class="cm-variable-2">url</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">path</span> <span class="cm-operator">=</span> <span class="cm-variable">resolve</span>(<span class="cm-variable">decodeURIComponent</span>(<span class="cm-variable-2">pathname</span>).<span class="cm-property">slice</span>(<span class="cm-number">1</span>));
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">path</span> <span class="cm-operator">!=</span> <span class="cm-variable">baseDirectory</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span>
      <span class="cm-operator">!</span><span class="cm-variable-2">path</span>.<span class="cm-property">startsWith</span>(<span class="cm-variable">baseDirectory</span> <span class="cm-operator">+</span> <span class="cm-variable">sep</span>)) {
    <span class="cm-keyword">throw</span> {<span class="cm-property">status</span>: <span class="cm-number">403</span>, <span class="cm-property">body</span>: <span class="cm-string">&quot;Forbidden&quot;</span>};
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">path</span>;
}</pre>

<p>به محض اینکه برنامه‌ای را تنظیم کردید تا درخواست‌های شبکه را قبول کند، نگرانی در مورد امنیت نیز شروع می‌شود. در مورد ما، اگر دقت کافی نکنیم، احتمال دارد به صورت اتفاقی کل سیستم فایل‌مان را در معرض دید شبکه قرار دهیم.</p>

<p>مسیر‌ فایل‌ها در Node از جنس رشته می‌باشند. برای نگاشت این‌گونه رشته‌ها به فایل‌های واقعی، تجزیه‌ و تفسیر‌های مهمی در جریان است. مسیر‌ها ممکن است، به عنوان مثال، حاوی <bdo><code>../</code></bdo> برای اشاره به پوشه‌ی والدشان باشند. بنابراین یکی از مشکل‌های روشن از درخواست‌هایی برای مسیری مانند <bdo><code>/../secret_file</code></bdo> ریشه می‌گیرد.</p>

<p><a class="p_ident" id="p_cyHHBL1Muz" href="#p_cyHHBL1Muz" tabindex="-1" role="presentation"></a>برای پیشگیری از این گونه مشکلات، <code>urlPath</code> از تابع <code>resolve</code> متعلق به ماژول <code>path</code> بهره می‌برد، که مسیر‌های نسبی را واکاوی می‌کند. سپس تحقیق می‌کند که مسیر حاصل زیرمجموعه‌ی پوشه‌ی کاری برنامه باشد. تابع <code>process.cwd</code> (که <code>cwd</code> سرنام “current working directory” یا پوشه‌ی فعلی کاری می‌باشد) را می‌توان برای پیدا کردن پوشه‌ی کاری استفاده کرد. متغیر <code>sep</code> از بسته‌ی <code>path</code>، جداساز مسیر سیستم است- یک بک‌اسلش در ویندوز و اسلش در بیشتر دیگر سیستم‌ ها. زمانی که یک مسیر با پوشه‌ی پایه شروعی نمی‌شود، این تابع یک پاسخ خطا رها می‌کند، که به وسیله‌ی کد وضعیت HTTP مشخص می‌شود که دسترسی به این منبع ممنوع می‌باشد.</p>

<p>ما متد <code>GET</code> را برای دریافت لیستی از فایل‌ها در هنگام خواندن یک پوشه و نمایش محتوای فایل در صورت خواندن یک فایل، تنظیم می کنیم.</p>

<p><a class="p_ident" id="p_xA5Nn3Yifx" href="#p_xA5Nn3Yifx" tabindex="-1" role="presentation"></a>یک سوال مهم این است که چه نوع سرنام <code>Content-Type</code>ای باید در زمان بازگرداندن محتوای یک فایل  انتخاب کنیم. با توجه به اینکه فایل‌های درخواستی می توانند از هر نوعی باشند، سرویس‌دهنده‌ی ما نمی‌تواند به سادگی فقط یک content type برای همه‌ی فایل ها در نظر بگیرد. دوباره NPM می تواند به ما کمک کند. بسته‌ی <code>mime</code> (نشان‌های نوع محتوا مانند <code>text/plain</code> که MIME types یا انواع MIME نیز خوانده می‌شوند.) نوع صحیح محتوا را برای تعداد زیادی از پسوند‌های فایل می‌داند.</p>

<p>دستور <code>npm</code> پیش‌رو، اگر در پوشه‌ای که اسکریپت سرویس‌دهنده قرار دارد اجرا شود، نسخه‌ی مشخص شده از <code>mime</code> را نصب می‌کند.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_nzfHTZ/5TP" href="#c_nzfHTZ/5TP" tabindex="-1" role="presentation"></a>$ npm install mime@2.2.0</pre>

<p><a class="p_ident" id="p_w1qfxSu1Vs" href="#p_w1qfxSu1Vs" tabindex="-1" role="presentation"></a>زمانی که فایلی درخواست می‌شود که وجود ندارد، کد وضعیت صحیحی که باید برگردانده شود کد 404 است. از تابع <code>stat</code> استفاده خواهیم کرد که به جستجوی اطلاعات در مورد فایل داده شده می‌پردازد و دو چیز را مشخص می‌کند: آیا فایل موجود است و اینکه آیا نتیجه پوشه است یا فایل.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_bUezN7Otmf" href="#c_bUezN7Otmf" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">createReadStream</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>);
<span class="cm-keyword">const</span> {<span class="cm-def">stat</span>, <span class="cm-def">readdir</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>).<span class="cm-property">promises</span>;
<span class="cm-keyword">const</span> <span class="cm-def">mime</span> <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;mime&quot;</span>);

<span class="cm-variable">methods</span>.<span class="cm-property">GET</span> <span class="cm-operator">=</span> <span class="cm-keyword">async</span> <span class="cm-keyword">function</span>(<span class="cm-def">request</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">path</span> <span class="cm-operator">=</span> <span class="cm-variable">urlPath</span>(<span class="cm-variable-2">request</span>.<span class="cm-property">url</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">stats</span>;
  <span class="cm-keyword">try</span> {
    <span class="cm-variable-2">stats</span> <span class="cm-operator">=</span> <span class="cm-keyword">await</span> <span class="cm-variable">stat</span>(<span class="cm-variable-2">path</span>);
  } <span class="cm-keyword">catch</span> (<span class="cm-def">error</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span>.<span class="cm-property">code</span> <span class="cm-operator">!=</span> <span class="cm-string">&quot;ENOENT&quot;</span>) <span class="cm-keyword">throw</span> <span class="cm-variable-2">error</span>;
    <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> {<span class="cm-property">status</span>: <span class="cm-number">404</span>, <span class="cm-property">body</span>: <span class="cm-string">&quot;File not found&quot;</span>};
  }
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">stats</span>.<span class="cm-property">isDirectory</span>()) {
    <span class="cm-keyword">return</span> {<span class="cm-property">body</span>: (<span class="cm-keyword">await</span> <span class="cm-variable">readdir</span>(<span class="cm-variable-2">path</span>)).<span class="cm-property">join</span>(<span class="cm-string">&quot;\n&quot;</span>)};
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">return</span> {<span class="cm-property">body</span>: <span class="cm-variable">createReadStream</span>(<span class="cm-variable-2">path</span>),
            <span class="cm-property">type</span>: <span class="cm-variable">mime</span>.<span class="cm-property">getType</span>(<span class="cm-variable-2">path</span>)};
  }
};</pre>

<p><a class="p_ident" id="p_KwmlL/1eTc" href="#p_KwmlL/1eTc" tabindex="-1" role="presentation"></a>به دلیل اینکه این تابع باید به سراغ دیسک برود پس ممکن است کمی زمان ببرد، ‍‍ <code>stat</code> ناهمگام است. با توجه به اینکه ما از سبک promiseها به جای callback استفاده می کنیم، باید آن را از  <code>promises</code> وارد (import) نمود نه از ماژول <code>fs</code>;</p>

<p><a class="p_ident" id="p_/2O6RSqdM8" href="#p_/2O6RSqdM8" tabindex="-1" role="presentation"></a>هنگامی که فایل مورد نظر وجود ندارد، <code>stat</code> شیء خطایی رها می‌کند که حاوی خاصیتی به نام <code>code</code> و مقدار <code>&quot;ENOENT&quot;</code> می‌باشد. این مقدار کمی ناآشنا به نظر می‌رسد، کدهای خطا در Node از Unix الهام گرفته شده اند.</p>

<p>شیء <code>stats</code>ای که توسط تابع <code>stat</code> برگردانده‌ می‌شود اطلاعاتی مانند اندازه فایل (خاصیت <code>size</code>) و تاریخ تغییر آن (<code>mtime</code>) را در اختیار ما می‌گذارد.  در اینجا ما می‌خواهیم بدانیم که درخواست ما فایل معمولی بوده است یا یک پوشه، که متد <code>isDirectory</code> این موضوع را مشخص می‌کند.</p>

<p>از متد <code>readdir</code> برای خواندن مجموعه‌ای از فایل‌های یک پوشه و بازگرداندن آن به کلاینت استفاده می‌کنیم. برای فایل‌های عادی، یک استریم قابل خواندن به وسیله‌ی <code>createReadStream</code> ایجاد کرده و آن را به عنوان بدنه به همراه نوع محتوایی که بسته‌ی <code>mime</code> برای نام فایل داده شده مشخص می‌کند باز می‌گردانیم.</p>

<p>کدی که درخواست‌های <code>DELETE</code> را رسیدگی می‌کند کمی ساده‌تر است.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_QVBbtdK0s5" href="#c_QVBbtdK0s5" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">rmdir</span>, <span class="cm-def">unlink</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>).<span class="cm-property">promises</span>;

<span class="cm-variable">methods</span>.<span class="cm-property">DELETE</span> <span class="cm-operator">=</span> <span class="cm-keyword">async</span> <span class="cm-keyword">function</span>(<span class="cm-def">request</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">path</span> <span class="cm-operator">=</span> <span class="cm-variable">urlPath</span>(<span class="cm-variable-2">request</span>.<span class="cm-property">url</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">stats</span>;
  <span class="cm-keyword">try</span> {
    <span class="cm-variable-2">stats</span> <span class="cm-operator">=</span> <span class="cm-keyword">await</span> <span class="cm-variable">stat</span>(<span class="cm-variable-2">path</span>);
  } <span class="cm-keyword">catch</span> (<span class="cm-def">error</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span>.<span class="cm-property">code</span> <span class="cm-operator">!=</span> <span class="cm-string">&quot;ENOENT&quot;</span>) <span class="cm-keyword">throw</span> <span class="cm-variable-2">error</span>;
    <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> {<span class="cm-property">status</span>: <span class="cm-number">204</span>};
  }
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">stats</span>.<span class="cm-property">isDirectory</span>()) <span class="cm-keyword">await</span> <span class="cm-variable">rmdir</span>(<span class="cm-variable-2">path</span>);
  <span class="cm-keyword">else</span> <span class="cm-keyword">await</span> <span class="cm-variable">unlink</span>(<span class="cm-variable-2">path</span>);
  <span class="cm-keyword">return</span> {<span class="cm-property">status</span>: <span class="cm-number">204</span>};
};</pre>

<p><a class="p_ident" id="p_4xc4THSn9Z" href="#p_4xc4THSn9Z" tabindex="-1" role="presentation"></a>هنگامی که یک پاسخ HTTP حاوی هیچ داده‌ای نیست، کد وضعیت 204 (“no content”) را می‌توان برای مشخص کردن آن استفاده کرد. با توجه به اینکه پاسخ به یک درخواست حذف (DELETE) نیازمند ارسال اطلاعاتی به جز اینکه عملیات موفق بوده یا خیر نیست، استفاده از این کد وضعیت در اینجا منطقی است.</p>

<p><a class="p_ident" id="p_2RQH1O1l1J" href="#p_2RQH1O1l1J" tabindex="-1" role="presentation"></a>ممکن است تعجب کنید که چرا تلاش برای حذف فایلی که موجود نیست وضعیت کد موفقیت برمی‌گرداند نه کد وضعیت خطا. زمانی که فایلی که باید حذف شود موجود نیست، می‌توانید پاسخ دهید که هدف درخواست پیش از این  برآورده شده است. استاندارد HTTP پیشنهاد می‌کند که درخواست‌ها را تکرار شونده (idempotent)  بسازیم، به این معنا که اگر درخواست مشابهی را چندین بار ارسال کنیم، پاسخی که دریافت می‌کنیم مشابه این باشد که آن درخواست یک بار ارسال شده است. به عبارتی، اگر سعی کنید که چیزی را که پیش از این حذف شده است  حذف کنید، اثر مورد نظر برآورده شده است -آن فایل دیگر موجود نیست.</p>

<p>گرداننده برای درخواست‌های <code>PUT</code> در اینجا آمده است:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_SSOayCBrzD" href="#c_SSOayCBrzD" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">createWriteStream</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>);

<span class="cm-keyword">function</span> <span class="cm-def">pipeStream</span>(<span class="cm-def">from</span>, <span class="cm-def">to</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>((<span class="cm-def">resolve</span>, <span class="cm-def">reject</span>) <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable-2">from</span>.<span class="cm-property">on</span>(<span class="cm-string">&quot;error&quot;</span>, <span class="cm-variable-2">reject</span>);
    <span class="cm-variable-2">to</span>.<span class="cm-property">on</span>(<span class="cm-string">&quot;error&quot;</span>, <span class="cm-variable-2">reject</span>);
    <span class="cm-variable-2">to</span>.<span class="cm-property">on</span>(<span class="cm-string">&quot;finish&quot;</span>, <span class="cm-variable-2">resolve</span>);
    <span class="cm-variable-2">from</span>.<span class="cm-property">pipe</span>(<span class="cm-variable-2">to</span>);
  });
}

<span class="cm-variable">methods</span>.<span class="cm-property">PUT</span> <span class="cm-operator">=</span> <span class="cm-keyword">async</span> <span class="cm-keyword">function</span>(<span class="cm-def">request</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">path</span> <span class="cm-operator">=</span> <span class="cm-variable">urlPath</span>(<span class="cm-variable-2">request</span>.<span class="cm-property">url</span>);
  <span class="cm-keyword">await</span> <span class="cm-variable">pipeStream</span>(<span class="cm-variable-2">request</span>, <span class="cm-variable">createWriteStream</span>(<span class="cm-variable-2">path</span>));
  <span class="cm-keyword">return</span> {<span class="cm-property">status</span>: <span class="cm-number">204</span>};
};</pre>

<p><a class="p_ident" id="p_FykHZel6vX" href="#p_FykHZel6vX" tabindex="-1" role="presentation"></a>این‌بار نیازی نیست بررسی کنیم که فایل مورد نظر وجود دارد یا خیر- اگر وجود داشت، کافی است تا باز نویسی‌اش کنیم. دوباره از  ‍<code>pipe</code> برای انتقال داده‌ها از یک استریم قابل خوانده به قابل نوشتن استفاده می‌کنیم، در این مورد از یک درخواست به یک فایل. اما چون <code>pipe</code> طوری نوشته نشده است که یک promise برگرداند، باید برایش یک پوشش ایجاد کنیم، که همان <code>pipeStream</code> است و یک promise پیرامون خروجی <code>pipe</code> ایجاد می‌کند.</p>

<p><a class="p_ident" id="p_vHTVlgF/Px" href="#p_vHTVlgF/Px" tabindex="-1" role="presentation"></a>هنگامی‌ که در زمان باز نمودن فایل، مشکلی پیش‌ می‌آید، <code>createWriteStream</code> همچنان یک استریم برمی‌گرداند اما آن استریم یک رخداد <code>&quot;error&quot;</code> را تولید می‌کند. استریم خروجی درخواست نیز ممکن است متوقف شود، به عنوان مثال، اگر شبکه از دسترس خارج شود. بنابراین ما رخداد‌های ‍<code>&quot;error&quot;</code> هر دو استریم را در نظر می‌گیریم تا promise را لغو (reject) کنیم. وقتی کار <code>pipe</code> به اتمام می‌رسد استریم خروجی را می‌بندد که باعث می‌شود رخداد ‍‍<code>&quot;finish&quot;</code> تولید شود. این نقطه ای است که ما می‌توانیم با موفقیت promise را به سرانجام برسانیم (بدون بازگرداندن چیزی).</p>

<p><a class="p_ident" id="p_ql5X8QYJHb" href="#p_ql5X8QYJHb" tabindex="-1" role="presentation"></a>اسکریپت کامل این سرویس‌دهنده در آدرس <a href="https://eloquentjavascript.net/code/file_server.js"><em>https://eloquentjavascript.net/code/file_server.js</em></a> موجود است. می توانید آن را دانلود کرده و پس از نصب وابستگی‌هایش، آن را به وسیله‌ی Node اجرا کنید و سرویس‌هنده‌ی فایل خودتان را داشته باشید. و البته که می توانید آن را تغییر دهید و با حل تمرین‌های این فصل آن را بهبود ببخشید.</p>

<p><a class="p_ident" id="p_TbwcSO28qG" href="#p_TbwcSO28qG" tabindex="-1" role="presentation"></a>ابزار خط فرمان <code>curl</code>، که به طور گسترده در سیستم‌های مبتنی بر Unix مانند مک و لینوکس در دسترس است، را می‌توان برای ایجاد درخواست‌های HTTP استفاده کرد. دستور پیش‌رو به صورت مختصر سرویس‌دهنده‌ی ما را آزمایش می‌کند. گزینه‌ی <bdo><code>-X</code></bdo> برای تنظیم متد درخواست استفاده می‌شود و <bdo><code>-d</code></bdo> برای قرار دادن بدنه‌ی درخواست.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_1De9cCo/FY" href="#c_1De9cCo/FY" tabindex="-1" role="presentation"></a>$ curl http://localhost:8000/file.txt
File not found
$ curl -X PUT -d hello http://localhost:8000/file.txt
$ curl http://localhost:8000/file.txt
hello
$ curl -X DELETE http://localhost:8000/file.txt
$ curl http://localhost:8000/file.txt
File not found</pre>

<p>اولین درخواست برای <code>file.txt</code> با شکست روبرو می‌شود زیرا فایل هنوز وجود ندارد. درخواست <code>PUT</code> فایل را ایجاد می کند و درخواست بعدی آن را با موفقیت برمی‌گرداند. پس از حذف آن به وسیله‌ی درخواست <code>DELETE</code>، فایل دوباره ناموجود می‌شود.</p>

<h2><a class="h_ident" id="h_EzvDUHyjs2" href="#h_EzvDUHyjs2" tabindex="-1" role="presentation"></a>خلاصه</h2>

<p><a class="p_ident" id="p_iZ3tijMtnp" href="#p_iZ3tijMtnp" tabindex="-1" role="presentation"></a>Node دوست داشتنی است، سیستمی کوچک که برای ما امکان اجرای جاوااسکریپت در فضایی غیر از مرورگر را فراهم می‌سازد. هدف ابتدایی طراحی Node برای استفاده در وظایف شبکه بود که قرار بود نقش یک گره (node) را در شبکه بازی کند. اما توانست خود را به همه‌ی وظایف و کاربردهای اسکریپتی عرضه کند، و اگر شما از نوشتن جاوااسکریپت لذت می‌برید، با استفاده از Node می‌توانید کارهایتان را خودکار نمایید.</p>

<p><a class="p_ident" id="p_ZIQPry1iK0" href="#p_ZIQPry1iK0" tabindex="-1" role="presentation"></a>NPM برای هر چیزی که فکرش را بکنید‌ (و چیزهایی که شاید فکرش را هم نکنید) بسته‌هایی فراهم می‌کند، و می‌توانید آن‌ها را بارگیری و به وسیله‌ی برنامه‌ی <code>npm</code> نصب کنید. خود Node نیز تعدادی ماژول درونی دارد،‌ مانند ماژول <code>fs</code> برای کار با سیستم فایل و <code>http</code> برای اجرای سرویس‌دهنده‌های HTTP و ساختن درخواست‌های HTTP.</p>

<p><a class="p_ident" id="p_UZ7+sINZt2" href="#p_UZ7+sINZt2" tabindex="-1" role="presentation"></a>همه‌ی عملیات ورودی و خروجی در Node به صورت ناهمگام صورت می‌پذیرند مگر اینکه صراحتا از شکل همگام یک تابع مانند <code>readFileSync</code> استفاده کنید. زمانی که از این گونه توابع ناهمگام استفاده می‌کنید، شما یک تابع callback به تابع مورد نظر ارسال می‌کنید و Node آن‌ها با یک مقدار خطا و (درصورت وجود) یک نتیجه فراخوانی می کند.</p>

<h2><a class="h_ident" id="h_ggOFdVwDCk" href="#h_ggOFdVwDCk" tabindex="-1" role="presentation"></a>تمرین‌ها</h2>

<h3><a class="i_ident" id="i_0ByU/i411E" href="#i_0ByU/i411E" tabindex="-1" role="presentation"></a>ابزار جستجو</h3>

<p><a class="p_ident" id="p_zswNhQB1Sz" href="#p_zswNhQB1Sz" tabindex="-1" role="presentation"></a>در سیستم‌های مبتنی بر Unix، ابزار خط فرمانی به نام <code>grep</code> وجود دارد که می‌توان از آن برای جستجوی فایل‌ها بر اساس یک عبارت باقاعده استفاده کرد.</p>

<p>یک اسکریپت Node بنویسید که بتوان آن را از طریق خط فرمان اجرا نمود و کاری مشابه <code>grep</code> را انجام دهد.  اولین دستور ورودی از خط فرمان را به عنوان عبارت باقاعده در نظر بگیرد و دیگر ورودی‌ها را به عنوان فایل‌هایی که باید جستجو کند. خروجی این ابزار باید نام‌ فایل‌هایی باشد که محتوایشان با عبارت باقاعده مطابقت داشته باشد.</p>

<p>پس از اینکه به خوبی کار کرد، به آن یک ویژگی جدید اضافه کنید که اگر یکی از ورودی ها پوشه بود، جستجو در همه‌ی فایل‌های آن پوشه و زیرپوشه‌های آن صورت می‌گیرد.</p>

<p>با توجه به نیازی که می‌بینید از توابع سیستم فایل ناهمگام یا همگام استفاده کنید. تنظیم سیستم به صورتی که بتوان چندین عمل ناهمگام را در یک لحظه درخواست داد ممکن است سرعت را اندکی بالا ببرد، اما نباید تعداد عملیات ناهمگام زیاد شود، زیرا در بیشتر سیستم‌های فایل در هر لحظه فقط می‌توان یک چیز را خواند.</p>

<div class="solution"><div class="solution-text">

<p>ورودی اول ابزار خط فرمان شما، همان عبارت باقاعده، را می توان در ‍<code>process.<wbr>argv[2]‍‍</code> به دست آورد. فایل‌های ورودی بعد از آن می‌آیند. می توانید از سازنده‌ی <code>RegExp</code> برای ساخت عبارت باقاعده از یک رشته استفاده کنید.</p>

<p>انجام این کار به صورت همگام، با استفاده از <code>readFileSync</code>، سرراست‌تر است، اما اگر دوباره از <code>fs.promises</code> برای گرفتن توابعی که promise برمی‌گردانند استفاده کنید و یک تابع <code>async</code> بنویسید، کد شما یکسان خواهد بود.</p>

<p><a class="p_ident" id="p_41DVzgFT8+" href="#p_41DVzgFT8+" tabindex="-1" role="presentation"></a>برای فهمیدن اینکه چیزی از جنس پوشه است، می توانید دوباره از <code>stat</code> یا <code>statSync</code> و متد <code>isDirectory</code> شیء stats استفاده کنید.</p>

<p>کاوش یک پوشه یک پردازش درختی است. می توانید این کار را یا با استفاده از یک تابع بازگشتی یا با نگه‌داری آرایه‌ای از کارها (فایل‌هایی که همچنان نیاز است کاوش شوند) انجام دهید. برای یافتن فایل‌های یک پوشه، می توانید <code>readdir</code> یا <code>readdirSync</code> را فراخوانی کنید.  روش عجیب استفاده از حروف بزرگ در نام‌گذاری توابع در سیستم فایل Node از توابع استاندارد Unix الهام گرفته مانند <code>readdir</code> که تماما با حروف کوچک است، اما <code>Sync</code> را با حروف بزرگ به آن اضافه می‌کند.</p>

<p>برای بدست آوردن یک نام مسیر کامل از نام فایلی که با <code>readdir</code> به دست آمده است، باید آن را با نام پوشه ترکیب کنید و یک کاراکتر اسلش (<code>/</code>) بین‌شان قرار دهید.</p>

</div></div>

<h3><a class="i_ident" id="i_rT9dq0Tp++" href="#i_rT9dq0Tp++" tabindex="-1" role="presentation"></a>ایجاد پوشه</h3>

<p>اگر در سرویس‌دهنده‌ی فایل ما، متد <code>DELETE</code> قادر است تا پوشه‌ها را حذف کند (به وسیله‌ی <code>rmdir</code>)، هنوز امکان ایجاد یک پوشه را پشتیبانی نمی‌کند.</p>

<p><a class="p_ident" id="p_fDNpnLouEt" href="#p_fDNpnLouEt" tabindex="-1" role="presentation"></a>پشتیبانی از متد <code>MKCOL</code> (“make collection”) را اضافه کنید، که باید پوشه‌ای را به وسیله‌ی فراخوانی <code>mkdir</code> از ماژول <code>fs</code> ایجاد کند. <code>MKCOL</code> متدی نیست که زیاد استفاده شود در HTTP اما به هر حال برای این هدف در استاندارد <em>WebDAV</em> وجود دارد، که مجموعه‌ای قرارداد در HTTP مشخص می‌کند که آن را مناسب ایجاد کردن اسناد می‌سازد.</p>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_bCxcKcwRYE" href="#p_bCxcKcwRYE" tabindex="-1" role="presentation"></a>می‌توانید از تابعی که متد <code>DELETE</code> را پیاده‌سازی می‌کند به عنوان نقطه‌ی شروع برای متد <code>MKCOL</code> استفاده کنید. زمانی که فایلی پیدا نمی‌شود، سعی کنید تا پوشه‌ای را به وسیله‌ی <code>mkdir</code> ایجاد کنید. زمانی که پوشه‌ی مورد نظر در مسیر داده شده موجود بود، می توانید یک پاسخ 204 ارسال کنید که نشان دهید درخواست‌های ایجاد پوشه تکرارشونده یا idempotent می‌باشند. اگر فایلی غیرپوشه در اینجا وجود داشت، یک کد خطا برگردانید. کد <bdo>400 (“bad request”)</bdo> مناسب خواهد بود.</p>

</div></div>

<h3><a class="i_ident" id="i_pJrS9yxfJE" href="#i_pJrS9yxfJE" tabindex="-1" role="presentation"></a>یک فضای عمومی در وب</h3>

<p>با توجه به اینکه سرویس‌دهنده‌ی فایل ما هر نوعی از فایل را پشتیبانی می‌کند و حتی سرنام صحیح برای <code>Content-Type</code> در نظر می‌گیرد، می توانید از آن برای میزبانی یک وب‌سایت استفاده کنید. به دلیل اینکه این سرویس‌دهنده اجازه حذف و جایگزینی فایل‌ها را به همه می‌دهد، در نوع خودش وب‌سایت جالبی خواهد شد: وب‌سایتی که می توان‌ آن را توسط هرکسی که زمان داشته باشد تا درخواست‌های HTTP صحیح ارسال کند، تغییر داد، بهبود بخشید و خراب کرد .</p>

<p><a class="p_ident" id="p_n3OM6EV/KR" href="#p_n3OM6EV/KR" tabindex="-1" role="presentation"></a>یک صفحه‌ی HTML ساده به همراه یک فایل جاوااسکریپت ساده ایجاد کنید. فایل‌ها را درون یک پوشه قرار داده و توسط سرویس‌دهنده‌ی پشتیبانی و در مرورگرتان باز کنید.</p>

<p>سپس، به عنوان یک تمرین پیشرفته یا حتی یک پروژه برای آخر هفته، تمام دانشی که در این کتاب کسب کرده اید را به کار ببرید تا رابط کاربرپسند‌تری برای ایجاد تغییر در این وب‌سایت ایجاد کنید- از درون خود وب‌سایت.</p>

<p><a class="p_ident" id="p_8B+7Jp4l3r" href="#p_8B+7Jp4l3r" tabindex="-1" role="presentation"></a>از یک فرم HTML برای ویرایش محتوای فایل‌های سازنده‌ی وب‌سایت استفاده کنید و به کاربر این امکان را بدهید که توسط درخواست‌های HTTP آن ها را به‌روزرسانی کند، همانطور که در <a href="18_http.html">فصل 18</a> توضیح داده شده است.</p>

<p>ابتدا فقط با یک فایل قابل ویرایش شروع کنید. سپس آن را تغییر داده تا کاربر بتواند فایلی که می‌خواهد ویرایش کند را انتخاب کند. از این نکته که سرویس‌دهنده‌ی فایل ما در هنگام خواندن یک پوشه لیستی از فایل‌ها را بر می‌گرداند بهره ببرید.</p>

<p>مستقیما در کدی که توسط سرویس‌دهنده فایل در دستری قرار می‌گیرد کار نکنید زیرا اگر اشتباهی مرتکب شوید، احتمال اینکه فایل‌ها را خراب کنید وجود دارد. در عوض، کدهایتان را خارج از یک پوشه قابل دسترس عموم بنویسید و هنگام آزمایش در انجا کپی کنید.</p>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_KpW/ics1eA" href="#p_KpW/ics1eA" tabindex="-1" role="presentation"></a>برای نگه‌داری محتوای فایلی که در حال ویرایش است می‌توانید از یک <code>&lt;textarea&gt;</code> استفاده کنید. یک درخواست‌ ‍<code>GET</code> به وسیله‌ی <code>fetch</code> می‌تواند برای دریافت محتوای  یک فایل استفاده شود. می‌توانید به جای استفاده از <a href="http://localhost:8000/index.html"><em>http://localhost:8000/index.html</em></a>، از URL های نسبی مثل  <em>index.html</em> استفاده کنید تا به فایل‌هایی که روی سرویس‌دهنده‌ی یکسانی با اسکریپت اجرایی هستند ارجاع دهید.</p>

<p>سپس، هنگامی که کاربر روی یک دکمه (می توانید از یک عنصر <code>&lt;form&gt;</code> و رخداد <code>&quot;submit&quot;</code> استفاده کنید) کلیک می کند، یک درخواست <code>PUT</code> به URL مشابه ارسال کنید که در این درخواست محتوای <code>&lt;textarea&gt;</code> به عنوان بدنه‌ی درخواست ارسال می‌شود تا فایل مورد نظر ذخیره شود.</p>

<p>در ادامه می‌توانید یک عنصر <code>&lt;select&gt;</code> که حاوی همه‌ی فایل‌ها موجود در پوشه‌ی بالایی سرویس‌دهنده است اضافه کنید. گزینه‌ها را به وسیله‌ی خطوطی که به وسیله‌ی ارسال درخواست <code>GET</code> به آدرس <code>/</code> دریافت می‌شوند توسط <code>&lt;option&gt;</code> تنظیم کنید. زمانی که کاربر فایل دیگری را انتخاب می‌کند (یک رخداد <code>change</code> روی فیلد)، اسکریپت باید آن فایل را دریافت و نمایش دهد. در هنگام ذخیره‌ی یک فایل، از نام فایل انتخاب شده‌ی فعلی استفاده کنید.</p>

</div></div><nav><a href="19_paint.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="21_skillsharing.html" title="next chapter">▶</a></nav>
</article>
