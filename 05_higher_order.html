<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>توابع رده‌بالا (Higher-Order) :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 5;var sandboxLoadFiles = ["code/scripts.js","code/chapter/05_higher_order.js","code/intro.js"];</script><script>var clicky_site_ids = clicky_site_ids || []; clicky_site_ids.push(101171577);</script>
  <script async src="//static.getclicky.com/js"></script>

</head>

<article>
<nav><a href="04_data.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="06_object.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>فصل 5</span>توابع رده‌بالا (Higher-Order)</h1>

<blockquote>

<p><a class="p_ident" id="p_vFulIihdz0" href="#p_vFulIihdz0" tabindex="-1" role="presentation"></a>زو-لی و زو-سو درباره‌ی اندازه‌ی آخرین برنامه‌هایشان در حال رجز خوانی بودند. زو-لی گفت: 'دویست هزار خط کد' بدون شمردن توضیحات! زو-سو پاسخ داد، هه! برنامه‌ی من تقریبا یک میلون خط شده! استاد Yuan-Ma گفت، 'بهترین برنامه‌ای که نوشتم پانصد خط کد داشت'. با شنیدن این جمله، زو-لی و زو-سو متنبه شدند و به خود آمدند.</p>

<footer>استاد Yuan-Ma, <cite>کتاب برنامه‌نویسی</cite></footer>

</blockquote>

<blockquote>

<p><a class="p_ident" id="p_2jmj7l5rSw" href="#p_2jmj7l5rSw" tabindex="-1" role="presentation"></a>دو روش برای ساختاردهی در طراحی نرم‌افزار وجود دارد: یک راه این است که آن را آن‌قدر ساده بسازیم که به وضوح مشخص باشد که ایرادی وجود ندارد، و روش دیگر این است که آن‌قدر آن را پیچیده بسازیم که نتوان  ایرادات نرم‌افزار را به وضوح تشخیص داد.</p>

<footer>C.A.R. Hoare, <cite>1980 ACM Turing Award Lecture</cite></footer>

</blockquote><figure class="chapter true"><img src="img/chapter_picture_5.jpg" alt="Letters from different scripts"></figure>

<p>یک برنامه بزرگ پرهزینه است و فقط به این خاطر نیست که زمان زیادی برای ساختن آن لازم است. اندازه‌ی برنامه همیشه شامل میزان پیچیدگی برنامه هم می شود، چیزی که برنامه نویسان را سردرگم می کند و موجب می شود اشتباه کنند و برنامه خطا (<em>باگ</em>) داشته باشد. بنابراین یک برنامه‌ی بزرگ فضای زیادی برای پنهان شدن باگ‌ها فراهم می سازد و پیدا کردن باگ‌ها را سخت می کند.</p>

<p>اجازه بدهید به طور مختصر به نسخه‌ی نهایی دو برنامه‌ی نمونه برگردیم که در مقدمه کتاب آورده شده اند. برنامه‌ی اول فاقد تابع و کلا دارای شش خط کد است:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_uIkg9pj99q" href="#c_uIkg9pj99q" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">total</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>, <span class="cm-def">count</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
<span class="cm-keyword">while</span> (<span class="cm-variable">count</span> <span class="cm-operator">&lt;=</span> <span class="cm-number">10</span>) {
  <span class="cm-variable">total</span> <span class="cm-operator">+=</span> <span class="cm-variable">count</span>;
  <span class="cm-variable">count</span> <span class="cm-operator">+=</span> <span class="cm-number">1</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">total</span>);</pre>

<p>دومین برنامه از دو تابع استفاده می و فقط یک خط دارد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_KTbQMmMCli" href="#c_KTbQMmMCli" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sum</span>(<span class="cm-variable">range</span>(<span class="cm-number">1</span>, <span class="cm-number">10</span>)));</pre>

<p>کدام یک بیشتر احتمال دارد باگ داشته باشد؟</p>

<p>اگر اندازه‌ی تعریف توابع <code>sum</code> و <code>range</code> را هم به حساب بیاوریم، برنامه دوم نیز برنامه‌ای بزرگ محسوب می شود – حتی بزرگ تر از برنامه اول. اما هنوز، من ادعا می کنم که این برنامه با احتمال بیشتری درست کار خواهد کرد.</p>

<p><a class="p_ident" id="p_4PtR8M5Y69" href="#p_4PtR8M5Y69" tabindex="-1" role="presentation"></a>با احتمال بیشتری درست کار خواهد کرد زیرا راه‌حل آن با واژگانی بیان شده است که با حل مسئله ارتباط معنایی دارند. جمع  بستن (sum) یک بازه‌ (range) از اعداد ربطی به حلقه‌ها و شمارنده‌ها ؛ندارد بلکه مربوط به بازه‌ها و عمل جمع می شود.</p>

<p>در تعریف این واژگان ( توابع <code>sum</code> و <code>range</code>) همچنان از حلقه‌ها، شمارنده‌ها و دیگر جزئیات فرعی استفاده خواهد شد. اما به دلیل اینکه آن‌ها به جای بیان برنامه به عنوان یک کل، مفاهیم ساده‌تری را نشان می دهند، آسان‌تر سامان می یابند.</p>

<h2><a class="h_ident" id="h_dbW+UMc4df" href="#h_dbW+UMc4df" tabindex="-1" role="presentation"></a>انتزاع</h2>

<p><a class="p_ident" id="p_ilqKIeyLYr" href="#p_ilqKIeyLYr" tabindex="-1" role="presentation"></a>در فضای برنامه‌نویسی، این گونه واژگان را عموما انتزاع‌ها یا <em>abstractions</em> می گویند. انتزاع‌ها جزئیات را مخفی می کنند و به ما این امکان را می دهند که در باره مسئله‌ها در سطح بالاتری ( انتزاع بیشتر ) گفتگو کنیم.</p>

<p>به عنوان تشبیه، می توان این دو طرز تهیه‌ی سوپ نخود را با هم مقایسه کرد. اولین مورد به صورت زیر خواهد بود:</p>

<blockquote>

<p><a class="p_ident" id="p_EzBRXPQ20K" href="#p_EzBRXPQ20K" tabindex="-1" role="presentation"></a>یک فنجان نخود خشک برای هر نفر درون یک ظرف بریزید. به آن آب اضافه کنید تا همه‌ی نخود‌ها را در بر بگیرد. اجازه بدهید نخودها حداقل 12 ساعت در آب بمانند. بعد نخودها را از آب درآورده درون یک قابلمه قرار دهید.  برای هر نفر 4 لیوان آب اضافه کنید. روی قابلمه را پوشانده  و بگذارید برای 2 ساعت روی گاز باشد. برای هر نفر نیمی از پیاز را برداشته آن را تکه تکه کنید و به نخود‌ها اضافه نمایید. برای هر نفر یک ساقه‌ی کرفس بردارید. با چاقو قطعه قطعه کنید و به نخود ها اضافه کنید. برای هر نفر یک هویج در نظر گرفته، تکه تکه کرده با چاقو! و به نخودها اضافه کنید. بگذارید 10 دقیقه دیگر بپزد.</p>

</blockquote>

<p>طرز تهیه‌ی دوم:</p>

<blockquote>

<p>برای هر نفر: یک لیوان نخود خشک، نیمی از یک پیاز تکه تکه شده، یک ساقه کرفس، و یک هویج.</p>

<p><a class="p_ident" id="p_LyHnQ+h/tZ" href="#p_LyHnQ+h/tZ" tabindex="-1" role="presentation"></a>نخود ها را 12 ساعت بخیسانید. 2 ساعت در 4 لیوان آب ( برای یک نفر) روی گاز آهسته بجوشانید. سبزیجات را تکه تکه کرده و اضافه کنید. برای 10 دقیقه دیگر پخته شود.</p>

</blockquote>

<p>دستور دوم کوتاه تر و توضیح ساده تری داشت. اما برای فهم آن بایستی چند واژه‌ی مرتبط با آشپزی را یاد داشته باشید – <em>خیساندن</em>،  <em>جوشاندن،</em> <em>ریز ریز کردن</em> و فکر کنم <em>سبزیجات</em>.</p>

<p>هنگام برنامه‌نویسی، نمی توانیم فرض کنیم همه‌ی واژگانی که نیاز داریم وجود داشته و در واژه‌نامه منتظر ما باشند. بنابراین، ممکن است به دام الگوی موجود در طرز تهیه‌ی اول بیفتیم - کارکردن روی قدم‌های دقیقی که کامپیوتر بایستی اجرا کند، یکی پس از دیگری، بدون توجه به مفاهیم سطح بالاتری که این دستورات بیان می کنند.</p>

<p>یکی از مهارت های کاربردی در برنامه نویسی، این است که زمانی که در سطح بسیار پایینی از انتزاع کار می کنید، نسبت به آن آگاه باشید.</p>

<h2><a class="h_ident" id="h_k5Nc/FDVtG" href="#h_k5Nc/FDVtG" tabindex="-1" role="presentation"></a>تکرار انتزاعی</h2>

<p>توابع ساده، مانند مواردی که تا کنون دیده ایم، برای ایجاد انتزاع مفید هستند. اما گاهی اوقات کافی نیستند.</p>

<p>در برنامه‌ها رایج است که کاری را به تعداد مشخصی تکرار کنیم. می توان از یک حلقه‌ی <code>for</code> برای این کار استفاده کرد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_5c+C2+9IG1" href="#c_5c+C2+9IG1" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable">i</span> <span class="cm-operator">&lt;</span> <span class="cm-number">10</span>; <span class="cm-variable">i</span><span class="cm-operator">++</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">i</span>);
}</pre>

<p><a class="p_ident" id="p_0oZoOm1bri" href="#p_0oZoOm1bri" tabindex="-1" role="presentation"></a>آیا می توان “انجام یک کار به تعداد <em>N</em> بار” را با استفاده از یک تابع تجرید کرد؟ خوب خیلی راحت می توان تابعی نوشت که <bdo><code>console.log</code></bdo> را <em>N</em>  بار فراخوانی کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_/gKhlra9P+" href="#c_/gKhlra9P+" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">repeatLog</span>(<span class="cm-def">n</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">n</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">i</span>);
  }
}</pre>

<p>اما اگر بخواهیم کاری به غیر از چاپ اعداد در خروجی انجام دهیم چه؟ با توجه به این که “انجام یک کار” را می توان به عنوان یک تابع در نظر گرفت و توابع هم در واقع مقدار هستند، می توانیم &quot;کار&quot;مان را به عنوان یک مقدار تابع ارسال کنیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_p03rPqGmn9" href="#c_p03rPqGmn9" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">repeat</span>(<span class="cm-def">n</span>, <span class="cm-def">action</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">n</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-variable-2">action</span>(<span class="cm-variable-2">i</span>);
  }
}

<span class="cm-variable">repeat</span>(<span class="cm-number">3</span>, <span class="cm-variable">console</span>.<span class="cm-property">log</span>);
<span class="cm-comment">// → 0</span>
<span class="cm-comment">// → 1</span>
<span class="cm-comment">// → 2</span></pre>

<p>نیازی نیست که حتما یک تابع از پیش تعریف شده را به تابع <code>repeat</code>  ارسال کنید. اغلب آسان تر است که یک مقدار تابع همان موقع ایجاد کنیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_EiK2Y8M/Mh" href="#c_EiK2Y8M/Mh" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">labels</span> <span class="cm-operator">=</span> [];
<span class="cm-variable">repeat</span>(<span class="cm-number">5</span>, <span class="cm-def">i</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">labels</span>.<span class="cm-property">push</span>(<span class="cm-string-2">`Unit ${</span><span class="cm-variable-2">i</span> <span class="cm-operator">+</span> <span class="cm-number">1</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
});
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">labels</span>);
<span class="cm-comment">// → [&quot;Unit 1&quot;, &quot;Unit 2&quot;, &quot;Unit 3&quot;, &quot;Unit 4&quot;, &quot;Unit 5&quot;]</span></pre>

<p>این ساختار کمی شبیه حلقه‌ی <code>for</code> به نظر می رسد – ابتدا نوع حلقه را مشخص می کند سپس بدنه را فراهم می کند.  با این حال، بدنه اکنون به صورت یک مقدار تابع نوشته می شود، که خود درون پرانتز‌های مربوط به فراخوانی تابع <code>repeat</code> قرار گرفته است. به همین دلیل است که باید حتما به وسیله کروشه‌ی پایانی  <em>و</em> پرانتز پایانی بسته شود.  در مواردی شبیه این مثال، جایی که بدنه، یک عبارت واحد کوچک است، می توانید کروشه‌ها را حذف کنید و حلقه را در یک خط بنویسید.</p>

<h2><a class="h_ident" id="h_msQfR7LHfK" href="#h_msQfR7LHfK" tabindex="-1" role="presentation"></a>توابع رده‌بالا</h2>

<p><a class="p_ident" id="p_7og6VBGsqZ" href="#p_7og6VBGsqZ" tabindex="-1" role="presentation"></a>توابعی که روی توابع دیگر عمل می کنند، چه با گرفتن آن ها به عنوان آرگومان و چه با برگرداندن آن ها ، <em>توابع رده‌بالا</em> نامیده می شوند. با توجه به این که پیش تر دیده‌ایم که توابع در واقع یک نوع مقدار هستند، مسئله‌ی قابل توجه و به خصوصی در مورد فلسفه‌ی وجود اینگونه توابع وجود ندارد. اصطلاح رده‌بالا (higher-order) از ریاضیات گرفته شده است جایی که به تمایز بین توابع و دیگر مقادیر اهمیت بیشتری داده شده است.</p>

<p>توابع رده‌بالا، به ما این امکان را می دهند که براساس <em>اقدام‌ها</em>، انتزاع ایجاد کنیم، نه فقط بر اساس مقدارها.  این گونه توابع به اشکال مختلفی می آیند. به عنوان نمونه‌، می توانید توابعی داشته باشید که خود توابعی را ایجاد می کنند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_kHXugeV8Vn" href="#c_kHXugeV8Vn" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">greaterThan</span>(<span class="cm-def">n</span>) {
  <span class="cm-keyword">return</span> <span class="cm-def">m</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">m</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">n</span>;
}
<span class="cm-keyword">let</span> <span class="cm-def">greaterThan10</span> <span class="cm-operator">=</span> <span class="cm-variable">greaterThan</span>(<span class="cm-number">10</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">greaterThan10</span>(<span class="cm-number">11</span>));
<span class="cm-comment">// → true</span></pre>

<p>یا توابعی داشته باشید که دیگر توابع را تغییر می دهند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_17dfYaooPK" href="#c_17dfYaooPK" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">noisy</span>(<span class="cm-def">f</span>) {
  <span class="cm-keyword">return</span> (<span class="cm-meta">...</span><span class="cm-def">args</span>) <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;calling with&quot;</span>, <span class="cm-variable-2">args</span>);
    <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable-2">f</span>(<span class="cm-meta">...</span><span class="cm-variable-2">args</span>);
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;called with&quot;</span>, <span class="cm-variable-2">args</span>, <span class="cm-string">&quot;, returned&quot;</span>, <span class="cm-variable-2">result</span>);
    <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
  };
}
<span class="cm-variable">noisy</span>(<span class="cm-variable">Math</span>.<span class="cm-property">min</span>)(<span class="cm-number">3</span>, <span class="cm-number">2</span>, <span class="cm-number">1</span>);
<span class="cm-comment">// → calling with [3, 2, 1]</span>
<span class="cm-comment">// → called with [3, 2, 1] , returned 1</span></pre>

<p>حتی می توانید توابعی بنویسید که نوعی جدیدی از جریان کنترل را فراهم نمایند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_of6iH06dyE" href="#c_of6iH06dyE" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">unless</span>(<span class="cm-def">test</span>, <span class="cm-def">then</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">test</span>) <span class="cm-variable-2">then</span>();
}

<span class="cm-variable">repeat</span>(<span class="cm-number">3</span>, <span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">unless</span>(<span class="cm-variable-2">n</span> <span class="cm-operator">%</span> <span class="cm-number">2</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>, () <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">n</span>, <span class="cm-string">&quot;is even&quot;</span>);
  });
});
<span class="cm-comment">// → 0 is even</span>
<span class="cm-comment">// → 2 is even</span></pre>

<p>متد از پیش تعریف شده ای به نام <code>forEach</code> برای آرایه‌ها وجود دارد که کاری شبیه حلقه‌ی <bdo><code>for</code>/<code>of</code></bdo> را به عنوان یک تابع رده‌بالا انجام می دهد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_v9jL6NafRj" href="#c_v9jL6NafRj" tabindex="-1" role="presentation"></a>[<span class="cm-string">&quot;A&quot;</span>, <span class="cm-string">&quot;B&quot;</span>].<span class="cm-property">forEach</span>(<span class="cm-def">l</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">l</span>));
<span class="cm-comment">// → A</span>
<span class="cm-comment">// → B</span></pre>

<h2><a class="h_ident" id="h_NLbARNSu7u" href="#h_NLbARNSu7u" tabindex="-1" role="presentation"></a>مجموعه داده‌ی الفبا</h2>

<p>یکی از ناحیه‌هایی که توابع رده‌بالا درخشان عمل می کنند، پردازش داده ها می باشد. برای پردازش داده ها، نیاز به داده‌ی واقعی داریم. در این فصل از مجموعه‌ی داده‌ای در باره‌ی حروف الفبا – سیستم های نوشتاری مانند لاتین، سیریلیک، یا عربی – استفاده می کنیم.</p>

<p><a class="p_ident" id="p_k4cCIHQMIm" href="#p_k4cCIHQMIm" tabindex="-1" role="presentation"></a>یونیکد را از <a href="01_values.html#unicode">فصل 1</a> به خاطر بیاورید، سیستمی که برای هر کاراکتر از زبان های نوشتاری، عددی را اختصاص می داد. اکثر این کاراکترها به الفبای مشخصی تعلق دارند.  این استاندارد دارای 140 الفبای متفاوت است – از این تعداد، 81 تای آن ها امروزه استفاده می شوند و 59 مورد دیگر به تاریخ پیوسته اند.</p>

<p><a class="p_ident" id="p_uIiymCa7U9" href="#p_uIiymCa7U9" tabindex="-1" role="presentation"></a>اگرچه من فقط می توانم کاراکترهای لاتین را به صورت روان بخوانم، اما این واقعیت که مردم جهان حداقل به 80 سیستم نوشتاری دیگر می نویسند که خیلی از آن ها را حتی نمی توانم تشخیص دهم را تحسین می کنم . به عنوان مثال، نمونه‌ی زیر دست نوشته ای از زبان تمیل است:</p><figure><img src="img/tamil.png" alt="Tamil handwriting"></figure>

<p><a class="p_ident" id="p_Ei6NLuQyZ4" href="#p_Ei6NLuQyZ4" tabindex="-1" role="presentation"></a>مجموعه‌ی داده نمونه‌ی ما حاوی اطلاعاتی از حدود 140 الفبای موجود در یونیکد است. این داده‌ها در قسمت <a href="https://eloquentjavascript.net/code#5">کدهای</a> این فصل  به عنوان متغیر <code>SCRIPTS</code> قابل دانلود می باشند. این متغیر شامل آرایه‌ای از اشیاء است که هر کدام معرف یک الفبا می باشند.</p>

<pre class="snippet cm-s-default" data-language="application/json" ><a class="c_ident" id="c_YkfuyBG2fl" href="#c_YkfuyBG2fl" tabindex="-1" role="presentation"></a>{
  <span class="cm-property">name</span>: <span class="cm-string">&quot;Coptic&quot;</span>,
  <span class="cm-property">ranges</span>: [[<span class="cm-number">994</span>, <span class="cm-number">1008</span>], [<span class="cm-number">11392</span>, <span class="cm-number">11508</span>], [<span class="cm-number">11513</span>, <span class="cm-number">11520</span>]],
  <span class="cm-property">direction</span>: <span class="cm-string">&quot;ltr&quot;</span>,
  <span class="cm-property">year</span>: <span class="cm-operator">-</span><span class="cm-number">200</span>,
  <span class="cm-property">living</span>: <span class="cm-atom">false</span>,
  <span class="cm-property">link</span>: <span class="cm-string">&quot;https://en.wikipedia.org/wiki/Coptic_alphabet&quot;</span>
}</pre>

<p>این اشیاء شامل نام الفبا، بازه‌ی یونیکدی که به آن اختصاص دارد،جهتی که به آن سمت نوشته می شود، منشاء زمانی (تقریبی)، اینکه اکنون نیز استفاده می شوند یا خیر، و لینکی به اطلاعات بیشتر می باشند. جهت نوشتن می تواند <code>&quot;ltr&quot;</code> برای چپ به راست، <code>&quot;rtl&quot;</code> راست به چپ (مانند عربی و عبری) یا <code>&quot;ttb&quot;</code> برای بالا به پایین (مانند زبان مغولی) باشد.</p>

<p><a class="p_ident" id="p_kubOhWdP4W" href="#p_kubOhWdP4W" tabindex="-1" role="presentation"></a>خاصیت <code>ranges</code> شامل آرایه‌ای از بازه‌های کاراکتر یونیکد می باشد که هر کدام یک آرایه‌ی دو عنصری است که یک مرز پایین و بالا دارد. هر کد کاراکتری که در این بازه قرار بگیرد متعلق به الفبای مذکور است. مرز پایین خود نیز شامل است ( کد 994 یک کاراکتر قبطی است) و مرز بالایی، خود شامل نمی شود (کد 1008 متعلق به قبطی نیست)</p>

<h2><a class="h_ident" id="h_kSp6ZlxcdG" href="#h_kSp6ZlxcdG" tabindex="-1" role="presentation"></a>فیلتر کردن آرایه ها</h2>

<p>برای پیدا کردن‌ الفباهایی که همچنان استفاده می شوند، تابع پیش رو می تواند مفید باشد. این تابع یه عنوان یک صافی عمل می کند و عناصری که با شرط تطبیق ندارند را در نتایج نمی آورد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_POEf7pMCk0" href="#c_POEf7pMCk0" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">filter</span>(<span class="cm-def">array</span>, <span class="cm-def">test</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">passed</span> <span class="cm-operator">=</span> [];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">element</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">array</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">test</span>(<span class="cm-variable-2">element</span>)) {
      <span class="cm-variable-2">passed</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">element</span>);
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">passed</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">filter</span>(<span class="cm-variable">SCRIPTS</span>, <span class="cm-def">script</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">script</span>.<span class="cm-property">living</span>));
<span class="cm-comment">// → [{name: &quot;Adlam&quot;, …}, …]</span></pre>

<p>تابع بالا از آرگومانی به نام <code>test</code> استفاده می کند، یک مقدار تابع، تا محاسبه مورد نظر را تکمیل کند – عمل انتخاب عناصری که باید به مجموعه اضافه شوند.</p>

<p><a class="p_ident" id="p_r+AD8RdksC" href="#p_r+AD8RdksC" tabindex="-1" role="presentation"></a>توجه کنید که چگونه تابع <code>filter،</code> به جای اینکه عناصر را از آرایه حذف کند، آرایه‌ی جدیدی می سازد که شامل فقط عناصری است که با شرط تطبیق دارند .این تابع <em>ناب</em> (pure) است. آرایه‌ای که دریافت می کند را تغییر نمی دهد.</p>

<p>شبیه <code>forEach،</code> تابع <code>filter</code> نیز یک متد استاندارد آرایه است. در مثالا بالا، تابع تعریف شد تا شیوه‌ی کارکرد درون آن را نشان دهد. از الان به بعد، به شکل زیر از آن استفاده خواهیم کرد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_x8e0PmGGB1" href="#c_x8e0PmGGB1" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">SCRIPTS</span>.<span class="cm-property">filter</span>(<span class="cm-def">s</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">s</span>.<span class="cm-property">direction</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;ttb&quot;</span>));
<span class="cm-comment">// → [{name: &quot;Mongolian&quot;, …}, …]</span></pre>

<h2 id="map"><a class="h_ident" id="h_ED83giG5cC" href="#h_ED83giG5cC" tabindex="-1" role="presentation"></a>تغییر شکل به وسیله‌ی map</h2>

<p>فرض کنید آرایه ای از اشیاء در دست داریم که نمایانگر الفبایی است که پس از اعمال فیلتر به آرایه‌ی <code>SCRIPTS</code> به وجود آمده است. اما اگر آرایه‌ای از نام ها در اختیار داشتیم کارمان ساده تر می شد.</p>

<p>متد <code>map</code> برای تغییر یک آرایه استفاده می شود. به این صورت که تابعی را به همه‌ی عناصر آرایه اعمال کرده و آرایه‌ی جدیدی را از مقادیر برگردانده شده می سازد. تعداد عناصر آرایه‌ی جدید با آرایه‌ی ورودی برابر است. اما محتوای آن به وسیله‌ی تابع داده شده تغییر می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_03caQcQElo" href="#c_03caQcQElo" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">map</span>(<span class="cm-def">array</span>, <span class="cm-def">transform</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">mapped</span> <span class="cm-operator">=</span> [];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">element</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">array</span>) {
    <span class="cm-variable-2">mapped</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">transform</span>(<span class="cm-variable-2">element</span>));
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">mapped</span>;
}

<span class="cm-keyword">let</span> <span class="cm-def">rtlScripts</span> <span class="cm-operator">=</span> <span class="cm-variable">SCRIPTS</span>.<span class="cm-property">filter</span>(<span class="cm-def">s</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">s</span>.<span class="cm-property">direction</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;rtl&quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">map</span>(<span class="cm-variable">rtlScripts</span>, <span class="cm-def">s</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">s</span>.<span class="cm-property">name</span>));
<span class="cm-comment">// → [&quot;Adlam&quot;, &quot;Arabic&quot;, &quot;Imperial Aramaic&quot;, …]</span></pre>

<p>شبیه <code>forEach</code> و <code>filter</code> متد <code>map</code> نیز از متدهای استاندارد آرایه است.</p>

<h2><a class="h_ident" id="h_NCm3KSrFg3" href="#h_NCm3KSrFg3" tabindex="-1" role="presentation"></a>خلاصه‌ کردن یک آرایه به وسیله‌ی متد reduce</h2>

<p>یکی دیگر از کارهای رایجی که با آرایه‌ها انجام می شود، محاسبه‌ی یک مقدار واحد از آن ها است. مثال تکراری خودمان، جمع کردن مجموعه‌ای از اعداد، نمونه‌ی از آن است. یک مثال دیگر می تواند پیدا کردن الفبایی با بیشترین حروف باشد.</p>

<p><a class="p_ident" id="p_SMNon23V6e" href="#p_SMNon23V6e" tabindex="-1" role="presentation"></a>عمل &quot;رده‌بالا&quot;یی که برای این الگو وجود دارد، <em>reduce</em> (کاهش) خوانده می شود ( گاهی اوقات هم آن‌ را <em>تاکردن</em> می نامند.) این متد به صورت مکرر عنصری از آرایه را گرفته و آن را با مقدار قبلی ترکیب کرده و در نهایت یک مقدار واحد تولید می کند. زمانی که اعداد را جمع می کنید، ابتدا با عدد صفر شروع می کنید و بعد یکایک عناصر را به مجموع اضافه می کنید.</p>

<p>پارامترهای تابع <code>reduce،</code> بدون در نظر گرفتن خود آرایه، شامل یک تابع ترکیب و یک مقدار اولیه می باشند. مفهوم این تابع به سرراستی <code>filter</code> و <code>map</code> نیست، پس بیایید نگاه دقیق تری بکنیم:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_k5GDHjqpSc" href="#c_k5GDHjqpSc" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">reduce</span>(<span class="cm-def">array</span>, <span class="cm-def">combine</span>, <span class="cm-def">start</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">current</span> <span class="cm-operator">=</span> <span class="cm-variable-2">start</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">element</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">array</span>) {
    <span class="cm-variable-2">current</span> <span class="cm-operator">=</span> <span class="cm-variable-2">combine</span>(<span class="cm-variable-2">current</span>, <span class="cm-variable-2">element</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">current</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">reduce</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>], (<span class="cm-def">a</span>, <span class="cm-def">b</span>) <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-variable-2">b</span>, <span class="cm-number">0</span>));
<span class="cm-comment">// → 10</span></pre>

<p>متد استاندارد آرایه‌ی <code>reduce</code> که شبیه به تابع بالا می باشد، یک مزیت بیشتر نیز دارد. اگر آرایه‌ی شما حداقل یک عنصر داشته باشد، می توانید آرگومان <code>start</code> را حذف کنید. خود تابع، اولین عنصر آرایه را به عنوان مقدار شروع در نظر گرفته و عمل کاهش را از عنصر دوم شروع می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Dxn7muuMkk" href="#c_Dxn7muuMkk" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>].<span class="cm-property">reduce</span>((<span class="cm-def">a</span>, <span class="cm-def">b</span>) <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-variable-2">b</span>));
<span class="cm-comment">// → 10</span></pre>

<p>برای استفاده از متد <code>reduce</code> (دو بار) برای پیدا کردن الفبایی که بیشترین حروف را دارد، می توانیم چیزی مثل کد پایین بنویسیم:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_x76Ukt5X+H" href="#c_x76Ukt5X+H" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">characterCount</span>(<span class="cm-def">script</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">script</span>.<span class="cm-property">ranges</span>.<span class="cm-property">reduce</span>((<span class="cm-def">count</span>, [<span class="cm-def">from</span>, <span class="cm-def">to</span>]) <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">count</span> <span class="cm-operator">+</span> (<span class="cm-variable-2">to</span> <span class="cm-operator">-</span> <span class="cm-variable-2">from</span>);
  }, <span class="cm-number">0</span>);
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">SCRIPTS</span>.<span class="cm-property">reduce</span>((<span class="cm-def">a</span>, <span class="cm-def">b</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">return</span> <span class="cm-variable">characterCount</span>(<span class="cm-variable-2">a</span>) <span class="cm-operator">&lt;</span> <span class="cm-variable">characterCount</span>(<span class="cm-variable-2">b</span>) <span class="cm-operator">?</span> <span class="cm-variable-2">b</span> : <span class="cm-variable-2">a</span>;
}));
<span class="cm-comment">// → {name: &quot;Han&quot;, …}</span></pre>

<p><a class="p_ident" id="p_IHfwEcHMPM" href="#p_IHfwEcHMPM" tabindex="-1" role="presentation"></a>تابع <code>characterCount</code> بازه‌ های  مربوط به یک الفبا را به وسیله جمع کردن اندازه‌ی آن ها کاهش می دهد. به استفاده از “تجزیه” (destructing) در لیست پارامتر ها در تابع کاهش دهنده توجه کنید. در فراخوانی دوم تابع <code>reduce</code>، از این نتیجه برای پیدا کردن بزرگترین الفبا استفاده می شود؛  دو به دو الفبا ها را مقایسه کرده و الفبای بزرگتر را بر می گرداند.</p>

<p><a class="p_ident" id="p_5FQGaj5ujw" href="#p_5FQGaj5ujw" tabindex="-1" role="presentation"></a>الفبای Han (هان) دارای بیش از <bdo>89,000</bdo> کاراکتر در استاندارد یونیکد است، که باعث شده به عنوان بزرگ‌ترین سیستم نوشتاری در این مجموعه شناخته شود. هان الفبایی است که (گاهی) برای متون چینی، ژاپنی، و کره‌ای استفاده می شود. این زبان‌ها کاراکترهای مشترک زیادی دارند اگرچه که به شکل متفاوتی آن ها را می نویسند. کنسرسیوم یونیکد ( مستقر در ایالات متحده) تصمیم گرفت که آن ها را به عنوان یک سیستم نوشتاری واحد در نظر بگیرد تا کدهای کارکتر کمتری استفاده شود. این کار <em>یکی سازی الفبای هان</em> خوانده می شود که هنوز بعضی افراد را خیلی عصبانی می کند.</p>

<h2><a class="h_ident" id="h_U/TVE+gCPe" href="#h_U/TVE+gCPe" tabindex="-1" role="presentation"></a>ترکیب پذیری</h2>

<p>ملاحظه کنید چگونه بدون استفاده توابع‌ رده‌بالا، می توانستیم مثال قبل را بنویسیم ( پیدا کردن بزرگ‌ترین الفبا).  آن‌قدرها هم بد از کار در نمی آمد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_1FmIKHNB24" href="#c_1FmIKHNB24" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">biggest</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
<span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">script</span> <span class="cm-keyword">of</span> <span class="cm-variable">SCRIPTS</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">biggest</span> <span class="cm-operator">==</span> <span class="cm-atom">null</span> <span class="cm-operator">|</span><span class="cm-operator">|</span>
      <span class="cm-variable">characterCount</span>(<span class="cm-variable">biggest</span>) <span class="cm-operator">&lt;</span> <span class="cm-variable">characterCount</span>(<span class="cm-variable">script</span>)) {
    <span class="cm-variable">biggest</span> <span class="cm-operator">=</span> <span class="cm-variable">script</span>;
  }
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">biggest</span>);
<span class="cm-comment">// → {name: &quot;Han&quot;, …}</span></pre>

<p>با چند متغیر اضافی و چهار خط کدنویسی بیشتر، همچنان برنامه خوانایی خوبی دارد.</p>

<p id="average_function">توابع رده‌بالا زمانی شروع به درخشش می کنند که نیاز باشد عملیات را <em>ترکیب</em> کنید. به عنوان یک مثال، بیایید کدی بنویسیم که میانگین سال ایجاد را برای الفبا‌های زنده و از رده خارج پیدا می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_rbnWPJoeJs" href="#c_rbnWPJoeJs" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">average</span>(<span class="cm-def">array</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">array</span>.<span class="cm-property">reduce</span>((<span class="cm-def">a</span>, <span class="cm-def">b</span>) <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-variable-2">b</span>) <span class="cm-operator">/</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">round</span>(<span class="cm-variable">average</span>(
  <span class="cm-variable">SCRIPTS</span>.<span class="cm-property">filter</span>(<span class="cm-def">s</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">s</span>.<span class="cm-property">living</span>).<span class="cm-property">map</span>(<span class="cm-def">s</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">s</span>.<span class="cm-property">year</span>))));
<span class="cm-comment">// → 1188</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">round</span>(<span class="cm-variable">average</span>(
  <span class="cm-variable">SCRIPTS</span>.<span class="cm-property">filter</span>(<span class="cm-def">s</span> <span class="cm-operator">=&gt;</span> <span class="cm-operator">!</span><span class="cm-variable-2">s</span>.<span class="cm-property">living</span>).<span class="cm-property">map</span>(<span class="cm-def">s</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">s</span>.<span class="cm-property">year</span>))));
<span class="cm-comment">// → 188</span></pre>

<p>بنابراین به طور میانگین الفباهای از رده خارج در یونیکد، قدیمی تر از موارد زنده هستند. این نتیجه خیلی معنای خاصی نمی دهد یا آمار شگفت انگیزی محسوب نمی شود. اما امیدوارم  موافق باشید که کدی که برای محاسبه این نتیجه استفاده شده از خوانایی خوبی برخوردار است. می توانید آن را به عنوان یک خط لوله در نظر بگیرید:  با همه‌ی الفباها شروع می کنیم، موارد زنده (یا از رده خارج) را فیلتر می کنیم، سال‌ها را از آن ها گرفته، میانگین می گیریم و نتیجه را گرد می کنیم.</p>

<p>قطعا می شد این محاسبه را به وسیله یک حلقه‌ی بزرگ پیاده‌سازی کرد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_PumCVjaL6O" href="#c_PumCVjaL6O" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">total</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>, <span class="cm-def">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
<span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">script</span> <span class="cm-keyword">of</span> <span class="cm-variable">SCRIPTS</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">script</span>.<span class="cm-property">living</span>) {
    <span class="cm-variable">total</span> <span class="cm-operator">+=</span> <span class="cm-variable">script</span>.<span class="cm-property">year</span>;
    <span class="cm-variable">count</span> <span class="cm-operator">+=</span> <span class="cm-number">1</span>;
  }
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">round</span>(<span class="cm-variable">total</span> <span class="cm-operator">/</span> <span class="cm-variable">count</span>));
<span class="cm-comment">// → 1188</span></pre>

<p>اما کاری که می کند و چگونگی آن به راحتی قابل درک نیست. و به علت اینکه نتایج میانی به عنوان مقادیری مربوط و منسجم نشان داده نمی شوند، برای اینکه بتوان چیزی شبیه به <code>average</code> را به عنوان یک تابع مستقل از دل آن استخراج کرد، کار زیادی خواهد برد.</p>

<p>با توجه به کاری که کامپیوتر در واقعیت انجام می دهد، این دو رهیافت نسبتا با هم متفاوت هستند. در مورد اول، یک آرایه جدید پس از اجرای <code>filter</code> و <code>map</code> ایجاد می شود، در حالیکه در مورد دوم فقط محاسباتی روی اعداد انجام می شود و کار کمتری صورت می گیرد. معمولا استفاده از روش خواناتر قابل استفاده و منطقی است اما اگر قصد پردازش آرایه‌های خیلی بزرگ را دارید، و این کار را به تعداد دفعات بالایی انجام می دهید، استفاده از روشی با خوانایی و انتزاع کمتر، ارزش سرعتی که دریافت می کنید را دارد.</p>

<h2><a class="h_ident" id="h_RVi4WcXKWO" href="#h_RVi4WcXKWO" tabindex="-1" role="presentation"></a>رشته‌ها و کدهای کاراکتر</h2>

<p>یکی از کاربرد‌هایی که می توان برای این مجموعه‌ی داده در نظر گرفت، استفاده از آن برای تشخیص الفبای یک متن است. بیایید به سراغ برنامه‌ای برویم که همین کار را انجام می دهد.</p>

<p>به خاطر دارید که هر الفبا حاوی یک آرایه از بازه‌های کد کاراکتری که به آن اختصاص داشت بود. با داشتن یک کد کاراکتر، می توانیم از تابعی مثل زیر برای پیدا کردن الفبای مرتبطش ( در صورت وجود )‌ استفاده کنیم:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Q8918ecfHn" href="#c_Q8918ecfHn" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">characterScript</span>(<span class="cm-def">code</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">script</span> <span class="cm-keyword">of</span> <span class="cm-variable">SCRIPTS</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">script</span>.<span class="cm-property">ranges</span>.<span class="cm-property">some</span>(([<span class="cm-def">from</span>, <span class="cm-def">to</span>]) <span class="cm-operator">=&gt;</span> {
      <span class="cm-keyword">return</span> <span class="cm-variable-2">code</span> <span class="cm-operator">&gt;=</span> <span class="cm-variable-2">from</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span> <span class="cm-variable-2">code</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">to</span>;
    })) {
      <span class="cm-keyword">return</span> <span class="cm-variable-2">script</span>;
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-atom">null</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">characterScript</span>(<span class="cm-number">121</span>));
<span class="cm-comment">// → {name: &quot;Latin&quot;, …}</span></pre>

<p><a class="p_ident" id="p_viUD0tQjF6" href="#p_viUD0tQjF6" tabindex="-1" role="presentation"></a>متد <code>some</code> یکی دیگر از توابع رده‌بالا است. این متد تابعی را به عنوان شرط دریافت می کند. این شرط به تک تک عناصر آرایه اعمال شده و اگر حداقل برای یکی از آن ها صدق کند (true باشد)، تابع نیز true را بر می گرداند.</p>

<p id="code_units">اما چگونه می توانیم کدهای کاراکتر یک رشته را بدست بیاوریم؟</p>

<p><a class="p_ident" id="p_uZTbwHfeuE" href="#p_uZTbwHfeuE" tabindex="-1" role="presentation"></a>در <a href="01_values.html">فصل 1</a> اشاره کردم که در جاوااسکریپت رشته‌ها به عنوان دنباله‌ای از اعداد 16 بیتی کدگذاری می شوند که به آن‌ها واحد‌های کد گفته می شود. ابتدا قرار بود در یونیکد هر کد کاراکتر در یکی از این واحد‌ها قرار گیرد ( که چیزی بیش از <bdo>65,000</bdo> کاراکتر را در اختیار شما می گذارد).  زمانی که روشن شد این مقدار کافی نیست، خیلی ها از موضوع اختصاص حافظه‌ی بیشتر برای هر کاراکتر طفره می رفتند. برای حل این مشکل، UTF-16 اختراع شد ، فرمتی که برای رشته‌های جاوااسکریپت استفاده می شود.  این سیستم اکثر کاراکترهای رایج را با یک واحد کد 16 بیتی توصیف می کند اما برای دیگر کدها، از دو واحد استفاده می کند.</p>

<p><a class="p_ident" id="p_BaR3OpT/DK" href="#p_BaR3OpT/DK" tabindex="-1" role="presentation"></a>این‌ روزها UTF-16  عموما به عنوان ایده‌ی بدی شناخته می شود. به نظر می رسد که عمدا طوری طراحی شده است که اشتباه ساز باشد. به‌سادگی توان برنامه‌هایی نوشت که در ظاهر تفاوتی بین واحدها و کاراکترهای کد قائل نمی شوند و بدون مشکل هم کار می کنند. اما به محض اینکه کسی سعی کند از این گونه برنامه‌ها برای نوشتن بعضی کاراکترهای چینی نامتداول استفاده کند، برنامه از کار می افتد. خوشبختانه، با ظهور ایموجی، همه به سراغ استفاده از کاراکترهای دو واحده رفته اند، و مسئولیت سروکار داشتن با این گونه مشکلات با عدالت بیشتری توزیع شده است.</p>

<p>متاسفانه، در جاوااسکریپت کارهای واضح روی رشته‌ها، مثل گرفتن طول آن ها به وسیله خاصیت <code>length</code> و دسترسی به محتوای آن‌ها به وسیله براکت ها، تنها از واحدهای کد پشتیبانی می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_50Oes+9anA" href="#c_50Oes+9anA" tabindex="-1" role="presentation"></a><span class="cm-comment">// Two emoji characters, horse and shoe</span>
<span class="cm-keyword">let</span> <span class="cm-def">horseShoe</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;🐴👟&quot;</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">horseShoe</span>.<span class="cm-property">length</span>);
<span class="cm-comment">// → 4</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">horseShoe</span>[<span class="cm-number">0</span>]);
<span class="cm-comment">// → (Invalid half-character)</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">horseShoe</span>.<span class="cm-property">charCodeAt</span>(<span class="cm-number">0</span>));
<span class="cm-comment">// → 55357 (Code of the half-character)</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">horseShoe</span>.<span class="cm-property">codePointAt</span>(<span class="cm-number">0</span>));
<span class="cm-comment">// → 128052 (Actual code for horse emoji)</span></pre>

<p>متد <code>charCodeAt</code> در جاوااسکریپت به شما یک واحد کد تحویل می دهد نه کد یک کاراکتر کامل. متد <code>codePointAt،</code> که بعدا اضافه شد، کد کامل یونیکد کاراکتر را برمی گرداند. بنابراین می توانیم از این متد برای گرفتن کاراکترهای یک رشته استفاده کنیم. اما آرگومانی که به متد <code>codePointAt</code> ارسال می شود هنوز یک اندیس گرفته‌ شده از دنباله‌ی کدهای واحد است. پس با توجه به آن، برای پیمایش همه‌ی کاراکتر‌های یک رشته، همچنان باید بدانیم که هر کاراکتر یک واحد یا دو واحد کد اشغال کرده است.</p>

<p>در <a href="04_data.html#for_of_loop">فصل پیش</a>، اشاره کردم که حلقه‌ی <bdo><code>for</code>/<code>of</code></bdo>  را همچنین می توان برای رشته‌ها استفاده کرد. شبیه <code>codePointAt</code>، این نوع از حلقه نیز زمانی معرفی شد که همه از مشکلات UTF-16 آگاه بودند. با استفاده از آن برای پیمایش یک رشته، به جای کدهای واحد، کاراکترهای واقعی برگردانده می شوند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_9QIfA1qjtG" href="#c_9QIfA1qjtG" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">roseDragon</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;🌹🐉&quot;</span>;
<span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">char</span> <span class="cm-keyword">of</span> <span class="cm-variable">roseDragon</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">char</span>);
}
<span class="cm-comment">// → 🌹</span>
<span class="cm-comment">// → 🐉</span></pre>

<p>اگر کاراکتری دارید ( که رشته‌ای از یک یا دو واحد کد است)، می توانید از متد <bdo><code>codePointAt(0)</code></bdo> برای گرفتن کد متناظرش استفاده کنید.</p>

<h2><a class="h_ident" id="h_dF/RGkNPy4" href="#h_dF/RGkNPy4" tabindex="-1" role="presentation"></a>تشخیص متن</h2>

<p>تا اینجا یک تابع به نام <code>characterScript</code> به همراه روشی برای پیمایش کاراکترها در اختیار داریم. گام بعدی شمردن کاراکترهایی است که به هر الفبا مربوط می شود. می توان از تابع زیر برای این کار استفاده کرد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_nau/OQcf6J" href="#c_nau/OQcf6J" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">countBy</span>(<span class="cm-def">items</span>, <span class="cm-def">groupName</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">counts</span> <span class="cm-operator">=</span> [];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">item</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">items</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">name</span> <span class="cm-operator">=</span> <span class="cm-variable-2">groupName</span>(<span class="cm-variable-2">item</span>);
    <span class="cm-keyword">let</span> <span class="cm-def">known</span> <span class="cm-operator">=</span> <span class="cm-variable-2">counts</span>.<span class="cm-property">findIndex</span>(<span class="cm-def">c</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">c</span>.<span class="cm-property">name</span> <span class="cm-operator">==</span> <span class="cm-variable-2">name</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">known</span> <span class="cm-operator">==</span> <span class="cm-operator">-</span><span class="cm-number">1</span>) {
      <span class="cm-variable-2">counts</span>.<span class="cm-property">push</span>({<span class="cm-property">name</span>, <span class="cm-property">count</span>: <span class="cm-number">1</span>});
    } <span class="cm-keyword">else</span> {
      <span class="cm-variable-2">counts</span>[<span class="cm-variable-2">known</span>].<span class="cm-property">count</span><span class="cm-operator">++</span>;
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">counts</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">countBy</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>, <span class="cm-number">5</span>], <span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">&gt;</span> <span class="cm-number">2</span>));
<span class="cm-comment">// → [{name: false, count: 2}, {name: true, count: 3}]</span></pre>

<p>تابع <code>countBy</code> به عنوان آرگومان، یک مجموعه (هرچیزی که بتوان به وسیله‌ی <bdo><code>for</code>/<code>of</code></bdo> آن را پیمایش کرد) به همراه تابعی برای گروه‌بندی دریافت می کند. خروجی این تابع، آرایه‌ای از اشیاء است که هر یک معرف یک گروه است و به شما می گوید چه تعداد عنصر در آن گروه پیدا شده است.</p>

<p><a class="p_ident" id="p_0yXQQurvWN" href="#p_0yXQQurvWN" tabindex="-1" role="presentation"></a>این تابع خود از متدی دیگر به نام <code>findIndex</code> استفاده می کند. این متد به شکلی شبیه به <code>indexOf</code> عمل می کند، اما به جای گشتن برای یک مقدار خاص، به دنبال اولین مقداری می گردد که تابع داده شده با آن مقدار true را برمی گرداند. مانند <code>indexOf،</code> اگر عنصری با آن شرایط پیدا نشود، <bdo>-1</bdo> برگردانده می شود.</p>

<p><a class="p_ident" id="p_7fHPkrbqq2" href="#p_7fHPkrbqq2" tabindex="-1" role="presentation"></a>با استفاده از countBy می توانیم تابعی بنویسیم که الفبای یک متن را برای ما مشخص کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_TyAeKAD0HB" href="#c_TyAeKAD0HB" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">textScripts</span>(<span class="cm-def">text</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">scripts</span> <span class="cm-operator">=</span> <span class="cm-variable">countBy</span>(<span class="cm-variable-2">text</span>, <span class="cm-def">char</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">script</span> <span class="cm-operator">=</span> <span class="cm-variable">characterScript</span>(<span class="cm-variable-2">char</span>.<span class="cm-property">codePointAt</span>(<span class="cm-number">0</span>));
    <span class="cm-keyword">return</span> <span class="cm-variable-2">script</span> <span class="cm-operator">?</span> <span class="cm-variable-2">script</span>.<span class="cm-property">name</span> : <span class="cm-string">&quot;none&quot;</span>;
  }).<span class="cm-property">filter</span>(({<span class="cm-def">name</span>}) <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">name</span> <span class="cm-operator">!=</span> <span class="cm-string">&quot;none&quot;</span>);

  <span class="cm-keyword">let</span> <span class="cm-def">total</span> <span class="cm-operator">=</span> <span class="cm-variable-2">scripts</span>.<span class="cm-property">reduce</span>((<span class="cm-def">n</span>, {<span class="cm-def">count</span>}) <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">+</span> <span class="cm-variable-2">count</span>, <span class="cm-number">0</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">total</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) <span class="cm-keyword">return</span> <span class="cm-string">&quot;No scripts found&quot;</span>;

  <span class="cm-keyword">return</span> <span class="cm-variable-2">scripts</span>.<span class="cm-property">map</span>(({<span class="cm-def">name</span>, <span class="cm-def">count</span>}) <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">return</span> <span class="cm-string-2">`${</span><span class="cm-variable">Math</span>.<span class="cm-property">round</span>(<span class="cm-variable-2">count</span> <span class="cm-operator">*</span> <span class="cm-number">100</span> <span class="cm-operator">/</span> <span class="cm-variable-2">total</span>)<span class="cm-string-2">}</span><span class="cm-string-2">% ${</span><span class="cm-variable-2">name</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>;
  }).<span class="cm-property">join</span>(<span class="cm-string">&quot;, &quot;</span>);
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">textScripts</span>(<span class="cm-string">'英国的狗说&quot;woof&quot;, 俄罗斯的狗说&quot;тяв&quot;'</span>));
<span class="cm-comment">// → 61% Han, 22% Latin, 17% Cyrillic</span></pre>

<p>تابع بالا ابتدا تعداد کاراکتر‌ها را با نام می شمارد، با استفاده از <code>characterScript</code> به آن‌ها نامی را اختصاص می دهد، و برای کاراکترهایی که جزء هیچ الفبایی محسوب نمی شوند، مقدار <code>“none”</code> را به رشته باز می گرداند. تابع <code>filter</code> تمامی <code>“none”</code> ها را از آرایه‌ی نتیجه حذف می کند، چرا که علاقه ای به این کاراکتر‌ها نداریم.</p>

<p>برای اینکه بتوانیم درصد‌ها را محاسبه کنیم، ابتدا به تعداد همه‌ی کاراکترهایی که به یک الفبا تعلق دارند نیاز داریم، که می توانیم این کار را با <code>reduce</code> انجام دهیم. اگر این اراکترها پیدا نشدند، تابع، یک رشته‌ی مشخص برمی گرداند. در غیر این صورت به وسیله تابع <code>map</code> موارد محاسبه‌شده را به رشته‌هایی مناسب خواندن تبدیل می کند و در آخر به وسیله <code>join</code> آن ها را به هم الحاق می نماید.</p>

<h2><a class="h_ident" id="h_EzvDUHyjs2" href="#h_EzvDUHyjs2" tabindex="-1" role="presentation"></a>خلاصه</h2>

<p>یکی از جنبه‌های عمیقا کاربردی جاوااسکریپت، امکان ارسال مقدارهای تابع به دیگر توابع است. با این ویژگی می توان توابعی برای مدل‌سازی محاسباتی نوشت که دارای بخشی &quot;باز&quot; می باشند. کدی که این توابع را فراخوانی می کند، می تواند این فضای باز را به وسیله‌ی مقدار‌های تابع تکمیل کند.</p>

<p>آرایه‌ها مجموعه‌ی مفیدی از توابع دست بالا را فراهم می سازند. می توانید از <code>forEach</code> برای پیمایش عناصر یک آرایه استفاده کنید. برای برگرداندن یک آرایه‌ی جدید با عناصری که شرایط خاصی دارند، متد <code>filter</code> مفید است. برای تغییر شکل عناصر یک آرایه به وسیله‌ی یک تابع، می توانید از <code>map</code> استفاده کنید. <code>reduce</code> برای ترکیب همه‌ی عناصر یک آرایه و ساخت یک مقدار واحد، کاربرد دارد. متد <code>some</code> بررسی می کند که آیا حداقل یک عنصر در آرایه با شرط تابع ورودی تطبیق می کند  و <code>findIndex</code> موقعیت اولین عنصری که با شرط ارسالی تطبیق دارد را بر می گرداند.</p>

<h2><a class="h_ident" id="h_ggOFdVwDCk" href="#h_ggOFdVwDCk" tabindex="-1" role="presentation"></a>تمرین‌ها</h2>

<h3><a class="i_ident" id="i_1XCp3Vm6bW" href="#i_1XCp3Vm6bW" tabindex="-1" role="presentation"></a>یک‌سطح کردن آرایه</h3>

<p>با استفاده از متد <code>reduce</code> و ترکیب آن با <code>concat،</code> آرایه‌ای از آرایه‌ها را گرفته و آرایه‌ی تختی (مسطح) بسازید که شامل همه‌ی عناصر آرایه‌های اصلی باشد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_I+o+qLGLXB" href="#c_I+o+qLGLXB" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">arrays</span> <span class="cm-operator">=</span> [[<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>], [<span class="cm-number">4</span>, <span class="cm-number">5</span>], [<span class="cm-number">6</span>]];
<span class="cm-comment">// Your code here.</span>
<span class="cm-comment">// → [1, 2, 3, 4, 5, 6]</span></pre>

<h3><a class="i_ident" id="i_rU7fdIk3WU" href="#i_rU7fdIk3WU" tabindex="-1" role="presentation"></a>شبیه‌سازی حلقه</h3>

<p><a class="p_ident" id="p_fLbvuYully" href="#p_fLbvuYully" tabindex="-1" role="presentation"></a>تابع رده‌بالایی به نام <code>loop</code> بنویسید که کاری مشابه یک حلقه‌ی <code>for</code> انجام دهد. این تابع به عنوان آرگومان، یک مقدار، تابع شرط، تابع به‌روز‌رسانی و بدنه‌ی یک تابع را دریافت می کند. در هر تکرار، ابتدا، تابع شرط را بر روی مقدار فعلی حلقه اجرا می کند و در صورتی که false را تولید کرد متوقف می شود. سپس بدنه تابع ارسالی را با دادن مقدار فعلی به آن، اجرا می نماید. در نهایت برای ایجاد یک مقدار جدید، تابع به‌روزرسانی را فراخوانی کرده و از ابتدا شروع می کند.</p>

<p>هنگام تعریف تابع، می توانید از یک حلقه‌ی معمولی برای پیاده‌سازی حلقه‌ی اصلی استفاده کنید.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Fv1rc97GEM" href="#c_Fv1rc97GEM" tabindex="-1" role="presentation"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">loop</span>(<span class="cm-number">3</span>, <span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0</span>, <span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>, <span class="cm-variable">console</span>.<span class="cm-property">log</span>);
<span class="cm-comment">// → 3</span>
<span class="cm-comment">// → 2</span>
<span class="cm-comment">// → 1</span></pre>

<h3><a class="i_ident" id="i_9HYBCnRNia" href="#i_9HYBCnRNia" tabindex="-1" role="presentation"></a>همه‌چیز</h3>

<p>مشابه متد <code>some،</code> آرایه‌ها متدی به نام <code>every</code> نیز دارند. این متد زمانی <code>true</code> برمی گرداند که تابع داده شد برای <em>همه‌ی</em> عناصر آرایه، مقدار <code>true</code> را تولید کند. به نوعی، <code>some</code> نسخه‌ای از عملگر <code>||</code> است که روی آرایه‌ها عمل می کند و <code>every</code> شبیه به عملگر <code>&amp;&amp;</code> کار می کند.</p>

<p>متد <code>every</code> را به عنوان یک تابع پیاده سازی کنید که یک آرایه و یک تابع دریافت می کند. دو نسخه‌ از این تابع را بنویسید، یک نسخه با استفاده از حلقه و دیگری با استفاده از متد <code>some</code>.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_NludaTWDls" href="#c_NludaTWDls" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">every</span>(<span class="cm-def">array</span>, <span class="cm-def">test</span>) {
  <span class="cm-comment">// Your code here.</span>
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">every</span>([<span class="cm-number">1</span>, <span class="cm-number">3</span>, <span class="cm-number">5</span>], <span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">&lt;</span> <span class="cm-number">10</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">every</span>([<span class="cm-number">2</span>, <span class="cm-number">4</span>, <span class="cm-number">16</span>], <span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">&lt;</span> <span class="cm-number">10</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">every</span>([], <span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">&lt;</span> <span class="cm-number">10</span>));
<span class="cm-comment">// → true</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_iYkMFxHxnk" href="#p_iYkMFxHxnk" tabindex="-1" role="presentation"></a>مانند عملگر <code>&amp;&amp;</code>، متد <code>every</code> به محض اینکه به موردی برخورد کند که با شرط تطبیق ندارد، ارزیابی دیگر عناصر را متوقف می کند. بنابراین در نسخه‌ی مبتنی بر حلقه، می توان با مشاهده‌ی خروجی false تابع روی یک عنصر، از حلقه به وسیله‌ی <code>break</code> یا <code>return</code> خارج شد. اگر حلقه بدون برخورد با چنین عنصری به انتهای خود برسد، می دانیم که همه‌ی عناصر مطابق تابع شرط بوده اند و می توانیم true را برگردانیم.</p>

<p>برای ساخت <code>every‍‍</code> با استفاده از <code>some</code>، می توانیم از قوانین <em>دمورگان</em> استفاده کنیم، که براساس آن‌، <bdo><code>a &amp;&amp; b</code></bdo> برابر است با <bdo><code>!(!a || !b)</code></bdo>. می توان آن را به آرایه‌ها تعمیم داد به این صورت که همه‌ی عناصر در آرایه با شرط تطبیق خواهند داشت اگر عنصری در آرایه نباشد که تطبیق نداشته باشد.</p>

</div></div>

<h3><a class="i_ident" id="i_csMsyLJrpx" href="#i_csMsyLJrpx" tabindex="-1" role="presentation"></a>جهت نوشتن غالب</h3>

<p>تابعی بنویسید که بتواند جهت نوشت غالب یک متن را محاسبه کند. به یاد دارید که هر شیء الفبا خاصیتی به نام <code>direction</code> دارد که می تواند <code>“ltr”</code> (چپ به راست)، <code>“rtl”</code> (راست به چپ)، یا  <code>“ttb”</code> (بالا به پایین) باشد.</p>

<p>جهت نوشتاری غالب جهتی است که بیشتر کاراکترهایی که الفبای مشخصی دارند، در آن جهت نوشته می شوند. احتمالا دو تابع <code>characterScript</code> و <code>countBy</code> که پیش تر نوشته شده اند، اینجا کاربرد خواهند داشت.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_CNawUvyti3" href="#c_CNawUvyti3" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">dominantDirection</span>(<span class="cm-def">text</span>) {
  <span class="cm-comment">// Your code here.</span>
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dominantDirection</span>(<span class="cm-string">&quot;Hello!&quot;</span>));
<span class="cm-comment">// → ltr</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dominantDirection</span>(<span class="cm-string">&quot;Hey, مساء الخير&quot;</span>));
<span class="cm-comment">// → rtl</span></pre>

<div class="solution"><div class="solution-text">

<p>پاسخ شما ممکن است شباهت زیادی به نیمه‌ی اول مثال <code>textScripts</code> داشته باشد. دوباره باید کاراکترها را با شرطی براساس <code>characterScript</code> بشمارید و سپس بخشی از نتیجه که الفبای مشخصی ندارند را فیلتر کنید.</p>

<p>پیدا کردن جهت نوشته بر اساس شمارش بیشترین کاراکتر را می توان با متد <code>reduce</code> انجام داد. اگر راه حل به ذهن‌تان نرسید، به مثالی که پیش‌تر در این فصل در مورد استفاده از <code>reduce</code> برای پیدا کردن الفبایی با بیشترین حروف مراجعه کنید.</p>

</div></div><nav><a href="04_data.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="06_object.html" title="next chapter">▶</a></nav>
</article>
