<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>توابع :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 3;</script><script>var clicky_site_ids = clicky_site_ids || []; clicky_site_ids.push(101171577);</script>
  <script async src="//static.getclicky.com/js"></script>

</head>

<article>
<nav><a href="02_program_structure.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="04_data.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>فصل 3</span>توابع</h1>

<blockquote>

<p><a class="p_ident" id="p_2jmj7l5rSw" href="#p_2jmj7l5rSw" tabindex="-1" role="presentation"></a>مردم تصور می‌کنند که دانش و مهارت کامپیوتر مخصوص نابغه‌ها است اما واقعیت برعکس است، فقط افراد زیادی روی ساخته‌های یکدیگر کار می‌کنند، مثل دیواری که از سنگ‌های کوچک ساخته می‌شود.</p>

<footer>Donald Knuth</footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_3.jpg" alt="Picture of fern leaves with a fractal shape"></figure>

<p>توابع یکی از پایه‌های اصلی برنامه‌نویسی به زبان جاوااسکریپت می‌باشند. مفهوم گذاشتن بخشی از برنامه درون یک مقدار، کاربردهای بسیاری دارد. می‌توان از این مفهوم برای ساختاردهی به برنامه‌های بزرگتر استفاده کرد، از تکرار پرهیز نمود، به زیربرنامه ها نام اختصاص داد و آن‌ها را به شکلی مستقل مجزا کرد.</p>

<p>استفاده از توابع برای تعریف واژه‌ی جدید، واضح ترین کاربرد آن‌ها می‌باشد. خلق واژه‌ای جدید در یک نثر، معمولا سبک خوبی نیست اما در برنامه‌نویسی این کار اجتناب ناپذیر است.</p>

<p><a class="p_ident" id="p_9nkc20pB5J" href="#p_9nkc20pB5J" tabindex="-1" role="presentation"></a>به طور معمول، انگلیسی زبانان بزرگسال در دامنه‌ی واژگانشان حدود 20,000 کلمه دارند. زبان‌های برنامه‌نویسی کمی وجود دارند که 20,000 دستور از پیش تعریف شده داشته باشند. البته این دستورات یا واژگانی که در دسترس هستند نیز با دقت تعریف می‌شوند که در نتیجه انعطاف کمتری نسبت به زبان‌های بشری دارند. بنابراین، معمولا نیاز است تا مفاهیم جدیدی را برای اجتناب از تکرار بی‌مورد تعریف کنیم.</p>

<h2><a class="h_ident" id="h_/hCfR38CAR" href="#h_/hCfR38CAR" tabindex="-1" role="presentation"></a>تعریف یک تابع</h2>

<p>تعریف یک تابع همان تعریف عادی یک انتساب (متغیر) است با این تفاوت که مقداری که به متغیر اختصاص داده می‌شود، از جنس تابع است. به عنوان مثال، کد پیش رو متغیر <code>square</code> را تعریف می‌کند که به تابعی ارجاع می دهد که مربع عدد داده شده را تولید می‌کند:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_JW7vLBZMWv" href="#c_JW7vLBZMWv" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">square</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">x</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>;
};

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">square</span>(<span class="cm-number">12</span>));
<span class="cm-comment">// → 144</span></pre>

<p>یک تابع را می‌توان به وسیله‌ی یک عبارت که با کلمه‌ی کلیدی <code>function</code> شروع می‌شود ایجاد کرد. توابع دارای مجموعه‌ای از <em>پارامترها</em> (در مثال بالا فقط <code>x</code>) و یک <em>بدنه</em> می‌باشند. بدنه خود حاوی دستوراتی است که در صورت فراخوانی تابع اجرا می‌شوند. بدنه‌ی تابع باید همیشه درون کروشه‌ها قرار گیرد حتی زمانی که فقط حاوی یک دستور است ( مانند مثال قبل ).</p>

<p>یک تابع می‌تواند چندین پارامتر داشته باشد یا هیچ پارامتری نداشته باشد. در مثال پیش رو، تابع <code>makeNoise</code> هیچ پارامتری ندارد در حالیکه تابع <code>power</code> دو پارامتر دارد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_8fTeYA4ABW" href="#c_8fTeYA4ABW" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">makeNoise</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Pling!&quot;</span>);
};

<span class="cm-variable">makeNoise</span>();
<span class="cm-comment">// → Pling!</span>

<span class="cm-keyword">const</span> <span class="cm-def">power</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">base</span>, <span class="cm-def">exponent</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">count</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">exponent</span>; <span class="cm-variable-2">count</span><span class="cm-operator">++</span>) {
    <span class="cm-variable-2">result</span> <span class="cm-operator">*=</span> <span class="cm-variable-2">base</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
};

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>(<span class="cm-number">2</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → 1024</span></pre>

<p>بعضی توابع مقداری را برمی گردانند،‌ مانند تابع <code>power</code> و <code>square</code>، و بعضی توابع مانند <code>makeNoise</code> فقط اثر جانبی تولید می کنند و مقداری را باز نمی گردانند. دستوری به نام <code>return</code> مسئول بازگرداندن یک مقدار از تابع است. زمانی که برنامه به این دستور می‌رسد، به سرعت از تابع فعلی خارج شده و مقدار  “برگردانده شده” را به قسمتی از برنامه که تابع در آنجا فراخوانی شده، ارسال می‌کند. استفاده از دستور <code>return</code> بدون عبارتی بعد از آن ، باعث می‌شود که تابع مقدار <code>undefined</code> را برگرداند. توابعی که اصلا دستور <code>return</code> را ندارند مانند <code>makeNoise</code> نیز مقدار <code>undefined</code> را برمی گردانند.</p>

<p>پارامترها در توابع درست شبیه به متغیرهای عادی رفتار می کنند اما مقدار اولیه آن‌ها توسط <em>فراخواننده</em> تابع مقداردهی می‌شود نه کدی که در بدنه تابع نوشته می‌شود.</p>

<h2><a class="h_ident" id="h_vMmbes/Jc3" href="#h_vMmbes/Jc3" tabindex="-1" role="presentation"></a>متغیرها و قلمرو‌ی آن - Scope</h2>

<p><a class="p_ident" id="p_6/Y7S6OhW/" href="#p_6/Y7S6OhW/" tabindex="-1" role="presentation"></a>هر متغیری دارای یک <em>قلمروی</em> (scope) دسترسی است که عبارت است از بخشی از برنامه که در آن، متغیر قابل دسترس و مشاهده است. برای متغیرهایی که بیرون از یک تابع یا یک بلاک تعریف شده اند، این قلمرو شامل کل برنامه می‌شود – می‌توانید به این متغیرها در هرجای برنامه دسترسی داشته باشید. به این متغیرها متغیرهای <em>سراسری</em> (global) گفته می‌شود.</p>

<p>اما متغیرهایی که برای پارامترهای توابع ایجاد می‌شوند یا آن‌هایی که درون یک تابع تعریف می‌شوند، فقط در درون همان تابع قابل ارجاع می‌باشند، به همین علت به آن‌ها متغیرهای <em>محلی</em> گفته می‌شود. هر بار که تابعی فراخوانی می‌شود، یک نمونه از این متغیرها ایجاد می‌شود. این کار باعث می‌شود که توابع به نوعی نسبت به هم مجزا (‌ایزوله) شوند - هر فراخوانی تابع در فضای اختصاصی خودش عمل می‌کند (محیط محلی خودش) و معمولا می‌توان این نحوه‌ی عملکرد را از برنامه متوجه شد و نیازی نیست جزئیات مرتبط با‌ آن را در محیط اجرایی بدانیم.</p>

<p><a class="p_ident" id="p_nN2mfe0/JY" href="#p_nN2mfe0/JY" tabindex="-1" role="presentation"></a>متغیرهایی که با <code>let</code> یا <code>const</code> تعریف می‌شوند در واقع نسبت به <em>بلاکی</em> که درون آن تعریف شده اند محلی هستند (متعلق به همان بلاک می‌باشند)، بنابراین اگر یکی از آن‌ها را درون یک حلقه تعریف کنید، کدی که قبل و بعد از حلقه قرار گرفته نمی‌تواند آن را “ببیند”. در نسخه‌های قبل از 2015 جاوااسکریپت، فقط توابع بودند که می‌توانستند قلمرو یا حوزه‌ی جدیدی ایجاد کنند، بنابراین متغیرهای قدیمی که با <code>var</code> تعریف می شدند، در تابعی که در آن تعریف شده بودند، دیده می شدند. اگر هم درون یک تابع نبودند، در سراسر برنامه در دسترس بودند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_d7ecKvF5xD" href="#c_d7ecKvF5xD" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>;
<span class="cm-keyword">if</span> (<span class="cm-atom">true</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-number">20</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">z</span> <span class="cm-operator">=</span> <span class="cm-number">30</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">y</span> <span class="cm-operator">+</span> <span class="cm-variable">z</span>);
  <span class="cm-comment">// → 60</span>
}
<span class="cm-comment">// y is not visible here</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">x</span> <span class="cm-operator">+</span> <span class="cm-variable">z</span>);
<span class="cm-comment">// → 40</span></pre>

<p>هر قلمرو می‌تواند قلمروی پیرامونش را ببیند، مثلا در برنامه‌ی بالا، متغیر <code>x</code> در درون بلاک قابل مشاهده است. یک استثناء در اینجا زمانی رخ می دهد که چندین متغیر با یک نام وجود داشته باشد که در این صورت، کد برنامه می‌تواند درونی‌ترین مورد را ببیند. به عنوان مثال، در تابع <code>halve</code> مثال پایین، زمانی که کد درون تابع به متغیر <code>n</code> اشاره می‌کند، متغیر <code>n</code> <em>خود</em> تابع استفاده می‌شود نه متغیر سراسری <code>n</code>.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_5g6POeoiQv" href="#c_5g6POeoiQv" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">halve</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">n</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">n</span> <span class="cm-operator">/</span> <span class="cm-number">2</span>;
};

<span class="cm-keyword">let</span> <span class="cm-def">n</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">halve</span>(<span class="cm-number">100</span>));
<span class="cm-comment">// → 50</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">n</span>);
<span class="cm-comment">// → 10</span></pre>

<h3 id="scoping"><a class="i_ident" id="i_6kT7sc0PGc" href="#i_6kT7sc0PGc" tabindex="-1" role="presentation"></a>قلمروی تو در تو</h3>

<p>جاوااسکریپت تنها بین متغیرهای <em>سراسری</em> و <em>محلی</em> تفاوت قائل نمی‌شود. می‌توان توابع و بلاک‌ها را نیز به شکل تودرتو ایجاد کرد که باعث ایجاد درجه‌های مختلفی از محلی بودن می‌گردد.</p>

<p>به عنوان مثال، این تابع – که مواد لازم برای تهیه حمص (نوعی غذا) را برمی گرداند – تابعی دیگر در درون خود دارد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_cOSfyI1GsW" href="#c_cOSfyI1GsW" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">hummus</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">factor</span>) {
  <span class="cm-keyword">const</span> <span class="cm-def">ingredient</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">amount</span>, <span class="cm-def">unit</span>, <span class="cm-def">name</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">ingredientAmount</span> <span class="cm-operator">=</span> <span class="cm-variable-2">amount</span> <span class="cm-operator">*</span> <span class="cm-variable-2">factor</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">ingredientAmount</span> <span class="cm-operator">&gt;</span> <span class="cm-number">1</span>) {
      <span class="cm-variable-2">unit</span> <span class="cm-operator">+=</span> <span class="cm-string">&quot;s&quot;</span>;
    }
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">ingredientAmount</span><span class="cm-string-2">}</span> <span class="cm-string-2">${</span><span class="cm-variable-2">unit</span><span class="cm-string-2">}</span> <span class="cm-string-2">${</span><span class="cm-variable-2">name</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  };
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">1</span>, <span class="cm-string">&quot;can&quot;</span>, <span class="cm-string">&quot;chickpeas&quot;</span>);
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">0.25</span>, <span class="cm-string">&quot;cup&quot;</span>, <span class="cm-string">&quot;tahini&quot;</span>);
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">0.25</span>, <span class="cm-string">&quot;cup&quot;</span>, <span class="cm-string">&quot;lemon juice&quot;</span>);
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">1</span>, <span class="cm-string">&quot;clove&quot;</span>, <span class="cm-string">&quot;garlic&quot;</span>);
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">2</span>, <span class="cm-string">&quot;tablespoon&quot;</span>, <span class="cm-string">&quot;olive oil&quot;</span>);
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">0.5</span>, <span class="cm-string">&quot;teaspoon&quot;</span>, <span class="cm-string">&quot;cumin&quot;</span>);
};</pre>

<p>کدی که در تابع <code>ingredient</code> قرار دارد می‌تواند متغیر <code>factor</code> را از تابع بیرونی ببیند. اما متغیرهای محلی‌اش مانند <code>unit</code> یا <code>ingredientAmount</code> توسط تابع بیرونی قابل مشاهده نیستند.</p>

<p><a class="p_ident" id="p_W83hGvOOqb" href="#p_W83hGvOOqb" tabindex="-1" role="presentation"></a>مجموعه‌ی متغیرهایی که در درون یک بلاک قابل رویت می‌باشند بستگی به مکان بلاک در متن برنامه دارند. هر قلمروی محلی همچنین می‌تواند قلمرو‌های محلی ای که آن را در بر گرفته اند را ببیند و همه‌ی قلمروها می‌تواند قلمرو سراسری را ببینند. این روش رویت پذیری متغیر را <em>حوزه‌بندی لغوی</em> (Lexical Scoping) می نامند.</p>

<h2><a class="h_ident" id="h_X2UZ4UkAI8" href="#h_X2UZ4UkAI8" tabindex="-1" role="presentation"></a>استفاده از توابع به عنوان مقدار</h2>

<p>متغیری که به یک تابع منتسب شده است، معمولا به سادگی، نقش یک نام را برای قطعه‌ای از برنامه، بازی می‌کند. این گونه متغیرها یک بار تعریف شده و دیگر تغییری نمی یابند. این امر ممکن است باعث شود که نام تابع با خود تابع اشتباه گرفته شود.</p>

<p>اما این دو متفاوتند. یک مقدار تابع می‌تواند همه‌ی چیزهایی که دیگر مقدارها، انجام می‌دهند را انجام دهد – به جز فراخوانی معمولی، می‌توانید از آن‌ها در عبارت‌ها استفاده کنید. می‌توان مقدار تابع را در متغیر جدیدی ذخیره کرد، به عنوان آرگومان به یک تابع فرستاد و موارد مشابه. همچنین متغیری که یک تابع را نگه داری می‌کند هنوز فقط یک متغیر عادی است و می‌توان مقدار جدیدی به آن اختصاص داد البته اگر به عنوان ثابت تعریف نشده باشد. مثلا:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_SZ7MmN0oGC" href="#c_SZ7MmN0oGC" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">launchMissiles</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-variable">missileSystem</span>.<span class="cm-property">launch</span>(<span class="cm-string">&quot;now&quot;</span>);
};
<span class="cm-keyword">if</span> (<span class="cm-variable">safeMode</span>) {
  <span class="cm-variable">launchMissiles</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {<span class="cm-comment">/* do nothing */</span>};
}</pre>

<p>در <a href="05_higher_order.html">فصل 5</a>، در مورد کارهای جالبی که می‌توان به وسیله ارسال توابع به عنوان مقدار به دیگر توابع انجام داد بحث خواهیم کرد.</p>

<h2><a class="h_ident" id="h_Age4dw3mWK" href="#h_Age4dw3mWK" tabindex="-1" role="presentation"></a>استفاده از روش اعلان تابع</h2>

<p><a class="p_ident" id="p_u7kwzEJlB+" href="#p_u7kwzEJlB+" tabindex="-1" role="presentation"></a>یک روش کوتاه‌تر برای تعریف  تابع وجود دارد. اگر در ابتدای یک دستور (statement)، کلمه‌ی کلیدی <code>function</code> استفاده شود، معنای دیگری خواهد داشت.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_4uHhsg+h7S" href="#c_4uHhsg+h7S" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">square</span>(<span class="cm-def">x</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>;
}</pre>

<p>این روش، تعریف تابع با <em>اعلان</em> می‌باشد. این دستور متغیری به نام <code>square</code> را تعریف کرده و آن را به تابع داده شده انتساب می‌دهد. تعریف تابع به این روش اندکی ساده تر به نظر می‌رسد و لازم نیست در این روش، بعد از تعریف تابع از نقطه ویرگول استفاده شود.</p>

<p>در این روش تعریف تابع نکته‌ی ظریفی وجود دارد که لازم است توجه شود.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_41Tuq8c/gg" href="#c_41Tuq8c/gg" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;The future says:&quot;</span>, <span class="cm-variable">future</span>());

<span class="cm-keyword">function</span> <span class="cm-def">future</span>() {
  <span class="cm-keyword">return</span> <span class="cm-string">&quot;You'll never have flying cars&quot;</span>;
}</pre>

<p>کد بالا به درستی کار می‌کند اگرچه تعریف تابع پایین تر از خطی که آن را فراخوانی می‌کند اتفاق افتاده است. دلیل این اتفاق این است که اعلان‌های توابع در جاوااسکریپت، به عنوان بخشی از جریان کنترل بالا به پایین عادی برنامه محسوب نمی‌شوند. به طور مفهومی به بالای قلمروی خودشان منتقل می‌شوند و می‌توان از آن‌ها در همه‌ی کدهای موجود در آن قلمرو استفاده کرد. این ویژگی گاهی کاربرد دارد چون این آزادی را به ما می دهد تا به شکلی کدها را مرتب کنیم که بهتر سازماندهی بشوند بدون اینکه نگران این باشیم که توابع ما حتما قبل از محل فراخوانی‌شان تعریف شده باشند.</p>

<h2><a class="h_ident" id="h_YYXqCm3JGE" href="#h_YYXqCm3JGE" tabindex="-1" role="presentation"></a>Arrow functions - توابع پیکانی</h2>

<p>روش سومی هم برای تعریف توابع وجود دارد، که با روش‌های قبلی خیلی متفاوت‌ به نظر می‌رسد. به جای استفاده از کلیدواژه‌ی <code>function</code> از یک پیکان <bdo>(<code>=&gt;</code>)</bdo> که از علامت مساوی و بزرگتر تشکیل شده است استفاده می‌شود. ( نباید با عملگر بزرگتر-یا-مساوی-از اشتباه گرفته شود، که به شکل <bdo><code>&gt;=</code></bdo> نوشته می‌شود)</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_4WdKJKvocO" href="#c_4WdKJKvocO" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">power</span> <span class="cm-operator">=</span> (<span class="cm-def">base</span>, <span class="cm-def">exponent</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">count</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">exponent</span>; <span class="cm-variable-2">count</span><span class="cm-operator">++</span>) {
    <span class="cm-variable-2">result</span> <span class="cm-operator">*=</span> <span class="cm-variable-2">base</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
};</pre>

<p>کاراکتر پیکان درست بعد از لیستی از پارامترها می آید که <em>بعد</em> از آن بدنه‌ی تابع خواهد آمد. می‌توان به نوعی این طور تفسیرش کرد که ” این ورودی (این پارامتر‌ها)، این نتیجه ( بدنه‌ی تابع‌ ) را تولید خواهد کرد”.</p>

<p>زمانی که تنها یک پارامتر وجود دارد، می‌توانید از پرانتز صرف نظر کنید. اگر بدنه‌ی تابع فقط شامل یک عبارت است، نه یک بلاک که توسط کروشه‌ها محصور شده، آن عبارت توسط تابع برگردانده می‌شود. بنابراین هر دو روش تعریف تابع <code>square</code> در زیر، کار مشابهی را انجام می‌دهند:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_VIDIsvgTjA" href="#c_VIDIsvgTjA" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">square1</span> <span class="cm-operator">=</span> (<span class="cm-def">x</span>) <span class="cm-operator">=&gt;</span> { <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>; };
<span class="cm-keyword">const</span> <span class="cm-def">square2</span> <span class="cm-operator">=</span> <span class="cm-def">x</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>;</pre>

<p><a class="p_ident" id="p_2jbaADpQVe" href="#p_2jbaADpQVe" tabindex="-1" role="presentation"></a>زمانی که یک تابع پیکانی (arrow function) فاقد پارامتر است، لیست پارامترهایش به صورت یک جفت پرانتز خالی نوشته می‌شود.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_VfJZoQnqTl" href="#c_VfJZoQnqTl" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">horn</span> <span class="cm-operator">=</span> () <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Toot&quot;</span>);
};</pre>

<p>نمی‌توان دلیل محکمی برای وجود نیاز به هر دو نوع تعریف تابع (روش پیکانی و معمول) ، پیدا کرد. از موارد جزئی که بگذریم ( که در <a href="06_object.html">فصل 6</a> به آن‌ها می پردازیم)، هر دوی آن‌ها کار یکسانی را انجام می‌دهند. روش پیکانی در نسخه‌ی 2015 به زبان اضافه شد؛ بیشتر به این خاطر که بتوان توابع را به شکل کوتاه‌تر و خلاصه نوشت و از درازنویسی پرهیز کرد. در <a href="05_higher_order.html">فصل 5</a> از آن‌ها زیاد استفاده خواهیم کرد.</p>

<h2 id="stack"><a class="h_ident" id="h_tB5d//rrwc" href="#h_tB5d//rrwc" tabindex="-1" role="presentation"></a>پشته‌ی فراخوانی توابع</h2>

<p>جریان کنترل برنامه در توابع اندکی پیچیده‌تر است. بجاست تا نگاهی دقیق تر به نحوه‌ی جریان کنترل در توابع بیاندازیم. در اینجا برنامه‌ی ساده ای داریم که چند فراخوانی تابع دارد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_vruWG+bXUz" href="#c_vruWG+bXUz" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">greet</span>(<span class="cm-def">who</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Hello &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">who</span>);
}
<span class="cm-variable">greet</span>(<span class="cm-string">&quot;Harry&quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Bye&quot;</span>);</pre>

<p><a class="p_ident" id="p_vx8FzaEQVq" href="#p_vx8FzaEQVq" tabindex="-1" role="presentation"></a>اجرای این برنامه به طور کلی به این شکل خواهد بود: فراخوانی تابع <code>greet</code> باعث می‌شود که کنترل برنامه به شروع بدنه‌ی آن تابع (خط 2) بپرد. تابع <code>console.log</code> (که تابعی از پیش ساخته شده در مرورگر است) را فراخوانی می‌کند، که کنترل را در دست گرفته، کارش را انجام می دهد و دوباره کنترل را به خط 2 بازمی گرداند. سپس به انتهای تابع <code>greet</code> می‌رسد بنابراین به جایی که در ابتدا فراخوانی شده بود باز می گردد، خط 4. خط بعدی دوباره <code>console.log</code> را فراخوانی می‌کند. بعد از آن، برنامه به پایان خود می‌رسد.</p>

<p>می‌توانیم این جریان کنترل را به صورت نمادین به این صورت نشان دهیم:</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_sK38O0sD4t" href="#c_sK38O0sD4t" tabindex="-1" role="presentation"></a>not in function
   in greet
        in console.log
   in greet
not in function
   in console.log
not in function</pre>

<p>به دلیل اینکه تابع پس از اجرا باید به نقطه‌ای که از آن‌جا فراخوانی شده است بازگردد، کامپیوتر باید مکانی از برنامه که تابع از آنجا فراخوانی شده است را به خاطر داشته باشد. در یک مورد، <code>console.log</code>،  پس از اجرا باید به تابع <code>greet</code> برگردد و در مورد بعدی به انتهای برنامه بر می گردد.</p>

<p><a class="p_ident" id="p_7Ccns7cfB2" href="#p_7Ccns7cfB2" tabindex="-1" role="presentation"></a>به جایی از کامپیوتر که این محل یا زمینه (context) در آن ذخیره می‌شود، <em>پشته‌ی فراخوانی</em> می گویند. هر بار که تابعی فراخوانی می‌شود، محل فعلی فراخوانی در بالای این “پشته” قرار می‌گیرد. زمانی که اجرای تابع تمام می‌شود، عنصر بالای پشته را از پشته حذف می‌کند و از آن محل برای ادامه‌ی اجرای برنامه استفاده می‌کند.</p>

<p><a class="p_ident" id="p_YHNeQouJ8W" href="#p_YHNeQouJ8W" tabindex="-1" role="presentation"></a>ذخیره‌ کردن این پشته نیاز به فضایی در حافظه‌ی کامپیوتر دارد. در صورت رشد بیش از اندازه پشته، کامپیوتر با مشکل روبرو شده و پیغام “out of stack space” یا “too much recursion” را تولید می‌کند. کدی که در ادامه می آید این موضوع را بیشتر باز می‌کند. در این مثال کامپیوتر با مسئله‌ی بسیار مشکلی روبرو می‌شود که موجب می‌شود به طور بی نهایت بین دو تابع گیر بیفتد. اگر محدودیت حافظه‌ برای پشته نبود، احتمالا اجرای این برنامه بی نهایت می شد. اما در واقعیت، ما با کمبود فضا روبرو می شویم، یا اینکه پشته از کار خواهد افتاد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_fZaWglCohr" href="#c_fZaWglCohr" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">chicken</span>() {
  <span class="cm-keyword">return</span> <span class="cm-variable">egg</span>();
}
<span class="cm-keyword">function</span> <span class="cm-def">egg</span>() {
  <span class="cm-keyword">return</span> <span class="cm-variable">chicken</span>();
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">chicken</span>() <span class="cm-operator">+</span> <span class="cm-string">&quot; came first.&quot;</span>);
<span class="cm-comment">// → ??</span></pre>

<h2><a class="h_ident" id="h_hQkARX0UIY" href="#h_hQkARX0UIY" tabindex="-1" role="presentation"></a>آرگومان‌های اختیاری</h2>

<p>کد مثال زیر معتبر است و بدون هیچ مشکلی کار می‌کند:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_IckdVt0tqA" href="#c_IckdVt0tqA" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">square</span>(<span class="cm-def">x</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>; }
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">square</span>(<span class="cm-number">4</span>, <span class="cm-atom">true</span>, <span class="cm-string">&quot;hedgehog&quot;</span>));
<span class="cm-comment">// → 16</span></pre>

<p>تابع <code>square</code> را فقط با یک پارامتر تعریف کردیم. اما زمانی که به شکل بالا با سه پارامتر آن را فراخوانی می کنیم، با خطایی روبرو نمی شویم. این تابع به جز آرگومان اول از دیگر آرگومان‌ها صرف نظر می‌کند و مربع عدد پارامتر اول را حساب می‌کند.</p>

<p>جاوااسکریپت نسبت به تعداد آرگومان‌های دریافتی، بسیار روشن فکرانه عمل می‌کند. اگر آرگومان‌های بیشتری نسبت به آنچه از قبل تعریف شده است ارسال نمایید، به سادگی از آن‌ها چشم پوشی می‌کند. اگر آرگومان کمتری ارسال کنید، به آرگومان‌هایی که مقداردهی نشده اند مقدار <code>undefined</code> را اختصاص می دهد.</p>

<p>جنبه‌ی منفی این کار این است که ممکن است که شما ناخواسته و تصادفی تعداد اشتباهی آرگومان را به تابع ارسال کنید و اصلا متوجه آن هم نشوید.</p>

<p>و جنبه مثبت این است که می‌توان با استفاده از آن به یک تابع اجازه داد که با آرگومان‌های متعدد و متفاوتی فراخوانی شود. به عنوان مثال، تابع <code>minus</code> که در ادامه می آید سعی می‌کند که عملگر <code>-</code> را با عمل کردن روی یک یا دو آرگومان شبیه سازی کند:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_8zGcY0SKdo" href="#c_8zGcY0SKdo" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">minus</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">b</span> <span class="cm-operator">===</span> <span class="cm-atom">undefined</span>) <span class="cm-keyword">return</span> <span class="cm-operator">-</span><span class="cm-variable-2">a</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">-</span> <span class="cm-variable-2">b</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">minus</span>(<span class="cm-number">10</span>));
<span class="cm-comment">// → -10</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">minus</span>(<span class="cm-number">10</span>, <span class="cm-number">5</span>));
<span class="cm-comment">// → 5</span></pre>

<p id="power">اگر بعد از نوشتن پارامتر، علامت <code>=</code> قرار داده و عبارتی را بنویسید، مقدار آن عبارت در صورتی که آرگومان ارسال نشود، جایگزین  می‌شود.</p>

<p><a class="p_ident" id="p_2kuSN7rMzf" href="#p_2kuSN7rMzf" tabindex="-1" role="presentation"></a>به عنوان مثال، این نسخه از تابع <code>power</code> آرگومان دومش را اختیاری تعریف کرده است. اگر آرگومان دوم را ارسال نکنید یا اینکه مقدار <code>undefined</code> را بفرستید، مقدار پیش‌فرض 2 در نظر گرفته می‌شود و تابع شبیه‌ به تابع <code>square</code> عمل می‌کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_nTMMMpMRLQ" href="#c_nTMMMpMRLQ" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">power</span>(<span class="cm-def">base</span>, <span class="cm-def">exponent</span> <span class="cm-operator">=</span> <span class="cm-number">2</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">count</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">exponent</span>; <span class="cm-variable-2">count</span><span class="cm-operator">++</span>) {
    <span class="cm-variable-2">result</span> <span class="cm-operator">*=</span> <span class="cm-variable-2">base</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>(<span class="cm-number">4</span>));
<span class="cm-comment">// → 16</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>(<span class="cm-number">2</span>, <span class="cm-number">6</span>));
<span class="cm-comment">// → 64</span></pre>

<p>در <a href="04_data.html#rest_parameters">فصل بعد</a>، با روشی آشنا خواهیم شد که به وسیله‌ی آن می‌توان در بدنه تابع به لیست دقیق آرگومان‌های ارسالی دست پیدا کرد. با استفاده از این ویژگی، می‌توانیم در یک تابع به تعداد دلخواه آرگومان دریافت کنیم. مثلا تابع <code>console.log</code> از این ویژگی استفاده می‌کند- همه‌ی مقادیری که به آن داده می‌شود را به خروجی ارسال می‌کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_RvkwVkcUZ7" href="#c_RvkwVkcUZ7" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;C&quot;</span>, <span class="cm-string">&quot;O&quot;</span>, <span class="cm-number">2</span>);
<span class="cm-comment">// → C O 2</span></pre>

<h2><a class="h_ident" id="h_RDU7jRFZ7F" href="#h_RDU7jRFZ7F" tabindex="-1" role="presentation"></a>بستار (closure)</h2>

<p>استفاده از توابع به عنوان مقدار، وقتی با این واقعیت ترکیب می‌شود که متغیرهای محلی با هر بار فراخوانی یک تابع از نو ایجاد می‌شوند، سوال جالبی را به ذهن می آورد. زمانی که آن فراخوانی تابع که موجب ایجاد آن‌ها شده بود، دیگر فعال نیست، برای متغیر‌های محلی چه اتفاقی می افتد؟</p>

<p>کدی که در ادامه می آید مثالی از این مفهوم را نمایش می دهد. تابعی به نام <code>wrapValue</code> را تعریف کرده که درون آن متغیری محلی ایجاد شده است. سپس تابعی را بازمیگرداند که به این متغیر محلی دسترسی داشته و آن را برمی گرداند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_DF70h3opbx" href="#c_DF70h3opbx" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">wrapValue</span>(<span class="cm-def">n</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">local</span> <span class="cm-operator">=</span> <span class="cm-variable-2">n</span>;
  <span class="cm-keyword">return</span> () <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">local</span>;
}

<span class="cm-keyword">let</span> <span class="cm-def">wrap1</span> <span class="cm-operator">=</span> <span class="cm-variable">wrapValue</span>(<span class="cm-number">1</span>);
<span class="cm-keyword">let</span> <span class="cm-def">wrap2</span> <span class="cm-operator">=</span> <span class="cm-variable">wrapValue</span>(<span class="cm-number">2</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">wrap1</span>());
<span class="cm-comment">// → 1</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">wrap2</span>());
<span class="cm-comment">// → 2</span></pre>

<p>این کار مجاز و معتبر است و به خوبی کار می‌کند درست همانطور که انتظارش را دارید – هر دوی نمونه‌های متغیر مورد نظر هنوز قابل دستیابی هستند. این وضعیت مثال خوبی از این واقعیت است که متغیرهای محلی با هر با فراخوانی از نو ایجاد می‌شوند و فراخوانی های مختلف به متغیرهای محلی هر فراخوانی آسیبی نمی رساند.</p>

<p>این ویژگی – امکان رجوع به یک نمونه مشخص یک متغیر محلی در یک قلمروی بسته را – <em>بستار</em> یا کلوژر می نامند. تابعی که به متغیرهای محلی قلمروی پیرامونش ارجاع می دهد،‌ <em>یک</em> بستار یا کلوژر نامیده می‌شود. این رفتار نیاز به در نظر گرفتن طول عمر متغیرها را برطرف می‌کند و راه را برای استفاده‌های خلاقانه از مقدارهای تابع باز می‌کند.</p>

<p>با کمی تغییر می‌توانیم مثال قبل را به روشی برای ایجاد توابعی که عمل ضرب را با یک مقدار دلخواه انجام می‌دهند استفاده کنیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_iIlCVmvMSs" href="#c_iIlCVmvMSs" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">multiplier</span>(<span class="cm-def">factor</span>) {
  <span class="cm-keyword">return</span> <span class="cm-def">number</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">number</span> <span class="cm-operator">*</span> <span class="cm-variable-2">factor</span>;
}

<span class="cm-keyword">let</span> <span class="cm-def">twice</span> <span class="cm-operator">=</span> <span class="cm-variable">multiplier</span>(<span class="cm-number">2</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">twice</span>(<span class="cm-number">5</span>));
<span class="cm-comment">// → 10</span></pre>

<p>نیازی نیست مانند مثال <code>wrapValue</code> به طور صریح متغیر <code>local</code> وجود داشته باشد چون پارامتر یک تابع خود یک متغیر محلی محسوب می‌شود.</p>

<p>درک و فکر کردن به برنامه‌هایی شبیه مثال بالا نیاز به کمی تمرین دارد. یک مدل ذهنی خوب این است که فرض کنید که مقدارهای تابع، هم کد بدنه‌شان را نگه می دارند و هم محیطی که در آن ایجاد می‌شوند. وقتی فراخوانی می‌شوند، بدنه‌ی تابع، محیطی که تابع در آن ایجاد شده را می بیند نه محیطی که در آن فراخوانی می‌شود.</p>

<p><a class="p_ident" id="p_wwW0b1Mdqm" href="#p_wwW0b1Mdqm" tabindex="-1" role="presentation"></a>در مثال، <code>multiplier</code> فراخوانی شده و محیطی را ایجاد کرده است که در آن پارامتر <code>factor</code> به 2 اختصاص داده شده است. مقدار تابعی که برمی گرداند، که در <code>twice</code> ذخیره شده است، محیط را به خاطر می آورد. بنابراین در هنگام فراخوانی، آرگومانش را در 2 ضرب می‌کند.</p>

<h2><a class="h_ident" id="h_d8u9yeE6bu" href="#h_d8u9yeE6bu" tabindex="-1" role="presentation"></a>بازگشتی</h2>

<p>فراخوانی یک تابع توسط خودش امری کاملا قابل قبول است البته تا زمانی که به نحوی انجام شود که باعث سرریز پشته نشود. تابعی که خودش را فراخوانی می‌کند را تابع <em>بازگشتی</em> می نامند. بازگشت این امکان را فراهم می سازد که بعضی توابع را به سبک دیگری بتوان نوشت. به عنوان نمونه، تابع <code>power</code> را به صورت بازگشتی بازنویسی می کنیم:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_agdELfiRGm" href="#c_agdELfiRGm" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">power</span>(<span class="cm-def">base</span>, <span class="cm-def">exponent</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">exponent</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
    <span class="cm-keyword">return</span> <span class="cm-number">1</span>;
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">base</span> <span class="cm-operator">*</span> <span class="cm-variable">power</span>(<span class="cm-variable-2">base</span>, <span class="cm-variable-2">exponent</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>);
  }
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>(<span class="cm-number">2</span>, <span class="cm-number">3</span>));
<span class="cm-comment">// → 8</span></pre>

<p>این روش تقریبا شبیه به روشی است که ریاضی‌دانان &quot;توان&quot; اعداد را تعریف می کنند و احتمالا این مفهوم را نسبت به روش استفاده از حلقه واضح تر بیان می‌کند. این تابع خودش را چندین مرتبه با توان های کوچکتر فراخوانی می‌کند تا به حاصل مجموعه‌ی ضرب‌ها برسد.</p>

<p>اما این روش پیاده‌سازی یک مشکل دارد: در پیاده‌سازی‌های رایج جاوااسکریپت، این روش تقریبا سه برابر کندتر از روش استفاده از حلقه عمل می‌کند. پیمایش یک حلقه‌ی ساده بسیار هزینه‌ی کمتری نسبت به فراخوانی چندباره‌ی یک تابع دارد.</p>

<p>معمای انتخاب بین خوانایی کد و سرعت اجرای بهتر، مساله‌ی جالبی است. می‌توان آن را به عنوان نوعی از مسائل مربوط به انسان پسند بودن و ماشین پسند بودن در نظر گرفت. تقریبا همه‌ی برنامه ها را می‌توان سریع‌تر ساخت اما با بزرگتر کردن و پیچیده کردن آن. برنامه‌نویس باید تصمیمی بر اساس تعادل این دو بگیرد.</p>

<p>در مورد تابع <code>power</code> که پیش تر آمد، روش استفاده از حلقه همچنان نسبتا قابل خواندن و فهمیدن است. زیاد توجیه ندارد که آن را با روش بازگشتی جایگزین کنیم. اگرچه گاهی یک برنامه با گونه‌ای از مفاهیم پیچیده روبرو است که صرف نظر کردن از مقداری سرعت یا کارایی در برابر سرراستی بیشتر گزینه‌ای جذاب به نظر می‌رسد.</p>

<p>نگرانی درباره‌ی سرعت اجرای برنامه می‌تواند شما را از مسئله‌ی اصلی دور کند. هنگام برنامه‌نویسی، مشغول حل مسئله‌ای مشکل هستید و وقتی فاکتور پیچیده‌ی دیگری به طور همزمان شما را نگران کند، از پیش‌روی شما جلوگیری می‌کند.</p>

<p>بنابراین، همیشه در ابتدا کدی را بنویسید که به طور صحیح کار می‌کند و قابل درک است. اگر نگرانید که خیلی کند عمل می‌کند – که معمولا این طور نخواهد بود،‌ چرا که اکثر کدها آن قدر به تعداد بالا اجرا نمی‌شوند که زمان قابل توجهی بگیرند- می‌توانید بعد از اتمام کار، اندازه گیری کرده و در صورت نیاز بهبودش بدهید.</p>

<p>نمی‌توان فرض کرد که همیشه  استفاده از بازگشتی نسبت به حلقه،  کارایی کمتری دارد. بعضی مسائل واقعا به روش بازگشتی بهتر و کاراتر حل می‌شوند. اکثر این مسائل مربوط به پیمایش و پردازش چندین شاخه که هر کدام ممکن است از شاخه‌های دیگر تشکیل شده باشند، می‌شوند.</p>

<p id="recursive_puzzle"><a class="p_ident" id="p_gsxOCL/1VV" href="#p_gsxOCL/1VV" tabindex="-1" role="presentation"></a>به این مسئله توجه کنید: با شروع از عدد 1 و اضافه‌ کردن عدد 5 یا ضرب‌ کردن در عدد 3 به صورت مداوم، بی نهایت عدد جدید می‌توان تولید کرد. چگونه می‌توانید تابعی بنویسید که عددی را گرفته و دنباله‌ای از ضرب و جمع‌هایی که منجر به تولید آن عدد شده اند را برگرداند؟</p>

<p><a class="p_ident" id="p_AyWjzT/sI8" href="#p_AyWjzT/sI8" tabindex="-1" role="presentation"></a>به عنوان مثال، عدد 13 را می‌توان با ضرب 1 در 3 و دو بار افزودن 5 بدست آورد در حالیکه عددی مثل 15 را اصلا نمی‌توان به این شیوه تولید کرد.</p>

<p>راه حل استفاده از روش بازگشتی:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_WGJ7JdCP7T" href="#c_WGJ7JdCP7T" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">findSolution</span>(<span class="cm-def">target</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">find</span>(<span class="cm-def">current</span>, <span class="cm-def">history</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">current</span> <span class="cm-operator">==</span> <span class="cm-variable-2">target</span>) {
      <span class="cm-keyword">return</span> <span class="cm-variable-2">history</span>;
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">current</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">target</span>) {
      <span class="cm-keyword">return</span> <span class="cm-atom">null</span>;
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">return</span> <span class="cm-variable-2">find</span>(<span class="cm-variable-2">current</span> <span class="cm-operator">+</span> <span class="cm-number">5</span>, <span class="cm-string-2">`(${</span><span class="cm-variable-2">history</span><span class="cm-string-2">}</span> <span class="cm-string-2">+ 5)`</span>) <span class="cm-operator">|</span><span class="cm-operator">|</span>
             <span class="cm-variable-2">find</span>(<span class="cm-variable-2">current</span> <span class="cm-operator">*</span> <span class="cm-number">3</span>, <span class="cm-string-2">`(${</span><span class="cm-variable-2">history</span><span class="cm-string-2">}</span> <span class="cm-string-2">* 3)`</span>);
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">find</span>(<span class="cm-number">1</span>, <span class="cm-string">&quot;1&quot;</span>);
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">findSolution</span>(<span class="cm-number">24</span>));
<span class="cm-comment">// → (((1 * 3) + 5) * 3)</span></pre>

<p>توجه داشته باشید که برنامه‌ی بالا لزوما <em>کوتاه‌ترین</em> دنباله‌ی عملیات را پیدا نمی‌کند. هدف تابع فقط پیدا کردن هر دنباله‌ای از عملیات صحیح است.</p>

<p>اگر متوجه چگونگی کارکرد تابع بالا نشدید، نگران نباشید. بیایید با هم آن را بررسی کنیم چرا که تمرین بسیار خوبی برای تفکر بازگشتی است.</p>

<p>تابع درونی <code>find</code> عمل اصلی بازگشتی را انجام می دهد. دو آرگومان می‌گیرد که شامل عدد فعلی و رشته‌ای است که نحوه‌ی رسیدن به عدد را ضبط می‌کند. اگر راه حلی پیدا کرد ، رشته‌ای حاوی دنباله‌ی عملیات تا عدد مورد نظر را بر می گرداند. اگر راه حلی وجود نداشت، مقدار <code>null</code> را بر می گرداند.</p>

<p><a class="p_ident" id="p_ZvedimMnyC" href="#p_ZvedimMnyC" tabindex="-1" role="presentation"></a>برای این کار، تابع یکی از این سه کار را انجام می دهد. اگر عدد فعلی عدد هدف بود، تاریخچه‌ی فعلی (history) به عنوان پاسخ برگردانده می‌شود. اگر عدد فعلی از عدد هدف بزرگتر بود، معنایی ندارد که کاوش بیشتری برای کشف تاریخچه انجام شود زیرا هر عمل جمع یا ضرب عدد را فقط بزرگتر می‌کند بنابراین مقدار <code>null</code> را برمی‌گرداند. در نهایت، اگر هنوز عدد فعلی از عدد هدف کوچکتر باشد، تابع هر دو مسیر ممکن که از عدد فعلی شروع می‌شود را آزمایش می‌کند و این کار را با دوبار فراخوانی خودش، یکبار برای جمع و یکبار برای ضرب انجام می دهد. اگر اولین فراخوانی چیزی به غیر از <code>null</code> را تولید کرد، آن را بر می گرداند. در غیر این صورت، فراخوانی دوم بازگردانده می‌شود – فارغ از اینکه رشته یا <code>null</code> را تولید کند.</p>

<p><a class="p_ident" id="p_vTB6PsMp4Q" href="#p_vTB6PsMp4Q" tabindex="-1" role="presentation"></a>برای درک بهتر نحوه‌ی عملکرد تابع اجازه دهید به همه‌ی فراخوانی‌های <code>find</code> که برای پیدا کردن جواب مساله برای عدد 13 اتفاق می افتد نگاهی بیاندازیم.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_KtyfRslIz2" href="#c_KtyfRslIz2" tabindex="-1" role="presentation"></a>find(1, &quot;1&quot;)
  find(6, &quot;(1 + 5)&quot;)
    find(11, &quot;((1 + 5) + 5)&quot;)
      find(16, &quot;(((1 + 5) + 5) + 5)&quot;)
        too big
      find(33, &quot;(((1 + 5) + 5) * 3)&quot;)
        too big
    find(18, &quot;((1 + 5) * 3)&quot;)
      too big
  find(3, &quot;(1 * 3)&quot;)
    find(8, &quot;((1 * 3) + 5)&quot;)
      find(13, &quot;(((1 * 3) + 5) + 5)&quot;)
        found!</pre>

<p>تورفتگی موجود در کد بالا برای نشان دادن عمق پشته‌ی فراخوانی توابع است. اولین بار که <code>find</code> فراخوانی می‌شود، خودش را برای کاوش راه حلی که با <bdo><code>(1 + 5)</code></bdo> شروع می‌شود فراخوانی می‌کند. این فراخوانی با استفاده بازگشت، تمامی راه حل هایی که عددی کمتر یا برابر عدد هدف را تولید می‌کند را مورد کاوش قرار می دهد. با توجه به این که این فراخوانی نمی‌تواند به راه حلی برسد مقدار <code>null</code> به عنوان خروجی فراخوانی اول بازگردانده می‌شود. عملگر <code>||</code> در اینجا باعث کاوش <bdo><code>(1 * 3)</code></bdo> می‌شود. این جستجو شانس بیشتری دارد — اولین فراخوانی بازگشتی آن، توسط فراخوانی بازگشتی‌اش، به عدد هدف می‌رسد . درونی ترین فراخوانی بازگشتی، یک رشته را بر می گرداند و هر کدام از عملگرهای <code>||</code> در فراخوانی‌های میانی، آن رشته را دست به دست می کنند تا در نهایت راه حل برگردانده شود.</p>

<h2><a class="h_ident" id="h_sAB7FPnQE6" href="#h_sAB7FPnQE6" tabindex="-1" role="presentation"></a>رشد توابع</h2>

<p>برای اضافه کردن توابع به برنامه، دو حالت کم و بیش طبیعی قابل تصور است.</p>

<p>زمانی که متوجه می شوید کد مشابهی را چندین بار تکرار می‌کنید. احتمالا ترجیح‌ می دهید که این کار را نکنید. داشتن کد بیشتر به معنای ایجاد فضای بیشتر برای پنهان‌ شدن اشتباهات است و ایجاد کار بیشتر برای افرادی که قرار است با خواندن کدها برنامه‌تان را درک کنند. بنابراین قسمت تکراری را گرفته و نام خوبی برای آن انتخاب و آن را به تابع تبدیل می کنیم.</p>

<p>حالت دوم زمانی است که متوجه می شوید به قابلیتی در برنامه نیاز دارید که هنوز آن را ننوشته‌اید و این قابلیت می‌تواند تابع خودش را داشته باشد. در این صورت ابتدا نامی برای این تابع در نظر می گیرید و بعدا بدنه‌ی آن را می نویسید. ممکن است قبل از اینکه خود تابع را تعریف کنید حتی از آن در دیگر کدها استفاده کنید .</p>

<p>سختی پیدا کردن یک نام خوب برای یک تابع نشانه خوبی است تا بفهمیم که مفهومی که قصد داریم به تابع تبدیلش کنیم چقدر برای ما شفاف و روشن است. اجازه بدهید تا مثالی را بررسی کنیم.</p>

<p><a class="p_ident" id="p_b+PAE+H+pa" href="#p_b+PAE+H+pa" tabindex="-1" role="presentation"></a>قصد داریم تا برنامه‌ای بنویسیم که دو عدد را چاپ کند: تعداد گاو‌ها و مرغ‌های یک مزرعه به همراه کلمات <code>Cows</code> و <code>Chickens</code> بعد از آن‌ها و نشان دادن هر دوی عددها با طول 3 رقم ( استفاده از 0 برای ترازبندی)</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_NGDR3Ll2Zn" href="#c_NGDR3Ll2Zn" tabindex="-1" role="presentation"></a>007 Cows
011 Chickens</pre>

<p>با توجه به مسئله به تابعی با دو آرگومان نیاز داریم. تعداد گاو‌ها و تعداد مرغ‌ها.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_RO+Vw8FSPK" href="#c_RO+Vw8FSPK" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">printFarmInventory</span>(<span class="cm-def">cows</span>, <span class="cm-def">chickens</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">cowString</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">cows</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">cowString</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>) {
    <span class="cm-variable-2">cowString</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;0&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">cowString</span>;
  }
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">cowString</span><span class="cm-string-2">}</span> <span class="cm-string-2">Cows`</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">chickenString</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">chickens</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">chickenString</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>) {
    <span class="cm-variable-2">chickenString</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;0&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">chickenString</span>;
  }
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">chickenString</span><span class="cm-string-2">}</span> <span class="cm-string-2">Chickens`</span>);
}
<span class="cm-variable">printFarmInventory</span>(<span class="cm-number">7</span>, <span class="cm-number">11</span>);</pre>

<p>استفاده از <bdo><code>.length</code></bdo> بعد از مقدار رشته‌ای، طول رشته را به ما می دهد. بنابراین، حلقه <code>while</code> عمل افزودن صفر به ابتدای رشته‌ی اعداد را تا زمانی ادامه می‌دهد که حداقل طول آن سه کاراکتر بشود.</p>

<p>ماموریت تمام است! اما درست زمانی که قرار است برنامه را برای کشاورز مثال‌مان ( به همراه صورت حساب) ارسال کنیم، با ما تماس می‌گیرد و اعلام می‌کند که اخیرا پرورش خوک را نیز شروع کرده است و آیا ما می‌توانیم قابلیت نرم افزار را افزایش داده تا تعداد خوک ها را نیز چاپ کند؟</p>

<p>حتما می‌توانیم. اما درست وقتی که یک بار دیگر در حال کپی و الصاق آن چهار خط هستیم، کمی صبر کرده و تجدید نظر می کنیم. باید راه بهتری برای این کار وجود داشته باشد. اولین تلاش ما اینگونه است:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_RHETS/If7p" href="#c_RHETS/If7p" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">printZeroPaddedWithLabel</span>(<span class="cm-def">number</span>, <span class="cm-def">label</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">numberString</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">number</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">numberString</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>) {
    <span class="cm-variable-2">numberString</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;0&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">numberString</span>;
  }
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">numberString</span><span class="cm-string-2">}</span> <span class="cm-string-2">${</span><span class="cm-variable-2">label</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
}

<span class="cm-keyword">function</span> <span class="cm-def">printFarmInventory</span>(<span class="cm-def">cows</span>, <span class="cm-def">chickens</span>, <span class="cm-def">pigs</span>) {
  <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-variable-2">cows</span>, <span class="cm-string">&quot;Cows&quot;</span>);
  <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-variable-2">chickens</span>, <span class="cm-string">&quot;Chickens&quot;</span>);
  <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-variable-2">pigs</span>, <span class="cm-string">&quot;Pigs&quot;</span>);
}

<span class="cm-variable">printFarmInventory</span>(<span class="cm-number">7</span>, <span class="cm-number">11</span>, <span class="cm-number">3</span>);</pre>

<p><a class="p_ident" id="p_zWGN4dSOxe" href="#p_zWGN4dSOxe" tabindex="-1" role="presentation"></a>روش جدید به خوبی کار می‌کند. اما نام <code>printZeroPaddedWithLabel</code> کمی ناجور به نظر می‌رسد. ظاهرا سه چیز مختلف – چاپ کردن (printing)، ترازکردن با صفر(zero-padding) و افزودن برچسب (adding a lable) – در یک تابع مخلوط شده است.</p>

<p>به جای به دوش کشیدن کل قسمت تکراری در یک تابع، اجازه دهید یک <em>مفهوم</em> را انتخاب کنیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_L3v+xO5gBH" href="#c_L3v+xO5gBH" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">zeroPad</span>(<span class="cm-def">number</span>, <span class="cm-def">width</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">string</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">number</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">string</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">width</span>) {
    <span class="cm-variable-2">string</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;0&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">string</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">string</span>;
}

<span class="cm-keyword">function</span> <span class="cm-def">printFarmInventory</span>(<span class="cm-def">cows</span>, <span class="cm-def">chickens</span>, <span class="cm-def">pigs</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable">zeroPad</span>(<span class="cm-variable-2">cows</span>, <span class="cm-number">3</span>)<span class="cm-string-2">}</span> <span class="cm-string-2">Cows`</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable">zeroPad</span>(<span class="cm-variable-2">chickens</span>, <span class="cm-number">3</span>)<span class="cm-string-2">}</span> <span class="cm-string-2">Chickens`</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable">zeroPad</span>(<span class="cm-variable-2">pigs</span>, <span class="cm-number">3</span>)<span class="cm-string-2">}</span> <span class="cm-string-2">Pigs`</span>);
}

<span class="cm-variable">printFarmInventory</span>(<span class="cm-number">7</span>, <span class="cm-number">16</span>, <span class="cm-number">3</span>);</pre>

<p>داشتن یک تابع با یک نام خوب و واضح مثل <code>zeroPad</code> کار را برای کسی که قصد دارد کد برنامه را بفهمد آسان تر خواهد کرد. همچنین می‌تواند در موقعیت‌های بیشتری مورد استفاده قرار گیرد تا اینکه فقط مخصوص این برنامه باشد. به عنوان مثال، می‌توانید از این تابع در چاپ جدولی از اعداد که به خوبی تراز شده اند استفاده کنید.</p>

<p>چقدر تابع‌مان <em>باید</em> هوشمند و جامع باشد؟ می‌توانیم هر چیزی بنویسیم از تابعی که عمل بسیار ساده افزودن کاراکتر برای تراز عدد در سه کاراکتر را انجام می دهد تا یک سیستم پیچیده‌ی عمومی قالب‌بندی اعداد که قادر است اعداد اعشاری، منفی، ترازبندی نقطه‌ها، فاصله‌گذاری با کاراکترهای مختلف و غیره را مدیریت کند.</p>

<p><a class="p_ident" id="p_8XiGfaKHnK" href="#p_8XiGfaKHnK" tabindex="-1" role="presentation"></a>یک قاعده‌ی کاربردی در اینجا این است که هوشمندی بیشتری به تابع اضافه نکنیم مگر در حالتی که قطعا مطمئن هستیم که از آن استفاده خواهیم کرد. ممکن است وسوسه شویم که برای هرعملکرد کوچکی که نیاز داریم ، چهارچوب‌هایی(framework) عمومی بنویسیم. در مقابل این وسوسه باید مقاومت کرد. در غیر این صورت برنامه جلو نخواهد رفت و در پایان کدهای بسیاری خواهید نوشت که هرگز استفاده نخواهید کرد.</p>

<h2 id="pure"><a class="h_ident" id="h_Nm9AGiwA2E" href="#h_Nm9AGiwA2E" tabindex="-1" role="presentation"></a>توابع و اثرات جانبی</h2>

<p>به طور کلی می‌توان توابع را به دو گروه تقسیم کرد: آن‌هایی که برای اثرات جانبی‌شان فراخوانی می‌شوند و آن‌هایی که برای مقداری که برمی گردانند فراخوانی می‌شوند. (اگرچه قطعا می‌توان تابعی داشت که هم اثر جانبی داشته باشد و هم مقداری را بازگرداند).</p>

<p>اولین تابع کمکی که در مثال مربوط به مزرعه آمد، تابع <code>printZeroPaddedWithLabel</code> بود که برای اثر جانبی‌اش فراخوانی شد: چاپ یک خط در خروجی. در نسخه‌ی دوم، تابع <code>zeroPad</code> برای مقداری که برمی‌گرداند فراخوانده شد. اینکه تابع دوم در موقعیت های بیشتری نسبت به تابع اول کاربرد دارد تصادفی نیست. توابعی که مقدار برمی گردانند  نسبت به توابعی که مستقیما اثرات جانبی خاصی را اجرا می کنند را می‌توان آسان‌تر با روش‌های جدید ترکیب کرد.</p>

<p><a class="p_ident" id="p_MNdAzDkH2+" href="#p_MNdAzDkH2+" tabindex="-1" role="presentation"></a>یک تابع <em>ناب</em> (pure) شکل خاصی از یک تابع است که مقداری را بر می گرداند و نه تنها خودش اثر جانبی ندارد، بلکه به اثرات جانبی دیگر کدها نیز وابستگی ندارد – مثلا متغیرهای سراسری که ممکن است در کدهای دیگر تغییر کنند را مورد استفاده قرار نمی دهد. یک تابع ناب ویژگی خوبش در این است که اگر با آرگومان‌های ثابت و مشابهی فراخوانی شود، همیشه مقدار مشابهی را برمیگرداند (و رفتار متفاوتی انجام نمی دهد). فراخوانی تابعی با این ویژگی را می‌توان بدون تغییر در معنای کد برنامه، معادل مقدار بازگشتی‌اش در نظر گرفت. زمانی که از صحت عملکرد یک تابع ناب مطمئن نیستید به راحتی می‌توانید با فراخوانی، آن را تست کنید و اگر در آن بستر (context) به درستی کار کرد، در همه‌ی بسترها هم به درستی کار خواهد کرد. توابع غیرناب اما برای آزمایش نیاز به شرایط و پیش‌نیازهای بیشتری دارند.</p>

<p>البته نیازی نیست هنگام نوشتن توابعی که ناب نیستند احساس بدی داشته باشید یا اینکه برای حذف آن‌ها از کدهایتان جنگی به راه بیاندازید. اثرات جانبی معمولا کاربرد خودشان را دارند. مثلا هیچ راه نابی برای نوشتن نسخه‌ای از تابع <code>console.log</code> وجود ندارد و مشخص است که <code>console.log</code> بسیار مفید است. بعضی کارها با استفاده از اثرات جانبی راحت‌تر بیان می‌شوند و کارایی بیشتری دارند. بنابراین یکی از دلایل استفاده نکردن از توابع ناب می‌تواند موضوع سرعت محاسبه باشد.</p>

<h2><a class="h_ident" id="h_EzvDUHyjs2" href="#h_EzvDUHyjs2" tabindex="-1" role="presentation"></a>خلاصه</h2>

<p>این فصل به شما آموخت که چگونه توابع خودتان را بنویسید. زمانی که کلمه‌ی کلیدی <code>function</code> به عنوان یک عبارت استفاده می‌شود، می‌تواند یک مقدار تابع را ایجاد کند. زمانی‌ هم که به عنوان یک دستور استفاده می‌شود، متغیری را اعلان می‌کند و تابعی را به عنوان مقدار آن به آن اختصاص می دهد. روش پیکانی (arrow function) نیز راهی دیگر برای ایجاد توابع است.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_x2/+thzlca" href="#c_x2/+thzlca" tabindex="-1" role="presentation"></a><span class="cm-comment">// Define f to hold a function value</span>
<span class="cm-keyword">const</span> <span class="cm-def">f</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">a</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-number">2</span>);
};

<span class="cm-comment">// Declare g to be a function</span>
<span class="cm-keyword">function</span> <span class="cm-def">g</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">*</span> <span class="cm-variable-2">b</span> <span class="cm-operator">*</span> <span class="cm-number">3.5</span>;
}

<span class="cm-comment">// A less verbose function value</span>
<span class="cm-keyword">let</span> <span class="cm-def">h</span> <span class="cm-operator">=</span> <span class="cm-def">a</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">a</span> <span class="cm-operator">%</span> <span class="cm-number">3</span>;</pre>

<p>نقطه‌ی کلیدی در فهم توابع، درک مفهوم قلمرو‌ها است. هر بلاک از کد قلمروی جدیدی را ایجاد می‌کند. پارامترها و متغیرهایی که درون یک بلاک اعلان می‌شوند نسبت به آن تابع محلی هستند، و از بیرون بلاک قابل دسترسی نیستند. متغیرهایی که با کلیدواژه‌ی <code>var</code> ایجاد می‌شوند به شکل متفاوتی عمل می کنند – محدوده‌ی آن‌ها تا پایان حوزه‌ی نزدیک ترین تابع یا فضای سراسری برنامه است.</p>

<p>جداسازی کارهایی که برنامه‌ی شما انجام می دهد به وسیله‌ی توابع مختلف، کاری مفید است. این کار باعث می‌شود که از تکرار بی مورد پرهیز کنید و به سازماندهی یک برنامه به وسیله‌ی دسته‌بندی آن به قسمت‌هایی تخصصی، کمک می‌کند.</p>

<h2><a class="h_ident" id="h_ggOFdVwDCk" href="#h_ggOFdVwDCk" tabindex="-1" role="presentation"></a>تمرین‌ها</h2>

<h3><a class="i_ident" id="i_R74RC5FV2X" href="#i_R74RC5FV2X" tabindex="-1" role="presentation"></a>کمینه</h3>

<p>در <a href="02_program_structure.html#return_values">فصل قبل</a> با تابع استاندارد <code>Math.min</code> که کوچکترین عدد را از بین آرگومان‌های ورودی برمی گرداند آشنا شدید. خودمان هم می‌توانیم این کار را برنامه‌نویسی کنیم. تابعی به نام <code>min</code> بنویسید که دو آرگومان دریافت کرده و کوچکترین آن‌ها را باز می‌گرداند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_zoK4eQ6E3E" href="#c_zoK4eQ6E3E" tabindex="-1" role="presentation"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">min</span>(<span class="cm-number">0</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → 0</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">min</span>(<span class="cm-number">0</span>, <span class="cm-operator">-</span><span class="cm-number">10</span>));
<span class="cm-comment">// → -10</span></pre>

<div class="solution"><div class="solution-text">

<p>اگر در تعریف تابع، با گذاشتن کروشه‌ها و پرانتز‌ها در جای درست مشکل دارید، یکی از مثال‌های این فصل را کپی کرده و ویرایش نمایید.</p>

<p>یک تابع می‌تواند چندین دستور <code>return</code> داشته باشد.</p>

</div></div>

<h3><a class="i_ident" id="i_lyUVxDnHs6" href="#i_lyUVxDnHs6" tabindex="-1" role="presentation"></a>بازگشت</h3>

<p>قبلا دیده بودیم که عملگر <code>%</code> (باقی مانده) را می‌توان برای تشخیص زوج یا فرد بودن عدد استفاده کرد که برای این کار با استفاده از <bdo><code>% 2</code></bdo>، بخش پذیری بر 2 مورد آزمایش قرار می گرفت. در اینجا با راهی دیگر برای تشخیص زوج یا فرد بودن یک عدد صحیح مثبت آشنا می شویم:</p>

<ul>

<li>

<p>صفر را زوج در نظر می گیریم</p></li>

<li>

<p>یک فرد است</p></li>

<li>

<p><a class="p_ident" id="p_KpgZOkANgN" href="#p_KpgZOkANgN" tabindex="-1" role="presentation"></a>برای هر عددی دیگر <em>N</em>، زوج بودن آن معادل <bdo><em>N</em> - 2</bdo> خواهد بود.</p></li></ul>

<p>تابع بازگشتی <code>isEven</code> را با توجه به توضیحات بالا تعریف کنید. تابع باید پارامتری مثبت و از جنس اعداد صحیح دریافت کند و مقداری از جنس بولی برگرداند.</p>

<p><a class="p_ident" id="p_F8nwhNCAnQ" href="#p_F8nwhNCAnQ" tabindex="-1" role="presentation"></a>تابع را با مقادیر 50 و 75 تست کنید. بررسی کنید که اگر <bdo>-1</bdo> را به آن بدهید چه خواهد شد. چرا؟ آیا می‌توانید راهی برای حل مشکل پیش آمده پیدا کنید؟</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_7Dyz/3MMqh" href="#c_7Dyz/3MMqh" tabindex="-1" role="presentation"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">isEven</span>(<span class="cm-number">50</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">isEven</span>(<span class="cm-number">75</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">isEven</span>(<span class="cm-operator">-</span><span class="cm-number">1</span>));
<span class="cm-comment">// → ??</span></pre>

<div class="solution"><div class="solution-text">

<p>تابع شما احتمالا به چیزی شبیه به تابع درونی <code>find</code> در <a href="03_functions.html#recursive_puzzle">مثال</a> بازگشتی <code>findSolution</code> نزدیک خواهد بود، که حاوی یک مجموعه‌ی <code>if</code>/<code>else if</code>/<code>else</code> بود که صحت یکی از سه حالت را آزمایش می کرد. <code>else</code> آخر، که به سومین حالت مربوط می‌شود، عمل فراخوانی بازگشتی را انجام می دهد. هر یک از شاخه‌ها باید یک دستور <code>return</code> داشته باشند یا به شکلی مقداری را برای خروجی مهیا کنند.</p>

<p>زمانی که عدد منفی داده شود، تابع مکرر خودش را با عدد منفی بیشتر فراخوانی می‌کند، بنابراین از بازگرداندن نتیجه دورتر و دورتر می‌شود. در نهایت با کمبود فضای پشته روبرو شده و از کار می افتد.</p>

</div></div>

<h3><a class="i_ident" id="i_YU8xeCexae" href="#i_YU8xeCexae" tabindex="-1" role="presentation"></a>شمارش دانه</h3>

<p><a class="p_ident" id="p_D3C8NOezly" href="#p_D3C8NOezly" tabindex="-1" role="presentation"></a>برای بدست آوردن کاراکتر یا حرف Nام یک رشته، می‌توانید از <bdo><code>&quot;string&quot;[N]</code></bdo> استفاده کنید. مقداری که برگردانده می‌شود رشته‌ای است که فقط یک کاراکتر دارد. (مثلا رشته‌ی <code>&quot;b&quot;</code>). کاراکتر اول در جایگاه صفرم قرار دارد. بنابراین آخرین کاراکتر در جایگاه <bdo><code>string.<wbr>length - 1</code></bdo> قرار می‌گیرد. به عبارتی دیگر، یک رشته‌ی دو کاراکتری طولش 2 کاراکتر است و کاراکتر‌هایش در جایگاه 0 و 1 قرار دارند.</p>

<p><a class="p_ident" id="p_rk8oHfWl0P" href="#p_rk8oHfWl0P" tabindex="-1" role="presentation"></a>تابعی به نام <code>countBs</code> بنویسید که رشته ای را به عنوان تنها آرگومانش می پذیرد و عددی را برمی‌گرداند که نشان می دهد چند کاراکتر “B” بزرگ در رشته وجود دارد.</p>

<p>بعد، تابعی به نام <code>countChar</code> بنویسید که شبیه <code>countBs</code> کار می‌کند اما آرگومان دومی نیز دریافت می‌کند که مشخص کننده کاراکتری است که باید شمرده بشود ( به جای اینکه فقط B شمرده شود ). تابع <code>countBs</code> را بازنویسی کنید تا این ویژگی جدید را داشته باشد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_QN+QdpdCe+" href="#c_QN+QdpdCe+" tabindex="-1" role="presentation"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">countBs</span>(<span class="cm-string">&quot;BBC&quot;</span>));
<span class="cm-comment">// → 2</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">countChar</span>(<span class="cm-string">&quot;kakkerlak&quot;</span>, <span class="cm-string">&quot;k&quot;</span>));
<span class="cm-comment">// → 4</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_NWoZK3kTsE" href="#p_NWoZK3kTsE" tabindex="-1" role="presentation"></a>تابع شما به یک حلقه نیاز دارد که به تک تک کاراکترهای رشته بپردازد. این حلقه می‌تواند از شاخص صفر تا یک عدد کمتر از طول رشته را پیمایش کند (<bdo><code>&lt; string.<wbr>length</code></bdo>). اگر کاراکتر موجود در موقعیت فعلی معادل کاراکتری بود که تابع به دنبال آن است، به متغیر شمارنده 1 واحد اضافه می‌کند. بعد از پایان حلقه، شمارنده را می‌توان بازگرداند.</p>

<p>حواستان باشد که همه‌ی متغیرهایی که در تابع استفاده می‌شود به صورت <em>محلی</em> در همان تابع به وسیله‌ی <code>let</code> یا <code>const</code> تعریف شوند.</p>

</div></div><nav><a href="02_program_structure.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="04_data.html" title="next chapter">▶</a></nav>
</article>
