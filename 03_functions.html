<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Functions :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 3;</script></head>

<article>
<nav><a href="02_program_structure.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="04_data.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>Chapter 3</span>Functions</h1>

<blockquote>

<p><a class="p_ident" id="p_hkFlscMSbe" href="#p_hkFlscMSbe" tabindex="-1" role="presentation"></a>People think that computer science is the art of geniuses but the actual reality is the opposite, just many people doing things that build on each other, like a wall of mini stones.</p>

<footer>Donald Knuth</footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_3.jpg" alt="Picture of fern leaves with a fractal shape"></figure>

<p><a class="p_ident" id="p_2jmj7l5rSw" href="#p_2jmj7l5rSw" tabindex="-1" role="presentation"></a>توابع از پایه‌های اصلی برنامه نویسی به زبان جاوااسکریپت هستند. مفهموم قراردادن قطعه برنامه‌ای درون یک مقدار کاربردهای زیادی دارد. از آن می توان برای ساختاردهی به برنامه‌های بزرگتر استفاده کرد، از تکرار پرهیز کرد، به زیربرنامه ها نام اختصاص داد و آن ها را به شکلی مستقل مجزا کرد.</p>

<p>واضح ترین کاربرد‌ توابع، استفاده از آن‌ها برای تعریف واژه‌ی جدید است. خلق واژه‌ای جدید در یک نثر معمولی معمولا کار جالبی نیست اما در برنامه نویسی این کار اجتناب ناپذیر است.</p>

<p><a class="p_ident" id="p_9nkc20pB5J" href="#p_9nkc20pB5J" tabindex="-1" role="presentation"></a>معمولا انگلیسی زبانان بزرگسال در دامنه واژگانشان حدود 20,000 کلمه دارند. زبان‌های برنامه نویسی کمی هستند که 20,000 دستور از پیش تعریف شده دارند.  و این دستورات یا واژگانی که در دسترس هستند به صورت دقیقی تعریف می شوند که در نتیجه انعطاف کمتری نسبت به زبان‌های بشری دارند. بنابراین، معمولا بایستی مفاهیم جدید را خودمان تعریف کنیم تا خیلی درگیر تکرار نشویم.</p>

<h2><a class="h_ident" id="h_/hCfR38CAR" href="#h_/hCfR38CAR" tabindex="-1" role="presentation"></a>تعریف یک تابع</h2>

<p>تعریف یک تابع همان تعریف عادی یک متغیر است با این تفاوت که مقداری که به متغیر اختصاص داده می شود، از جنس تابع است. به عنوان مثال، کد پیش رو متغیر <code>square</code> را تعرف می کند که به تابعی ارجاع می دهد که مربع عدد داده شده را تولید می کند:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_JW7vLBZMWv" href="#c_JW7vLBZMWv" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">square</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">x</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>;
};

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">square</span>(<span class="cm-number">12</span>));
<span class="cm-comment">// → 144</span></pre>

<p>یک تابع را می توان به وسیله‌ی یک عبارت که با کلمه‌ی کلیدی <code>function</code> شروع می شود ایجاد کرد.توابع دارای  مجموعه‌ای از <em>پارامترها</em> (در مثال بالا فقط <code>x</code>) و یک <em>بدنه</em> که خود در بردارنده دستوراتی است که در صورت فراخوانی تابع اجرا می شوند، می باشد. بدنه‌ی تابع می بایست همیشه درون کروشه‌ها قرار گیرد حتی زمانی که فقط حاوی یک دستور است ( مانند مثال قبل ).</p>

<p>یک تابع می تواند چندین پارامتر داشته باشد یا هیچ پارامتری نداشته باشد. در مثال پیش رو، تابع <code>makeNoise</code> هیچ پارامتری ندارد در حالیکه  تابع <code>power</code> دو پارامتر دارد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_8fTeYA4ABW" href="#c_8fTeYA4ABW" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">makeNoise</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Pling!&quot;</span>);
};

<span class="cm-variable">makeNoise</span>();
<span class="cm-comment">// → Pling!</span>

<span class="cm-keyword">const</span> <span class="cm-def">power</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">base</span>, <span class="cm-def">exponent</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">count</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">exponent</span>; <span class="cm-variable-2">count</span><span class="cm-operator">++</span>) {
    <span class="cm-variable-2">result</span> <span class="cm-operator">*=</span> <span class="cm-variable-2">base</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
};

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>(<span class="cm-number">2</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → 1024</span></pre>

<p>بعضی توابع مقداری را برمی گردانند،‌ مانند تابع <code>power</code> و <code>square</code>، و بعضی توابع مانند <code>makeNoise</code> فقط اثر جانبی تولید می کنند و مقداری را باز نمی گردانند. دستوری به نام <code>return</code> مسئول بازگرداندن مقداری از تابع است. زمانی که برنامه به این دستور می رسد، به سرعت از تابع فعلی خارج شده و مقداری که “برگردانده شده” را به قسمتی از برنامه که تابع در آنجا فراخوانی شده، ارسال می کند. استفاده از دستور <code>return</code> بدون عبارتی بعد از آن ، باعث می شود که تابع مقدار <code>undefined</code> را برگرداند. توابعی که اصلا دستور <code>return</code> را ندارند مانند <code>makeNoise</code> نیز مقدار <code>undefined</code> را برمی گردانند.</p>

<p>پارامترها در توابع درست شبیه متغیرهای عادی رفتار می کنند اما مقدار اولیه آن ها توسط <em>فراخواننده</em> تابع مقداردهی می شود نه کدی که در بدنه تابع نوشته می شود.</p>

<h2><a class="h_ident" id="h_jswzJS0iuC" href="#h_jswzJS0iuC" tabindex="-1" role="presentation"></a>متغیرها و قلمرو‌ی آن</h2>

<p>هر متغیری دارای یک <em>قلمرو</em> دسترسی است که عبارت است از بخشی از برنامه که در آن متغیر قابل دسترسی و مشاهده است. برای متغیرهایی که بیرون از یک تابع یا یک بلاک تعریف شده اند، این حوزه شامل کل برنامه می شود – می توانید به این متغیرها در هرجای برنامه دسترسی داشته باشید. به این متغیرها متغیرهای <em>سراسری</em> گفته می شود.</p>

<p>اما متغیرهایی که برای پارامترهای توابع ایجاد می شوند یا آن هایی که درون یک تابع تعریف می شوند، فقط در درون همان تابع قابل ارجاع می باشند، به همین علت به آن ها متغیرهای <em>محلی</em> گفته می شود. هر دفعه که تابعی فراخوانی می شود، یک نمونه از این متغیرها ایجاد می شود. این کار باعث می شود که توابع به نوعی نسبت به هم مجزا (‌ایزوله) شوند- هر فراخوانی تابع در فضای اختصاصی خودش عمل می کند (محیط محلی خودش) و معمولا می توان این نحوه‌ی عملکرد را از برنامه دریافت بدون اینکه بخواهیم از جزئیاتی که در محیط اجرایی برنامه باخبر شویم.</p>

<p><a class="p_ident" id="p_nN2mfe0/JY" href="#p_nN2mfe0/JY" tabindex="-1" role="presentation"></a>متغیرهایی که با <code>let</code>  یا <code>const</code> تعریف می شوند در واقع نسبت به <em>بلاکی</em> که درون آن تعریف شده اند محلی هستند، بنابراین اگر یکی از آن ها درون یک حلقه تعریف کنید، کدی که قبل و بعد از حلقه قرار گرفته نمی تواند آن را “ببیند”. در نسخه‌های قبل از 2015 جاوااسکریپت(؟)، فقط توابع بودند که می توانستند حوزه‌ی جدید ایجاد کنند، بنابراین متغیرهای قدیمی که با <code>var</code> تعریف می شدند در تابعی که که درآن تعریف شده بودند، دیده می شدند یا اگر بیرون تابع بودن، در کل برنامه در دسترس بوند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_d7ecKvF5xD" href="#c_d7ecKvF5xD" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>;
<span class="cm-keyword">if</span> (<span class="cm-atom">true</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-number">20</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">z</span> <span class="cm-operator">=</span> <span class="cm-number">30</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">y</span> <span class="cm-operator">+</span> <span class="cm-variable">z</span>);
  <span class="cm-comment">// → 60</span>
}
<span class="cm-comment">// y is not visible here</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">x</span> <span class="cm-operator">+</span> <span class="cm-variable">z</span>);
<span class="cm-comment">// → 40</span></pre>

<p>هر قلمرو می تواند حوزه‌ی پیرامونش را ببیند، مثلا در مثال بالا، متغیر <code>x</code> در درون بلاک قابل مشاهده است. یک استثناء اینجا زمانی رخ می دهد که چندین متغیر با یک نام وجود داشته باشد که در این صورت، کد برنامه می تواند درونی‌ترین مورد را ببیند. به عنوان مثلا، در تابع <code>halve</code> مثال پایین، زمانی که کد درون تابع به متغیر <code>n</code> اشاره می کند، متغیر <code>n</code> <em>خود</em> تابع استفاده می شود نه متغیر سراسری <code>n</code>.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_5g6POeoiQv" href="#c_5g6POeoiQv" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">halve</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">n</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">n</span> <span class="cm-operator">/</span> <span class="cm-number">2</span>;
};

<span class="cm-keyword">let</span> <span class="cm-def">n</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">halve</span>(<span class="cm-number">100</span>));
<span class="cm-comment">// → 50</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">n</span>);
<span class="cm-comment">// → 10</span></pre>

<h3 id="scoping"><a class="i_ident" id="i_6kT7sc0PGc" href="#i_6kT7sc0PGc" tabindex="-1" role="presentation"></a>قلمروی تو در تو</h3>

<p>جاوااسکریپت تنها بین متغیرهای <em>سراسری</em> و <em>محلی</em> تفاوت قائل نمی شود. می توان توابع و بلاک‌ها را نیز به شکل تودرتو ایجاد کرد که باعث ایجاد درجه‌های مختلفی از محلی بودن میگردد.</p>

<p>به عنوان مثال، این تابع – که مواد لازم برای تهیه حمص (نوعی غذا) را برمی گرداند – تابعی دیگر در درون خود دارد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_cOSfyI1GsW" href="#c_cOSfyI1GsW" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">hummus</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">factor</span>) {
  <span class="cm-keyword">const</span> <span class="cm-def">ingredient</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">amount</span>, <span class="cm-def">unit</span>, <span class="cm-def">name</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">ingredientAmount</span> <span class="cm-operator">=</span> <span class="cm-variable-2">amount</span> <span class="cm-operator">*</span> <span class="cm-variable-2">factor</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">ingredientAmount</span> <span class="cm-operator">&gt;</span> <span class="cm-number">1</span>) {
      <span class="cm-variable-2">unit</span> <span class="cm-operator">+=</span> <span class="cm-string">&quot;s&quot;</span>;
    }
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">ingredientAmount</span><span class="cm-string-2">}</span> <span class="cm-string-2">${</span><span class="cm-variable-2">unit</span><span class="cm-string-2">}</span> <span class="cm-string-2">${</span><span class="cm-variable-2">name</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  };
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">1</span>, <span class="cm-string">&quot;can&quot;</span>, <span class="cm-string">&quot;chickpeas&quot;</span>);
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">0.25</span>, <span class="cm-string">&quot;cup&quot;</span>, <span class="cm-string">&quot;tahini&quot;</span>);
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">0.25</span>, <span class="cm-string">&quot;cup&quot;</span>, <span class="cm-string">&quot;lemon juice&quot;</span>);
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">1</span>, <span class="cm-string">&quot;clove&quot;</span>, <span class="cm-string">&quot;garlic&quot;</span>);
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">2</span>, <span class="cm-string">&quot;tablespoon&quot;</span>, <span class="cm-string">&quot;olive oil&quot;</span>);
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">0.5</span>, <span class="cm-string">&quot;teaspoon&quot;</span>, <span class="cm-string">&quot;cumin&quot;</span>);
};</pre>

<p>کدی که در تابع <code>ingredient</code> قرار دارد می تواند متغیر <code>factor</code> را از تابع بیرونی ببیند. اما متغیرهای محلیش مانند <code>unit</code> یا <code>ingredientAmount</code> توسط تابع بیرونی قابل مشاهده نیستند.</p>

<p>مجموعه‌ای از متغیرها که درون یک بلاک قابل رویت هستند بستگی به مکان بلاک در متن برنامه دارد.  هر قلمروی محلی همچنین می تواند قلمرو‌های محلی ای که آن را در بر گرفته اند را ببیند و همه قلمروها می تواند قلمرو سراسری را ببینند. این روش رویت پذیری متغیر را <em>حوزه‌بندی لغوی</em> می نامند.</p>

<h2><a class="h_ident" id="h_X2UZ4UkAI8" href="#h_X2UZ4UkAI8" tabindex="-1" role="presentation"></a>استفاده از توابع به عنوان مقدار</h2>

<p>متغیرهایی که توابع را نگه‌داری می کنند معمولا به شکلی ساده نقش یک نام را برای قطعه‌ای از برنامه بازی می کنند. این گونه متغیرها یک بار تعریف شده و دیگر تغییر نمی یابند. این امر ممکن است باعث بروز اشتباهاتی بین خود تابع و نام آن بشود.</p>

<p>اما این دو متفاوتند. یک مقدار تابع می تواند همه‌ی چیزهایی که دیگر مقدارها، انجام می دهند را انجام دهد – می توانید از آن ها در عبارت‌ها استفاده کنید نه اینکه فقط آن ها را فراخوانی کنید. می توان مقدار تابع را در متغیر جدیدی ذخیره کرد، به عنوان آرگومان به یک تابع فرستاد و از این قبیل. به طور مشابه متغیری که یک تابع را نگه داری می کند هنوز فقط یک متغیر عادی است و می توان مقدار جدیدی به آن اختصاص داد البته اگر به عنوان ثابت تعریف نشده باشد. مثلا:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_SZ7MmN0oGC" href="#c_SZ7MmN0oGC" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">launchMissiles</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-variable">missileSystem</span>.<span class="cm-property">launch</span>(<span class="cm-string">&quot;now&quot;</span>);
};
<span class="cm-keyword">if</span> (<span class="cm-variable">safeMode</span>) {
  <span class="cm-variable">launchMissiles</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {<span class="cm-comment">/* do nothing */</span>};
}</pre>

<p>در <a href="05_higher_order.html">فصل 5</a>، در مورد کارهای جالبی که می توان به وسیله ارسال توابع به عنوان مقدار به دیگر توابع انجام داد بحث خواهیم کرد.</p>

<h2><a class="h_ident" id="h_Age4dw3mWK" href="#h_Age4dw3mWK" tabindex="-1" role="presentation"></a>استفاده از روش اعلان تابع</h2>

<p>روش نسبتا کوتاه‌تری برای ایجاد یک تابع  وجود دارد. زمانی که از کلمه کلیدی <code>function</code> در ابتدای یک دستور استفاده می کنیم، این تعریف به شکل دیگری صورت می گیرد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_4uHhsg+h7S" href="#c_4uHhsg+h7S" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">square</span>(<span class="cm-def">x</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>;
}</pre>

<p>این روش، تعریف تابع با <em>اعلان</em> آن است. این دستور متغیری به نام <code>square</code> را تعریف کرده و آن را به تابع داده شده مرتبط می کند. تعریف تابع به این روش اندکی ساده تر به نظر می رسد و در این روش نیازی نیست بعد از تعریف تابع از نقطه ویرگول استفاده کنید.</p>

<p>در اینجا یک نکته‌ی ریز در این شکل از تعریف تابع وجود دارد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_41Tuq8c/gg" href="#c_41Tuq8c/gg" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;The future says:&quot;</span>, <span class="cm-variable">future</span>());

<span class="cm-keyword">function</span> <span class="cm-def">future</span>() {
  <span class="cm-keyword">return</span> <span class="cm-string">&quot;You'll never have flying cars&quot;</span>;
}</pre>

<p>کد بالا به درستی کار می کند اگرچه تعریف تابع پایین تر از خطی که فراخوانی می شود اتفاق افتاده است. دلیل این اتفاق این است که اعلان‌های توابع در جاوااسکریپت به عنوان بخشی از جریان کنترل بالا به پایین عادی برنامه محسوب نمی شوند. به طور مفهومی آن ها به بالای حوزه‌ی خودشان منتقل می شوند و می توان از آن‌ها در همه‌ی کدهای موجود در آن حوزه استفاده کرد. این ویژگی گاهی اوقات کاربردی است چرا که این آزادی را به ما می دهد تا به شکلی کدها را مرتب کنیم که بهتر سازماندهی بشوند بدون اینکه نگران این باشیم که توابع ما حتما قبل از محل فراخوانی‌شان تعریف شده باشند.</p>

<h2><a class="h_ident" id="h_/G0LSjQxoo" href="#h_/G0LSjQxoo" tabindex="-1" role="presentation"></a>Arrow functions</h2>

<p>روش سومی هم برای تعریف توابع وجود دارد، که با روش‌های قبلی خیلی متفاوت‌ به نظر می رسد. به جای استفاده از کلیدواژه‌ی <code>function</code> از یک پیکان <bdo>(<code>=&gt;</code>)</bdo> که از علامت مساوی و بزرگتر استفاده می شود. ( نباید با عملگر بزرگتر-یا-مساوی-از اشتباه گرفته شود، که به شکل <bdo><code>&gt;=</code></bdo> نوشته می شود)</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_4WdKJKvocO" href="#c_4WdKJKvocO" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">power</span> <span class="cm-operator">=</span> (<span class="cm-def">base</span>, <span class="cm-def">exponent</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">count</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">exponent</span>; <span class="cm-variable-2">count</span><span class="cm-operator">++</span>) {
    <span class="cm-variable-2">result</span> <span class="cm-operator">*=</span> <span class="cm-variable-2">base</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
};</pre>

<p>کاراکتر پیکان درست بعد از لیستی از پارامترها می آید که <em>بعد</em> از آن بدنه‌ی تابع خواهد آمد. می توان به نوعی این طور تفسیرش کرد که ” این ورودی پارامترها) این نتیجه ( بدنه‌ی تابع‌ ) را تولید خواهد کرد”.</p>

<p>زمانی که تنها یک پارامتر وجود دارد، می توانید از پرانتزها صرف نظر کنید. اگر بدنه تابع فقط شامل یک عبارت است، نسبت به یک بلاک که توسط کروشه‌ها محصور شده، آن عبارت توسط تابع برگردانده می شود. بنابراین  دو روش تعریف تابع <code>square</code> در زیر، کار مشابهی را انجام می دهند:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_VIDIsvgTjA" href="#c_VIDIsvgTjA" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">square1</span> <span class="cm-operator">=</span> (<span class="cm-def">x</span>) <span class="cm-operator">=&gt;</span> { <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>; };
<span class="cm-keyword">const</span> <span class="cm-def">square2</span> <span class="cm-operator">=</span> <span class="cm-def">x</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>;</pre>

<p><a class="p_ident" id="p_2jbaADpQVe" href="#p_2jbaADpQVe" tabindex="-1" role="presentation"></a>زمانی که یک arrow function فاقد پارامتر است، لیست پارامترهایش به صورت یک جفت پرانتز خالی نوشته می شود.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_VfJZoQnqTl" href="#c_VfJZoQnqTl" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">horn</span> <span class="cm-operator">=</span> () <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Toot&quot;</span>);
};</pre>

<p>نمی توان دلیل خیلی خوبی برای اینکه در زبان جاوااسکریپت نیاز به هر دو نوع تعریف تابع (روش پیکانی و معمول) وجود دارد پیدا کرد. از موارد جزئی که بگذریم ( که در <a href="06_object.html">فصل 6</a> به آن ها می پردازیم)، هر دوی آن ها کار یکسانی را انجام می دهند. روش پیکانی در سال 2015 به زبان اضافه شد بیشتر به این خاطر که بتوان توابع را به شکل کوتاه‌تر و خلاصه نوشت و از درازنویسی پرهیز کرد. در <a href="05_higher_order.html">فصل 5</a> از آن‌ها زیاد استفاده خواهیم کرد.</p>

<h2 id="stack"><a class="h_ident" id="h_tB5d//rrwc" href="#h_tB5d//rrwc" tabindex="-1" role="presentation"></a>پشته‌ی فراخوانی توابع</h2>

<p>روشی که کنترل برنامه در توابع جریان می یابد، نسبتا کمی پیچیده است. بجاست تا نگاهی دقیق تر به نحوه‌ی جریان کنترل در توابع بیاندازیم. در اینجا برنامه‌ی ساده ای داریم که چند فراخوانی تابع دارد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_vruWG+bXUz" href="#c_vruWG+bXUz" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">greet</span>(<span class="cm-def">who</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Hello &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">who</span>);
}
<span class="cm-variable">greet</span>(<span class="cm-string">&quot;Harry&quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Bye&quot;</span>);</pre>

<p><a class="p_ident" id="p_vx8FzaEQVq" href="#p_vx8FzaEQVq" tabindex="-1" role="presentation"></a>اجرای این برنامه به طور کلی به این شکل خواهد بود: فراخوانی تابع <code>greet</code> باعث می شود که کنترل برنامه به شروع بدنه‌ی آن تابع (خط 2) بپرد. تابع <code>console.log</code> (که تابعی از پیش ساخته شده در مرورگر است) را فراخوانی می کند، که کنترل را در دست گرفته، کارش را انجام می دهد و دوباره کنترل را به خط 2 بازمی گرداند. سپس به انتهای تابع <code>greet</code> می رسد بنابراین به جایی که در ابتدا فراخوانی شده بود باز می گردد، خط 4. خط بعدی دوباره <code>console.log</code> را فراخوانی می کند. بعد از آن، برنامه به پایان خود می رسد.</p>

<p>می توانیم این جریان کنترل را به صورت شماتیک به این صورت نشان دهیم:</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_sK38O0sD4t" href="#c_sK38O0sD4t" tabindex="-1" role="presentation"></a>not in function
   in greet
        in console.log
   in greet
not in function
   in console.log
not in function</pre>

<p>به دلیل اینکه تابع پس از اجرا می بایست به نقطه‌ای که از آن‌جا فراخوانی شده است بازگردد، کامپیوتر باید مکانی از برنامه که تابع از آنجا فراخوانی شده است را به خاطر بیاورد. در یک مورد، <code>console.log</code> پس از اجرا باید به تابع <code>greet</code> برگردد و در مورد بعدی به انتهای برنامه بر می گردد.</p>

<p><a class="p_ident" id="p_7Ccns7cfB2" href="#p_7Ccns7cfB2" tabindex="-1" role="presentation"></a>جایی از کامپیوتر که این محل یا زمینه (context) ذخیره می شود <em>پشته‌ی فراخوانی</em> می باشد. هر بار که تابعی فراخوانی می شود، محل فعلی فراخوانی در بالای این “پشته” قرار می گیرد. زمانی که اجرای تابع تمام می شود، عنصر بالای پشته را از پشته حذف می کند و از آن محل برای ادامه اجرای برنامه استفاده می کند.</p>

<p><a class="p_ident" id="p_YHNeQouJ8W" href="#p_YHNeQouJ8W" tabindex="-1" role="presentation"></a>ذخیره‌ی این پشته نیاز به فضایی در حافظه‌ی کامپیوتر دارد. در صورت رشد بیش از اندازه پشته، کامپیوتر با مشکل روبرو شده و پیغام “out of stack space” یا “too much recursion” را تولید می کند. کدی که در ادامه می آید این موضوع را بیشتر باز می کند. در این مثال کامپیوتر با مساله‌ی بسیار مشکلی روبرو می شود که باعث می شود به طور بی نهایت بین دو تابع گیر بیفتد. اگر محدودیت حافظه‌ برای پشته نبود، احتمالا اجرای این برنامه بی نهایت می شد. اما در واقع، ما با کمبود فضا روبرو می شویم، یا اینکه پشته از کار خواهد افتاد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_fZaWglCohr" href="#c_fZaWglCohr" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">chicken</span>() {
  <span class="cm-keyword">return</span> <span class="cm-variable">egg</span>();
}
<span class="cm-keyword">function</span> <span class="cm-def">egg</span>() {
  <span class="cm-keyword">return</span> <span class="cm-variable">chicken</span>();
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">chicken</span>() <span class="cm-operator">+</span> <span class="cm-string">&quot; came first.&quot;</span>);
<span class="cm-comment">// → ??</span></pre>

<h2><a class="h_ident" id="h_hQkARX0UIY" href="#h_hQkARX0UIY" tabindex="-1" role="presentation"></a>آرگومان‌های اختیاری</h2>

<p>کد مثال زیر، معتبر است و بدون هیچ مشکلی کار می کند:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_IckdVt0tqA" href="#c_IckdVt0tqA" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">square</span>(<span class="cm-def">x</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>; }
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">square</span>(<span class="cm-number">4</span>, <span class="cm-atom">true</span>, <span class="cm-string">&quot;hedgehog&quot;</span>));
<span class="cm-comment">// → 16</span></pre>

<p>تابع <code>square</code> را که فقط یک پارامتر دارد را تعریف کردیم. اما زمانی که به شکل بالا با سه پارامتر  آن را فراخوانی می کنیم، با خطایی روبرو نمی شویم. این تابع به جز آرگومان اول از دیگر آرگومان‌ها صرف نظر می کند و مربع عدد اول را حساب می کند.</p>

<p>جاوااسکریپت نسبت به تعداد آرگومان‌های دریافتی، بسیار روشن فکرانه عمل می کند. اگر آرگومان‌های بیشتری نسبت به آنچه از قبل تعریف شده است ارسال نمایید، به سادگی از آن ها چشم پوشی می کند. اگر آرگومان کمتری ارسال کنید، به آرگومان‌هایی که مقداردهی نشده اند مقدار <code>undefined</code> را اختصاص می دهد.</p>

<p>جنبه‌ی منفی این کار این است که ممکن است که شما ناخواسته و تصادفی تعداد اشتباهی آرگومان را به تابع ارسال کنید و اصلا متوجه آن هم نشوید.</p>

<p>و جنبه مثبت  این است که می توان با استفاده از آن به یک تابع اجازه داد که آرگومان‌های متعدد و متفاوتی فراخوانی شود. به عنوان مثال، تابع <code>minus</code>  که در ادامه می آید سعی می کند که عملگر <code>-</code> را با عمل کردن روی یک یا دو آرگومان شبیه سازی کند:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_8zGcY0SKdo" href="#c_8zGcY0SKdo" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">minus</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">b</span> <span class="cm-operator">===</span> <span class="cm-atom">undefined</span>) <span class="cm-keyword">return</span> <span class="cm-operator">-</span><span class="cm-variable-2">a</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">-</span> <span class="cm-variable-2">b</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">minus</span>(<span class="cm-number">10</span>));
<span class="cm-comment">// → -10</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">minus</span>(<span class="cm-number">10</span>, <span class="cm-number">5</span>));
<span class="cm-comment">// → 5</span></pre>

<p id="power">اگر بعد از نوشتن پارامتر علامت <code>=</code> قرار داده و عبارتی را بنویسید، مقدار آن عبارت در صورتی که آرگومان ارسال نشود، جایگزین آن می شود.</p>

<p><a class="p_ident" id="p_2kuSN7rMzf" href="#p_2kuSN7rMzf" tabindex="-1" role="presentation"></a>به عنوان مثال، این نسخه از تابع <code>power</code> آرگومان دومش را اختیاری تعریف کرده است. اگر آرگومان دوم را ارسال نکنید یا اینکه مقدار <code>undefined</code> را بفرستید، مقدار پیش‌فرض 2 در نظر گرفته می شود و تابع شبیه تابع <code>square</code> عمل می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_nTMMMpMRLQ" href="#c_nTMMMpMRLQ" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">power</span>(<span class="cm-def">base</span>, <span class="cm-def">exponent</span> <span class="cm-operator">=</span> <span class="cm-number">2</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">count</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">exponent</span>; <span class="cm-variable-2">count</span><span class="cm-operator">++</span>) {
    <span class="cm-variable-2">result</span> <span class="cm-operator">*=</span> <span class="cm-variable-2">base</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>(<span class="cm-number">4</span>));
<span class="cm-comment">// → 16</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>(<span class="cm-number">2</span>, <span class="cm-number">6</span>));
<span class="cm-comment">// → 64</span></pre>

<p>در <a href="04_data.html#rest_parameters">فصل بعد</a>، با راهی آشنا خواهیم شد که در بدنه تابع می توان با آن به لیست دقیق آرگومان‌های ارسالی دست پیدا کرد. با این ویژگی می توان در یک تابع هر تعداد آرگومان قبول کرد. مثلا تابع <code>console.log</code> از این ویژگی استفاده می کند- همه‌ی مقادیری که به آن داده می شود به خروجی ارسال می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_RvkwVkcUZ7" href="#c_RvkwVkcUZ7" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;C&quot;</span>, <span class="cm-string">&quot;O&quot;</span>, <span class="cm-number">2</span>);
<span class="cm-comment">// → C O 2</span></pre>

<h2><a class="h_ident" id="h_RDU7jRFZ7F" href="#h_RDU7jRFZ7F" tabindex="-1" role="presentation"></a>بستار (closure)</h2>

<p>امکان استفاده از توابع به شکل مقدار، وقتی با این واقعیت ترکیب می شود که متغیرهای محلی با هر بار فراخوانی تابع از نوع ایجاد می شوند، سوال جالبی را به ذهن می آورد. چه اتفاقی برای متغیرهای محلی می افتد زمانی که تابعی که با فراخوانیش آن ها را ایجاد کرده دیگر فعال نیست؟</p>

<p>کدی که در ادامه می آید مثالی از این مفهوم را نمایش می دهد. تابعی به نام <code>wrapValue</code> را تعریف کرده که درون آن متغیری محلی ایجاد شده است. سپس تابعی را بازمیگرداند که به این متغیر محلی دسترسی داشته و آن را برمی گرداند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_DF70h3opbx" href="#c_DF70h3opbx" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">wrapValue</span>(<span class="cm-def">n</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">local</span> <span class="cm-operator">=</span> <span class="cm-variable-2">n</span>;
  <span class="cm-keyword">return</span> () <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">local</span>;
}

<span class="cm-keyword">let</span> <span class="cm-def">wrap1</span> <span class="cm-operator">=</span> <span class="cm-variable">wrapValue</span>(<span class="cm-number">1</span>);
<span class="cm-keyword">let</span> <span class="cm-def">wrap2</span> <span class="cm-operator">=</span> <span class="cm-variable">wrapValue</span>(<span class="cm-number">2</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">wrap1</span>());
<span class="cm-comment">// → 1</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">wrap2</span>());
<span class="cm-comment">// → 2</span></pre>

<p>این کار مجاز و معتبر است و به خوبی کار می کند درست همانطور که انتظارش را دارید- هر دوی نمونه‌های متغیر مورد نظر هنوز در دسترس هستند. در واقع، نمونه‌های متعددی از متغیر را می توان در یک زمان زنده نگه داشت که خود مثال خوبی از این مفهوم است که متغیرهای محلی واقعا با هر با فراخوانی از نو ایجاد می شوند و فراخوانی های مختلف نمی توانند روی متغیرهای محلی یکدیگر اثری داشته باشند.</p>

<p>این ویژگی - امکان رجوع به یک نمونه مشخص از متغیرهای محلی محصور در یک تابع – <em>بستار</em> یا کلوژر نامیده می شود. تابعی که به متغیرهایی که در حوزه‌ی محلی پیرامونش قرار دارند ارجاع می دهد را <em>یک</em> بستار می نامند. این رفتار نه تنها شما را از نگرانی برای عمر متغیرها آزاد می کند بلکه همچنین این امکان استفاده‌های خلاقانه از مقدارهای تابع را فراهم می کند.</p>

<p>با کمی تغییر می توانیم مثال قبل را به روشی برای ایجاد توابعی که عمل ضرب را با یک مقدار دلخواه انجام می دهند استفاده کنیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_iIlCVmvMSs" href="#c_iIlCVmvMSs" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">multiplier</span>(<span class="cm-def">factor</span>) {
  <span class="cm-keyword">return</span> <span class="cm-def">number</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">number</span> <span class="cm-operator">*</span> <span class="cm-variable-2">factor</span>;
}

<span class="cm-keyword">let</span> <span class="cm-def">twice</span> <span class="cm-operator">=</span> <span class="cm-variable">multiplier</span>(<span class="cm-number">2</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">twice</span>(<span class="cm-number">5</span>));
<span class="cm-comment">// → 10</span></pre>

<p>به طور صریح نیازی به متغیر <code>local</code> از مثال <code>wrapValue</code> وجود ندارد به این علت که پارامتر خود یک متغیر محلی محسوب می شود.</p>

<p>درک و فکر کردن به برنامه‌هایی شبیه مثال بالا نیاز به مقدار تمرین دارد. یک مدل ذهنی خوب این است که فرض کنید که مقدارهای تابع، کد،‌بدنه و محیطی که در آن ایجاد شده اند را نگه داری می کنند. زمانی که فراخوانی می شوند، بدنه تابع محیطی که در آن ایجاد شده را می بیند نه محیطی که در آن فراخوانی شده است.</p>

<p><a class="p_ident" id="p_wwW0b1Mdqm" href="#p_wwW0b1Mdqm" tabindex="-1" role="presentation"></a>در مثال، <code>multiplier</code> فراخوانی شده و محیطی را ایجاد کرده است که در آن پارامتر <code>factor</code> به 2 اختصاص داده شده است. مقدار تابعی که برمی گرداند، که خود در <code>twice</code> ذخیره شده است، محیط را به خاطر می آورد. بنابراین در هنگام فراخوانی، آرگومانش را در 2 ضرب می کند.</p>

<h2><a class="h_ident" id="h_d8u9yeE6bu" href="#h_d8u9yeE6bu" tabindex="-1" role="presentation"></a>بازگشتی</h2>

<p>فراخوانی یک تابع توسط خودش امری کاملا قابل قبول است البته تا زمانی که به نحوی انجام شود که باعث سرریز پشته نشود. تابعی که خودش را فراخوانی می کند را تابع <em>بازگشتی</em> می نامند. بازگشت این امکان را فراهم می سازد که بعضی توابع را به سبک دیگری بتوان نوشت. به عنوان مثال، به سبک دیگری که می توان تابع <code>power</code> را پیاده سازی کرد توجه نمایید:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_agdELfiRGm" href="#c_agdELfiRGm" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">power</span>(<span class="cm-def">base</span>, <span class="cm-def">exponent</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">exponent</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
    <span class="cm-keyword">return</span> <span class="cm-number">1</span>;
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">base</span> <span class="cm-operator">*</span> <span class="cm-variable">power</span>(<span class="cm-variable-2">base</span>, <span class="cm-variable-2">exponent</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>);
  }
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>(<span class="cm-number">2</span>, <span class="cm-number">3</span>));
<span class="cm-comment">// → 8</span></pre>

<p>این روش  نسبتا شبیه راهی است که ریاضی‌دانان به توان رساندن اعداد را تعریف می کنند و احتمالا مفهوم  این تابع را نسب به نوع استفاده از حلقه‌ها، به شکل روشن تری (خواناتر) توصیف می کند. تابع خودش را چندین مرتبه با توان های کوچکتر فراخوانی می کند تا به حاصل مجموعه ضرب‌ها برسد.</p>

<p>اما این روش پیاده‌سازی یک مشکل مهم دارد: در پیاده‌سازی‌های رایج جاوااسکریپت، تقریبا سه برابر کندتر از روش استفاده از حلقه عمل می کند. پیمایش یک حلقه‌ی ساده بسیار هزینه‌ی کمتری نسبت به فراخوانی چندباره‌ی یک تابع دارد.</p>

<p>معمای انتخاب بین خوانایی کد و سرعت اجرای بهتر، مساله‌ی جالبی است. می توان آن را به عنوان نوعی از مسائل مربوط به انسان پسند بودن و ماشین پسند بودن در نظر گرفت. تقریبا همه‌ی برنامه ها را می توان سریع‌تر ساخت اما با بزرگتر کردن و پیچیده کردن آن. برنامه‌نویس بایستی تصمیمی بر اساس تعادل این دو بگیرد.</p>

<p>در مورد تابع <code>power</code> که پیش تر آمد، روش استفاده از حلقه همچنان نسبتا قابل خواندن و فهمیدن است. زیاد توجیه ندارد که آن را با روش بازگشتی جایگزین کنیم. اگرچه گاهی یک برنامه با گونه‌ای از مفاهیم پیچیده روبرو است که صرف نظر کردن از مقداری سرعت یا کارایی در برابر سرراستی بیشتر گزینه‌ای جذاب به نظر می رسد.</p>

<p>نگرانی در باره‌ی سرعت/کارایی برنامه می تواند شما را از مساله اصلی دور کند. شما هنگام برنامه نویسی مشغول حل مساله‌ای مشکل هستید و وقتی فاکتور پیچیده‌ی دیگری به طور همزمان شما را نگران کند، باعث می شود که نتوانید جلو بروید.</p>

<p>بنابراین، همیشه در ابتدا کدی را بنویسید که به طور صحیح کار می کند و قابل خواندن است. اگر نگرانید که خیلی کند عمل می کند – که معمولا این طور نخواهد بود،‌ چرا که اکثر کدها آن قدر به تعداد بالا اجرا نمی شوند که زمان قابل توجهی بگیرند- می توانید بعد از اتمام، اندازه گیری کرده و در صورت نیاز بهبودش بدهید.</p>

<p>نمی توان فرض کرد که همیشه روش استفاده از بازگشتی نسبت به حلقه، فاقد کارایی است. بعضی مسائل واقعا به روش بازگشتی بهتر و کاراتر حل می شوند. اکثر این مسائل مربوط به پیمایش و پردازش چندین شاخه که هر کدام ممکن است از شاخه‌های دیگر تشکیل شده باشند، می شوند.</p>

<p id="recursive_puzzle"><a class="p_ident" id="p_gsxOCL/1VV" href="#p_gsxOCL/1VV" tabindex="-1" role="presentation"></a>به این معما توجه کنید: با شروع از عدد 1 و افزودن مکرر عدد 5 یا ضرب در عدد 3، بی نهایت عدد جدید می توان تولید کرد. چگونه می توانید تابعی بنویسید که عددی را گرفته و دنباله‌ای از ضرب و جمع‌هایی که منجر به تولید آن عدد شده است را برگرداند؟</p>

<p><a class="p_ident" id="p_bCSmZ5NN6U" href="#p_bCSmZ5NN6U" tabindex="-1" role="presentation"></a>به عنوان مثال، عدد 13 را می توان با یک ضرب در 3 و دوبار افزودن 5 بدست آورد در حالیکه عددی مثل 15 را اصلا نمی توان به این شیوه تولید کرد.</p>

<p>راه حل استفاده از روش بازگشتی:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_WGJ7JdCP7T" href="#c_WGJ7JdCP7T" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">findSolution</span>(<span class="cm-def">target</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">find</span>(<span class="cm-def">current</span>, <span class="cm-def">history</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">current</span> <span class="cm-operator">==</span> <span class="cm-variable-2">target</span>) {
      <span class="cm-keyword">return</span> <span class="cm-variable-2">history</span>;
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">current</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">target</span>) {
      <span class="cm-keyword">return</span> <span class="cm-atom">null</span>;
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">return</span> <span class="cm-variable-2">find</span>(<span class="cm-variable-2">current</span> <span class="cm-operator">+</span> <span class="cm-number">5</span>, <span class="cm-string-2">`(${</span><span class="cm-variable-2">history</span><span class="cm-string-2">}</span> <span class="cm-string-2">+ 5)`</span>) <span class="cm-operator">|</span><span class="cm-operator">|</span>
             <span class="cm-variable-2">find</span>(<span class="cm-variable-2">current</span> <span class="cm-operator">*</span> <span class="cm-number">3</span>, <span class="cm-string-2">`(${</span><span class="cm-variable-2">history</span><span class="cm-string-2">}</span> <span class="cm-string-2">* 3)`</span>);
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">find</span>(<span class="cm-number">1</span>, <span class="cm-string">&quot;1&quot;</span>);
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">findSolution</span>(<span class="cm-number">24</span>));
<span class="cm-comment">// → (((1 * 3) + 5) * 3)</span></pre>

<p>توجه داشته باشید که برنامه‌ی بالا لزوما <em>کوتاه‌ترین</em> دنباله‌ی عملیات را پیدا نمی کند. هدف تابع فقط پیدا کردن هر دنباله‌ای از عملیات صحیح است.</p>

<p>اگر متوجه چگونگی کارکرد تابع بالا نشدید، نگران نباشید. بیایید با هم آن را بررسی کنیم چرا که تمرین بسیار خوبی برای تفکر بازگشتی است.</p>

<p>تابع درونی <code>find</code> عمل اصلی بازگشتی را انجام می دهد. دو آرگومان می گیرد که شامل عدد فعلی و رشته‌ای است که نحوه رسیدن به عدد را ضبط می کند. اگر راه حلی پیدا کرد ، رشته‌ای حاوی دنباله‌ی عملیات تا عدد مورد نظر را بر می گرداند. اگر راه حلی وجود نداشت، مقدار <code>null</code> را بر می گرداند.</p>

<p><a class="p_ident" id="p_ZvedimMnyC" href="#p_ZvedimMnyC" tabindex="-1" role="presentation"></a>برای این کار، تابع یکی از این سه کار را انجام می دهد. اگر عدد فعلی عدد هدف بود، تاریخچه‌ی فعلی (history) به عنوان پاسخ برگردانده می شود. اگر عدد فعلی از عدد هدف بزرگتر بود، معنایی ندارد که کاوش بیشتری برای کشف تاریخچه انجام شود زیرا هر عمل جمع یا ضرب عدد را فقط بزرگتر می کند بنابراین مقدار <code>null</code> را برمی‌گرداند. در نهایت، اگر هنوز عدد فعلی از عدد هدف کوچکتر باشد، تابع هر دو مسیر ممکن که از عدد فعلی شروع می شود را آزمایش می کند و این کار را با دوبار فراخوانی خودش، یکبار برای جمع و یکبار برای ضرب انجام می دهد. اگر اولین فراخوانی چیزی به غیر از <code>null</code> را تولید کرد، آن را بر می گرداند. در غیر این صورت، فراخوانی دوم بازگردانده می شود – فارغ از اینکه رشته یا <code>null</code> را تولید کند.</p>

<p><a class="p_ident" id="p_vTB6PsMp4Q" href="#p_vTB6PsMp4Q" tabindex="-1" role="presentation"></a>برای درک بهتر نحوه عملکرد تابع اجازه دهید به همه‌ی فراخوانی‌های <code>find</code> که برای پیدا کردن جواب مساله برای عدد 13 اتفاق می افتد نگاهی بیاندازیم.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_KtyfRslIz2" href="#c_KtyfRslIz2" tabindex="-1" role="presentation"></a>find(1, &quot;1&quot;)
  find(6, &quot;(1 + 5)&quot;)
    find(11, &quot;((1 + 5) + 5)&quot;)
      find(16, &quot;(((1 + 5) + 5) + 5)&quot;)
        too big
      find(33, &quot;(((1 + 5) + 5) * 3)&quot;)
        too big
    find(18, &quot;((1 + 5) * 3)&quot;)
      too big
  find(3, &quot;(1 * 3)&quot;)
    find(8, &quot;((1 * 3) + 5)&quot;)
      find(13, &quot;(((1 * 3) + 5) + 5)&quot;)
        found!</pre>

<p>تورفتگی موجود در کد بالا برای نشان دادن عمق پشته‌ی فراخوانی توابع است. اولین بار که <code>find</code> فراخوانی می شود، خودش را برای کاوش راه حلی که با <bdo><code>(1 + 5)</code></bdo> شروع می شود فراخوانی می کند. این فراخوانی با استفاده بازگشت، تمامی راه حل هایی که عددی کمتر یا برابر عدد هدف را تولید می کند را مورد کاوش قرار می دهد. با توجه به این که این فراخوانی نمی تواند به راه حلی برسد مقدار <code>null</code> به عنوان خروجی فراخوانی اول بازگردانده می شود. عملگر <code>||</code> در اینجا باعث کاوش <bdo><code>(1 * 3)</code></bdo> می شود. این جستجو شانس بیشتری دارد به دلیل اینکه اول فراخوانی بازگشتی است که در دل یک فراخوانی بازگشتی دیگر قرار گرفته تا عدد هدف را تولید کند. درونی ترین فراخوانی بازگشتی یک رشته را بر می گرداند و هر کدام از عملگرهای <code>||</code> در فراخوانی‌های میانی آن رشته را دست به دست می کنند تا در نهایتا راه حل برگردانده شود.</p>

<h2><a class="h_ident" id="h_sAB7FPnQE6" href="#h_sAB7FPnQE6" tabindex="-1" role="presentation"></a>رشد توابع</h2>

<p>دو روش دیگر به طور طبیعی باعث می شود که به سراغ استفاده از توابع در برنامه برویم.</p>

<p>اول زمانی است که متوجه می شوید در حال تکرار کد بسیار مشابه‌ای در چندین جای برنامه هستید. ترجیح می دهیم از این کار اجتناب کنیم چراکه داشتن کد بیشتر به معنای فضای بیشتر برای پنهان شدن اشتباهات است و همچنین کار بیشتر برای افرادی که قصد دارند با خواندن کد برنامه را بفهمند. بنابراین قسمت تکراری  را گرفته و نام خوبی برای آن انتخاب می کنیم و آن را به تابع تبدیل می کنیم.</p>

<p>حالت دوم زمانی است که متوجه می شوید که به قابلیتی در برنامه نیاز دارید اما هنوز آن را کد نویسی نکرده اید که می تواند به عنوان یک تابع تعریف شود. در این صورت ابتدا نامی برای این تابع در نظر می گیرد و بعدا بنده‌ی آن را می نویسید. ممکن است حتی از تابع مورد نظر در دیگر کدها استفاده کنید قبل از اینکه خود تابع را تعریف کنید.</p>

<p>سختی پیدا کردن یک نام خوب برای یک تابع نشانه خوبی است تا بفهمیم که مفهومی که قصد داریم به تابع تبدیلش کنیم چقدر برای ما شفاف و روشن است. اجازه بدهید تا مثالی را بررسی کنیم.</p>

<p><a class="p_ident" id="p_b+PAE+H+pa" href="#p_b+PAE+H+pa" tabindex="-1" role="presentation"></a>قصد داریم تا برنامه‌ای بنویسیم که دو عدد را چاپ کند: تعداد گاو‌ها و مرغ‌های یک مزرعه به همراه کلمات <code>Cows</code> و <code>Chickens</code> بعد از آن ها و نشان دادن هر دو عددها با طول 3 رقم ( استفاده از 0 برای ترازبندی)</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_NGDR3Ll2Zn" href="#c_NGDR3Ll2Zn" tabindex="-1" role="presentation"></a>007 Cows
011 Chickens</pre>

<p>با توجه به مساله به تابعی با دو آرگومان نیاز داریم. تعداد گاو‌ها و تعداد مرغ‌ها.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_RO+Vw8FSPK" href="#c_RO+Vw8FSPK" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">printFarmInventory</span>(<span class="cm-def">cows</span>, <span class="cm-def">chickens</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">cowString</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">cows</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">cowString</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>) {
    <span class="cm-variable-2">cowString</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;0&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">cowString</span>;
  }
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">cowString</span><span class="cm-string-2">}</span> <span class="cm-string-2">Cows`</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">chickenString</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">chickens</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">chickenString</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>) {
    <span class="cm-variable-2">chickenString</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;0&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">chickenString</span>;
  }
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">chickenString</span><span class="cm-string-2">}</span> <span class="cm-string-2">Chickens`</span>);
}
<span class="cm-variable">printFarmInventory</span>(<span class="cm-number">7</span>, <span class="cm-number">11</span>);</pre>

<p>استفاده از <bdo><code>.length</code></bdo> بعد از مقدار رشته‌ای طول رشته را به ما می دهد. بنابراین، حلقه <code>while</code> عمل افزودن صفر به ابتدای رشته‌ی اعداد را تا زمانی که حداقل طول آن سه کاراکتر بشود ادامه می دهد.</p>

<p>ماموریت تمام است! اما درست زمانی که قرار است برنامه را برای کشاورز مثال‌مان ( به همراه صورت حساب) ارسال کنیم، با ما تماس می گیرد و اعلام می کند که اخیرا پرورش خوک را نیز شروع کرده است و آیا ما می توانیم قابلیت نرم افزار را افزایش داده تا تعداد خوک ها را نیز چاپ کند؟</p>

<p>حتما می توانیم. اما درست وقتی که یک بار دیگر در حال کپی و الصاق آن چهار خط هستیم، کمی صبر کرده و تجدید نظر می کنیم. بایستی راه بهتری برای این کار وجود داشته باشد. اولین تلاش ما اینگونه است:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_RHETS/If7p" href="#c_RHETS/If7p" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">printZeroPaddedWithLabel</span>(<span class="cm-def">number</span>, <span class="cm-def">label</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">numberString</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">number</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">numberString</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>) {
    <span class="cm-variable-2">numberString</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;0&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">numberString</span>;
  }
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">numberString</span><span class="cm-string-2">}</span> <span class="cm-string-2">${</span><span class="cm-variable-2">label</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
}

<span class="cm-keyword">function</span> <span class="cm-def">printFarmInventory</span>(<span class="cm-def">cows</span>, <span class="cm-def">chickens</span>, <span class="cm-def">pigs</span>) {
  <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-variable-2">cows</span>, <span class="cm-string">&quot;Cows&quot;</span>);
  <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-variable-2">chickens</span>, <span class="cm-string">&quot;Chickens&quot;</span>);
  <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-variable-2">pigs</span>, <span class="cm-string">&quot;Pigs&quot;</span>);
}

<span class="cm-variable">printFarmInventory</span>(<span class="cm-number">7</span>, <span class="cm-number">11</span>, <span class="cm-number">3</span>);</pre>

<p><a class="p_ident" id="p_zWGN4dSOxe" href="#p_zWGN4dSOxe" tabindex="-1" role="presentation"></a>روش جدید به خوبی کار می کند. اما نام <code>printZeroPaddedWithLabel</code> کمی ناجور به نظر می رسد. به نظر می رسد که سه چیز مختلف – چاپ کردن(printing)، ترازکردن با صفر(zero-padding) و افزودن برچسب (adding a lable) – در یک تابع مخلوط شده است.</p>

<p>به جای به دوش کشیدن کل قسمت تکراری در یک تابع، اجازه دهید یک <em>مفهوم</em> را انتخاب کنیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_L3v+xO5gBH" href="#c_L3v+xO5gBH" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">zeroPad</span>(<span class="cm-def">number</span>, <span class="cm-def">width</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">string</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">number</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">string</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">width</span>) {
    <span class="cm-variable-2">string</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;0&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">string</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">string</span>;
}

<span class="cm-keyword">function</span> <span class="cm-def">printFarmInventory</span>(<span class="cm-def">cows</span>, <span class="cm-def">chickens</span>, <span class="cm-def">pigs</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable">zeroPad</span>(<span class="cm-variable-2">cows</span>, <span class="cm-number">3</span>)<span class="cm-string-2">}</span> <span class="cm-string-2">Cows`</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable">zeroPad</span>(<span class="cm-variable-2">chickens</span>, <span class="cm-number">3</span>)<span class="cm-string-2">}</span> <span class="cm-string-2">Chickens`</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable">zeroPad</span>(<span class="cm-variable-2">pigs</span>, <span class="cm-number">3</span>)<span class="cm-string-2">}</span> <span class="cm-string-2">Pigs`</span>);
}

<span class="cm-variable">printFarmInventory</span>(<span class="cm-number">7</span>, <span class="cm-number">16</span>, <span class="cm-number">3</span>);</pre>

<p>داشتن یک تابع با یک نام خوب و واضح مثل <code>zeroPad</code> کار را برای کسی که قصد دارد کد برنامه را بفهمد آسان تر خواهد کرد. همچنین می تواند در موقعیت‌های بیشتری مورد استفاده قرار گیرد تا اینکه مخصوص فقط این برنامه باشد. به عنوان مثال، می توانید از این تابع در چاپ جدولی از اعداد که به خوبی تراز شده اند استفاده کنید.</p>

<p>چقدر تابع‌مان می <em>باید</em> هوشمند و جامع باشد بسازیم؟  می توانیم هر تابعی را بنویسیم ازتابعی که عمل بسیار ساده افزودن کاراکتر برای تراز عدد در سه کاراکتر را انجام می دهد تا یک سیستم پیچیده عمومی قالب‌بندی اعداد که قادر است اعداد اعشاری، منفی، ترازبندی نقطه‌ها، فاصله‌گذاری با کاراکترهای مختلف و غیره را مدیریت کند.</p>

<p><a class="p_ident" id="p_8XiGfaKHnK" href="#p_8XiGfaKHnK" tabindex="-1" role="presentation"></a>یه قاعده کاربردی در اینجا این است که هوشمندی بیشتری به تابع اضافه نکنیم  مگر در حالتی که قطعا مطمئن هستیم که از آن استفاده خواهیم کرد. ممکن است وسوسه شویم که برای هرعملکرد کوچکی که نیاز داریم ، چهارچوب‌هایی(framework) عمومی بنویسیم. در مقابل این وسوسه باید مقاومت کرد. در غیر این صورت برنامه جلو نخواهد رفت و در پایان کدهای بسیاری خواهید نوشت که هرگز استفاده نخواهید کرد.</p>

<h2 id="pure"><a class="h_ident" id="h_Nm9AGiwA2E" href="#h_Nm9AGiwA2E" tabindex="-1" role="presentation"></a>توابع و اثرات جانبی</h2>

<p>به طور کلی می توان توابع را به آن‌هایی که برای اثرات جانبی‌شان فراخوانی می شوند و آن‌هایی که برای مقداری که برمی گردانند فراخوانی می شوند تقسیم کرد. (اگرچه قطعا می توان تابعی داشت که هم اثر جانبی داشته باشد و هم مقداری را بازگرداند).</p>

<p>اولین تابع کمکی که در مثال مربوط به مثال مزرعه آمد، تابع <code>printZeroPaddedWithLabel</code> برای اثر جانبی‌اش فراخوانی شد: چاپ یک خط در خروجی. در نسخه‌ی دوم، تابع <code>zeroPad</code> برای مقداری که برمی‌گرداند  فراخوانده شد. اینکه تابع دوم در موقعیت های بیشتری نسبت به تابع اول کاربرد دارد تصادفی نیست. توابعی که مقادیری را ایجاد می کنند را راحتتر می توان به شکل های جدید ترکیب کرد نسبت به توابعی که مستقیما اثرات جانبی خاصی را اجرا می کنند.</p>

<p><a class="p_ident" id="p_MNdAzDkH2+" href="#p_MNdAzDkH2+" tabindex="-1" role="presentation"></a>یک تابع <em>ناب</em> (pure) شکل خاصی از یک تابعی است که مقداری را بر می گرداند و نه تنها خودش اثر جانبی ندارد، به اثرات جانبی دیگر کدها نیز وابستگی ندارد – مثلا متغیرهای جهانی که ممکن است در کدهای دیگر تغییر کنند را مورد استفاده قرار نمی دهد. یک تابع ناب ویژگی خوبش در این است که اگر با آرگومان‌های ثابت و مشابهی فراخوانی شود، همیشه مقدار مشابهی را برمیگرداند (و رفتار متفاوتی انجام نمی دهد). فراخوانی تابعی با این ویژگی را می توان بدون تغییر در معنای کد برنامه، معادل مقدار بازگشتی‌اش در نظر گرفت. زمانی که از صحت عملکرد یک تابع ناب مطمئن نیستید به راحتی می توانید با فراخوانی، آن را تست کنید و اگر در آن بستر (context) به درستی کار کرد، در همه‌ی بسترها هم به درستی کار خواهد کرد. توابع غیرناب اما برای آزمایش نیاز به شرایط و پیش‌نیازهای بیشتری دارند.</p>

<p>البته نیازی نیست هنگامی که توابعی می نویسید که ناب نیستند احساس بدی داشته باشید یا اینکه برای حذف آن‌ها از کدهایتان جنگی راه بیاندازید. اثرات جانبی معمولا کاربرد خودشان را دارند.  مثلا هیچ راه نابی برای نوشتن نسخه‌ای از تابع <code>console.log</code> وجود ندارد و مشخص است که <code>console.log</code> بسیار مفید است. بعضی کارها را اگر به کمک اثرات جانبی انجام دهیم راحت تر و سریع‌تر می توان عملی کرد که در این صورت سرعت محاسبه‌ی برنامه را می توان دلیلی بر اجتناب از تابع ناب دانست.</p>

<h2><a class="h_ident" id="h_EzvDUHyjs2" href="#h_EzvDUHyjs2" tabindex="-1" role="presentation"></a>خلاصه</h2>

<p>این فصل به شما نوشتن توابع خودتان را یاد داد. کلمه‌ی کلیدی <code>function</code> زمانی که به عنوان یک عبارت استفاده می شود، می تواند یک مقدار تابع ایجاد کنید. زمانی‌ هم که به عنوان یک دستور استفاده می شود، متغیری را اعلان می کند و تابعی را به عنوان مقدار آن به آن اختصاص می دهد. روش پیکانی نیز راهی دیگر برای ایجاد توابع است.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_x2/+thzlca" href="#c_x2/+thzlca" tabindex="-1" role="presentation"></a><span class="cm-comment">// Define f to hold a function value</span>
<span class="cm-keyword">const</span> <span class="cm-def">f</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">a</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-number">2</span>);
};

<span class="cm-comment">// Declare g to be a function</span>
<span class="cm-keyword">function</span> <span class="cm-def">g</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">*</span> <span class="cm-variable-2">b</span> <span class="cm-operator">*</span> <span class="cm-number">3.5</span>;
}

<span class="cm-comment">// A less verbose function value</span>
<span class="cm-keyword">let</span> <span class="cm-def">h</span> <span class="cm-operator">=</span> <span class="cm-def">a</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">a</span> <span class="cm-operator">%</span> <span class="cm-number">3</span>;</pre>

<p>نقطه‌ی کلیدی در فهم توابع، درک مفهوم حوزه‌ها است. هر بلاک از کد حوزه‌ی جدیدی را ایجاد می کند.  پارامترها و متغیرهایی که درون یک بلاک اعلان می شوند نسبت به آن تابع محلی هستند، و از بیرون بلاک قابل دسترسی نیستند. متغیرهایی که با کلیدواژه‌ی <code>var</code> ایجاد می شوند به شکل متفاوتی عمل می کنند – محدوده‌ی آن تا پایان حوزه‌ی نزدیک ترین تابع یا فضای سراسری برنامه است.</p>

<p>جداسازی قابلیت‌های برنامه به شکل توابع متفاوت بسیار مفید است. باعث می شود که از تکرار بی مورد پرهیز کنید. همچنین توابع باعث می شوند که یک برنامه به وسیله گروهبندی کدها به قسمت‌هایی که هر کدام کار خاصی انجام می دهند، سازماندهی بشود.</p>

<h2><a class="h_ident" id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe" tabindex="-1" role="presentation"></a>Exercises</h2>

<h3><a class="i_ident" id="i_R74RC5FV2X" href="#i_R74RC5FV2X" tabindex="-1" role="presentation"></a>کمینه</h3>

<p>در <a href="02_program_structure.html#return_values">فصل قبل</a> با تابع استاندارد <code>Math.min</code> که کوچکترین عدد را از بین آرگومان‌های ورودی برمی گرداند آشنا شدید. خودمان هم می توانیم این کار را برنامه نویسی کنیم. تابعی به نام <code>min</code> بنویسید که دو آرگومان دریافت کرده و کوچکترین آن‌ها را باز می‌گرداند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_zoK4eQ6E3E" href="#c_zoK4eQ6E3E" tabindex="-1" role="presentation"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">min</span>(<span class="cm-number">0</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → 0</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">min</span>(<span class="cm-number">0</span>, <span class="cm-operator">-</span><span class="cm-number">10</span>));
<span class="cm-comment">// → -10</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_jbGq7vKDsS" href="#p_jbGq7vKDsS" tabindex="-1" role="presentation"></a>If you have trouble putting braces and parentheses in the right place to get a valid function definition, start by copying one of the examples in this chapter and modifying it.</p>

<p><a class="p_ident" id="p_V+p4wKaMty" href="#p_V+p4wKaMty" tabindex="-1" role="presentation"></a>A function may contain multiple <code>return</code> statements.</p>

</div></div>

<h3><a class="i_ident" id="i_lyUVxDnHs6" href="#i_lyUVxDnHs6" tabindex="-1" role="presentation"></a>بازگشت</h3>

<p>قبلا دیده بودایم که عملگر <code>%</code> (باقی مانده) را می توان برای تشخیص زوج یا فرد بودن عدد استفاده کرد که برای این کار با <bdo><code>% 2</code></bdo> بخش پذیری بر دو مورد آزمایش قرار می گرفت. در اینجا با راهی دیگر برای تشخیص زوج یا فرد بودن یک عدد صحیح مثبت آشنا می شویم:</p>

<ul>

<li>

<p>صفر را زوج در نظر می گیریم</p></li>

<li>

<p>یک فرد است</p></li>

<li>

<p><a class="p_ident" id="p_KpgZOkANgN" href="#p_KpgZOkANgN" tabindex="-1" role="presentation"></a>برای هر عددی دیگر <em>N</em> زوج بودن آن مشابه <bdo><em>N</em> - 2</bdo> خواهد بود.</p></li></ul>

<p>تابع بازگشتی <code>isEven</code> را با توجه به توضیحات بالا تعریف کنید. تابع باید پارامتری مثبت و از جنس اعداد صحیح دریافت کند و مقداری از جنس بولی برگرداند.</p>

<p><a class="p_ident" id="p_F8nwhNCAnQ" href="#p_F8nwhNCAnQ" tabindex="-1" role="presentation"></a>تابع را با مقادیر 50 و 75 تست کنید. بررسی کنید که اگر <bdo>-1</bdo> را به آن بدهید چه خواهد شد. چرا؟ آیا می توانید راهی برای حل مشکل پیش آمده پیدا کنید؟</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_7Dyz/3MMqh" href="#c_7Dyz/3MMqh" tabindex="-1" role="presentation"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">isEven</span>(<span class="cm-number">50</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">isEven</span>(<span class="cm-number">75</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">isEven</span>(<span class="cm-operator">-</span><span class="cm-number">1</span>));
<span class="cm-comment">// → ??</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_Y58IopmAbB" href="#p_Y58IopmAbB" tabindex="-1" role="presentation"></a>Your function will likely look somewhat similar to the inner <code>find</code> function in the recursive <code>findSolution</code> <a href="03_functions.html#recursive_puzzle">example</a> in this chapter, with an <code>if</code>/<code>else if</code>/<code>else</code> chain that tests which of the three cases applies. The final <code>else</code>, corresponding to the third case, makes the recursive call. Each of the branches should contain a <code>return</code> statement or in some other way arrange for a specific value to be returned.</p>

<p><a class="p_ident" id="p_QIaN+xYJ+M" href="#p_QIaN+xYJ+M" tabindex="-1" role="presentation"></a>When given a negative number, the function will recurse again and again, passing itself an ever more negative number, thus getting further and further away from returning a result. It will eventually run out of stack space and abort.</p>

</div></div>

<h3><a class="i_ident" id="i_YU8xeCexae" href="#i_YU8xeCexae" tabindex="-1" role="presentation"></a>شمارش دانه</h3>

<p><a class="p_ident" id="p_D3C8NOezly" href="#p_D3C8NOezly" tabindex="-1" role="presentation"></a>برای بدست آوردن کاراکتر یا حرف Nام یک رشته، می توانید از <code>&quot;string&quot;[N]</code> استفاده کنید. مقداری که برگردانده می شود رشته‌ای است که فقط یک کاراکتر دارد. (مثلا رشته‌ی <code>&quot;b&quot;</code>). کاراکتر اول در جایگاه صفرم قرار دارد. بنابراین آخرین کاراکتر در جایگاه <bdo><code>string.<wbr>length - 1</code></bdo> قرار بگیرد. به عبارتی دیگر، یک رشته‌ی دو کاراکتری طولش 2 کاراکتر است و کاراکتر‌هایش در جایگاه 0 و 1 قرار دارند.</p>

<p><a class="p_ident" id="p_rk8oHfWl0P" href="#p_rk8oHfWl0P" tabindex="-1" role="presentation"></a>تابعی به نام <code>countBs</code> بنویسید که رشته ای را به عنوان تنها آرگومانش می پذیرد و عددی را برمیگرداند که نشان می دهد چند کاراکتر “B” بزرگ در رشته وجود دارد.</p>

<p>بعد، تابعی به نام <code>countChar</code> بنویسید که شبیه <code>countBs</code> کار می کند اما آرگومان دومی نیز دریافت می کند که مشخص کننده کاراکتری است که بایستی شمرده بشود ( به جای اینکه فقط B شمرده شود ). تابع <code>countBs</code> را بازنویسی کنید تا این ویژگی جدید را داشته باشد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_QN+QdpdCe+" href="#c_QN+QdpdCe+" tabindex="-1" role="presentation"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">countBs</span>(<span class="cm-string">&quot;BBC&quot;</span>));
<span class="cm-comment">// → 2</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">countChar</span>(<span class="cm-string">&quot;kakkerlak&quot;</span>, <span class="cm-string">&quot;k&quot;</span>));
<span class="cm-comment">// → 4</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_iXtbGSBd1r" href="#p_iXtbGSBd1r" tabindex="-1" role="presentation"></a>Your function will need a loop that looks at every character in the string. It can run an index from zero to one below its length (<code>&lt; string.<wbr>length</code>). If the character at the current position is the same as the one the function is looking for, it adds 1 to a counter variable. Once the loop has finished, the counter can be returned.</p>

<p><a class="p_ident" id="p_h0vFGXYL6A" href="#p_h0vFGXYL6A" tabindex="-1" role="presentation"></a>Take care to make all the bindings used in the function <em>local</em> to the function by properly declaring them with the <code>let</code> or <code>const</code> keyword.</p>

</div></div><nav><a href="02_program_structure.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="04_data.html" title="next chapter">▶</a></nav>
</article>
