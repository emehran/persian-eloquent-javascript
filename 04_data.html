<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ساختارهای داده: اشیاء و آرایه‌ها :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 4;var sandboxLoadFiles = ["code/journal.js","code/chapter/04_data.js"];</script><script>var clicky_site_ids = clicky_site_ids || []; clicky_site_ids.push(101171577);</script>
  <script async src="//static.getclicky.com/js"></script>

</head>

<article>
<nav><a href="03_functions.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="05_higher_order.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>فصل 4</span>ساختارهای داده: اشیاء و آرایه‌ها</h1>

<blockquote>

<p><a class="p_ident" id="p_2jmj7l5rSw" href="#p_2jmj7l5rSw" tabindex="-1" role="presentation"></a>در دو موقعیت از من پرسش شد، ‍'ببخشید، آقای بابیج اگر اعداد غلطی را به ماشین بدهی، ماشین پاسخ درست را خودش تولید می‌کند؟' [...] من نمی‌توانم به درستی درک کنم چه آشفتگی‌ ذهنی می‌تواند اینچنین سوالی را برانگیزد.</p>

<footer>چارلز بابیج, <cite>گذری بر زندگی یک فیلسوف (1864)</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_4.jpg" alt="Picture of a weresquirrel"></figure>

<p>اعداد، مقادیر بولی، و رشته‌ها عناصری هستند که ساختار داده‌‌ها از آن ها ساخته می‌شوند. اگرچه انواع زیادی از اطلاعات وجود دارند که نیاز به چیزی بیش از یک عنصر دارند. <em>اشیاء</em> این امکان را به ما می دهند که مقادیر مختلف – از جمله دیگر اشیاء – را با هم ترکیب کنیم و ساختارهای پیچیده‌تری را بسازیم.</p>

<p>برنامه‌هایی که تا کنون ساخته‌ایم فقط با انواع داده‌ی ساده کار می‌کردند. در این فصل ساختارهای داده‌ی پایه را معرفی می‌کنیم. در انتهای این فصل ، به اندازه کافی اطلاعات در اختیار دارید که نوشتن برنامه‌های کاربردی را شروع کنید.</p>

<p>این فصل با مثال‌های برنامه‌نویسی کم و بیش واقعی جلو می رود تا مفاهیم جدید را همانطور که در مسئله پیش می آیند، معرفی کند. کدهای مثال‌ها اغلب با توابع و متغیرهایی که پیش‌تر معرفی شده اند ساخته می‌شوند.</p>

<h2><a class="h_ident" id="h_d+Hn7Tmkxv" href="#h_d+Hn7Tmkxv" tabindex="-1" role="presentation"></a>انسان‌سنجاب</h2>

<p>هر از چند گاهی معمولا بین ساعت هشت تا ده شب ژاک متوجه می شود که تغییر شکل داده و به یک جونده کوچک با دمی پرپشت تبدیل می شود.</p>

<p>از طرفی، ژاک نسبتا خوشحال است که شبیه‌ به داستان‌های کلاسیک تبدیل به گرگ نمی شود. سنجاب شدن احتمالا مشکلات کمتری نسبت به گرگ شدن ایجاد می کند. به جای اینکه نگران باشد که اتفاقی همسایه‌اش را نخورد ( که خیلی ناجور است )، نگران خورده شدن توسط گربه‌ی همسایه است. بعد از دو مرتبه‌ای که روی شاخه‌ی باریک و لرزان بالای یک درخت بلوط، لخت و گیج، بیدار شد، درها و پنجره‌های  اتاقش را شب‌ها قفل می کرد و چندتایی گردو هم کف اتاق قرار می داد که سرگرم بماند.</p>

<p>این، مشکل گربه‌ی همسایه و درخت را حل می کرد. اما ژاک به دنبال این بود که از این مشکل به طور کلی رهایی یابد. تبدیل شدن‌های بی نظم و قاعده باعث شده بود که شک کند شاید چیز خاصی علت این مشکل باشد. برای مدتی،  فکر می کرد که این اتفاق در روزهایی رخ می دهد که نزدیک درخت بلوط بوده است. اما دوری از درخت بلوط هم کمکی نکرد و مشکل برطرف نشد.</p>

<p>ژاک با انتخاب روشی علمی تر، یک گزارش روزانه از همه‌ی فعالیت‌های یک روز و وضعیت تبدیل شدن به سنجاب را نگه‌داری می‌کند. با در دست داشتن این اطلاعات، او امیدوار است بتواند شرایطی که باعث می‌شود به سنجاب تبدیل شود را محدودتر کند.</p>

<p>اکنون اولین کاری که باید انجام دهد طراحی یک ساختار داده برای ذخیره این اطلاعات است.</p>

<h2><a class="h_ident" id="h_v3yvJ+5nHg" href="#h_v3yvJ+5nHg" tabindex="-1" role="presentation"></a>مجموعه‌های داده</h2>

<p><a class="p_ident" id="p_oZVqgDTFVc" href="#p_oZVqgDTFVc" tabindex="-1" role="presentation"></a>برای کار با داده‌های دیجیتال، ابتدا باید راهی برای ارائه‌ی آن‌ها در حافظه‌ی کامپیوتر (ماشین) بیابیم. به عنوان یک مثال ساده، فرض کنید که می خواهیم مجموعه ای از اعداد، 2، 3، 5، 7، و 11 را در حافظه قرار دهیم.</p>

<p>برای این کار می توانیم از رشته‌ها خلاقانه استفاده کنیم – به هر حال رشته ها می توانند هر طولی داشته باشند؛ پس می توان داده‌های زیادی درون آن‌ها قرار داد – و از نمایش رشته‌ای <bdo><code>&quot;2 3 5 7 11&quot;</code></bdo> استفاده کنیم. اما این کار ایرادهایی دارد. برای استفاده از اعداد، مجبور خواهید شد که به شکلی آن ها را از دل رشته ها استخراج و به نوع عدد تبدیل کنید.</p>

<p>خوشبختانه، جاوااسکریپت نوع داده‌ای فراهم می کند که به طور خاص برای ذخیره دنباله‌ای از مقدارها استفاده می شود. این نوع داده‌ی خاص <em>آرایه</em> نام دارد و به این صورت نوشته می شود که مقدارها بین براکت قرار می گیرند و با ویرگول جدا می‌شوند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_05cIH1hy/D" href="#c_05cIH1hy/D" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">listOfNumbers</span> <span class="cm-operator">=</span> [<span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">5</span>, <span class="cm-number">7</span>, <span class="cm-number">11</span>];
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">listOfNumbers</span>[<span class="cm-number">2</span>]);
<span class="cm-comment">// → 5</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">listOfNumbers</span>[<span class="cm-number">0</span>]);
<span class="cm-comment">// → 2</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">listOfNumbers</span>[<span class="cm-number">2</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>]);
<span class="cm-comment">// → 3</span></pre>

<p>برای دستیابی به عناصر درون یک آرایه نیز، از براکت‌ها استفاده می شود. یک جفت براکت که بلافاصله بعد از یک عبارت می آیند و بعد از آن عبارتی دیگر درون آن قرار می گیرد. با این کار عنصر مورد نظرمان را با استفاده از <em>شاخصی</em> که به وسیله عبارت داخل براکت‌ها مشخص می کنیم، در داخل عبارت سمت چپ جستجو می کنیم.</p>

<p id="array_indexing">اولین خانه‌ی یک آرایه، صفر است، نه یک. بنابراین اولین عنصر را می توان با <bdo><code>listOfNumbers[0]</code></bdo> به دست آورد.  شمارش از صفر، در تکنولوژی سابقه‌ای دیرینه دارد و در بعضی مواقع، کاری بسیار منطقی می‌باشد؛ اما ممکن است کمی زمان ببرد تا به آن عادت کنید. می توانید اندیس آرایه را به صورت تعداد آیتم هایی که باید از ابتدای آرایه گذشت تا به عنصر مورد نظر رسید، تصور کنید.</p>

<h2 id="properties"><a class="h_ident" id="h_DOvcyyR3ED" href="#h_DOvcyyR3ED" tabindex="-1" role="presentation"></a>خاصیت‌ها</h2>

<p>در فصل‌های قبل، با عبارت‌هایی روبرو شدیم که ظاهری ناآشنا داشتند مانند <bdo><code>myString.length</code></bdo> (برای بدست آوردن طول رشته) یا <code>Math.max</code> (برای یافتن بیشینه‌ی اعداد). این ها عبارت‌هایی هستند که به <em>خاصیتی</em> از یک مقدار دسترسی دارند. در مثال اول، به خاصیت <code>length</code> از مقدار <code>myString</code> اشاره می کنیم. در مورد دوم، به خاصیتی با نام <code>max</code> از شیء <code>Math</code> دسترسی پیدا کرده ایم ( که این شیء شامل مجموعه‌ای از ثابت ها و توابع ریاضی می‌باشد).</p>

<p>تقریبا همه‌ی مقدارهای جاوااسکریپت دارای خاصیت‌هایی می باشند. مورد استثنا <code>null</code> و <code>undefined</code>  است. اگر سعی کنید تا به خاصیتی از این دو اشاره کنید، با خطا مواجه خواهید شد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_FNR95AymUx" href="#c_FNR95AymUx" tabindex="-1" role="presentation"></a><span class="cm-atom">null</span>.<span class="cm-property">length</span>;
<span class="cm-comment">// → TypeError: null has no properties</span></pre>

<p><a class="p_ident" id="p_EfatjsUqKY" href="#p_EfatjsUqKY" tabindex="-1" role="presentation"></a>دو روش رایج برای دسترسی به خاصیت‌ها در جاوااسکریپت استفاده از نقطه و براکت است. هر دو روش <bdo><code>value.x</code></bdo> و <bdo><code>value[x]</code></bdo> به خاصیتی از <code>value</code> اشاره می‌کنند – اما نه لزوما به خاصیتی یکسان. تفاوت به نحوه‌ی تفسیر <code>x</code> بر می گردد. زمانی که از نقطه استفاده می کنیم، قسمت بعد از نقطه، بایستی نام متغیری معتبر باشد که مستقیما نام خاصیت را مشخص می کند. اما زمانی که از براکت استفاده می شود، عبارتی که بین براکت‌ها قرار می گیرد <em>ارزیابی</em> شده تا نام خاصیت مشخص شود. در حالیکه  <bdo><code>value.x</code></bdo> خاصیتی از <code>value</code> که نام آن “x” است را برمی‌گرداند، <bdo><code>value[x]</code></bdo> سعی می کند تا عبارت <code>x</code> را ارزیابی کرده و نتیجه‌ی آن را به عنوان نام خاصیت استفاده کند.</p>

<p><a class="p_ident" id="p_6/I9FI5SCH" href="#p_6/I9FI5SCH" tabindex="-1" role="presentation"></a>بنابراین اگر می دانید که نام خاصیت  مورد نظرتان <em>color</em> است، به سراغ <bdo><code>value.color</code></bdo> بروید. اگر قصد دارید به خاصیتی اشاره کنید که نامش در متغیر <code>i</code> ذخیره شده است ، می توانید از <bdo><code>value[i]</code></bdo> استفاده کنید. نام یک خاصیت می تواند هر رشته‌ای باشد، اما روش استفاده از نقطه، فقط روی نام‌هایی کار می کند که برای یک متغیر معتبر می باشند. بنابراین اگر قصد دارید تا به خاصیتی به نام <em>2</em> یا <bdo><em>John Doe</em></bdo> دسترسی داشته باشید، باید حتما از براکت‌ها استفاده کنید:‌<bdo><code>value[2]</code></bdo>  یا <bdo><code>value[&quot;John Doe&quot;]</code></bdo>.</p>

<p>عناصر درون یک آرایه به عنوان خاصیت‌های آن ذخیره می‌شوند که برای نام این خاصیت ها از اعداد استفاده می شود. چون نمی توان از نقطه برای دسترسی به نام‌های عدد استفاده کرد، و اغلب لازم است تا به خانه‌های آرایه با استفاده از متغیرها اشاره کنیم، باید از روش براکت‌ برای دستیابی به آن‌ها استفاده نماییم.</p>

<p><a class="p_ident" id="p_PVSXP1KLAQ" href="#p_PVSXP1KLAQ" tabindex="-1" role="presentation"></a>خاصیت <code>length</code> در آرایه‌ها نیز تعداد عناصری که در آرایه وجود دارد را نشان می دهد. نام این خاصیت (length)، نامی معتبر برای یک متغیر می‌باشد و ما از آن آگاه بودیم پس به سراغ روش <bdo><code>array.length</code></bdo> می رویم چراکه از <bdo><code>array[&quot;length&quot;]</code></bdo> آسان تر نوشته می شود.</p>

<h2 id="methods"><a class="h_ident" id="h_X5eRdH5+Re" href="#h_X5eRdH5+Re" tabindex="-1" role="presentation"></a>متدها</h2>

<p>هر دوی اشیاء رشته‌ای و آرایه‌ای، علاوه بر خاصیت <code>length</code> تعدادی خاصیت دیگر دارند که حاوی مقدارهایی از جنس تابع هستند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_prRDc5amqh" href="#c_prRDc5amqh" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">doh</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;Doh&quot;</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">typeof</span> <span class="cm-variable">doh</span>.<span class="cm-property">toUpperCase</span>);
<span class="cm-comment">// → function</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">doh</span>.<span class="cm-property">toUpperCase</span>());
<span class="cm-comment">// → DOH</span></pre>

<p>همه‌ی رشته‌ها خاصیت <code>toUpperCase</code> را دارند که در صورت فراخوانی، یک کپی از رشته‌ را با حروف بزرگ برمی‌گرداند. همچنین <code>toLowerCase</code> نیز وجود دارد که عکس آن عمل می کند.</p>

<p>جالب آن‌که، وقتی که <code>toUpperCase</code> فراخوانی می شود علی رغم اینکه مقداری به عنوان آرگومان دریافت نمی کند، این تابع به نحوی به رشته‌ی <code>&quot;Doh&quot;</code> دسترسی دارد (مقداری که خاصیت را روی آن فراخوانی کرده ایم). چگونگی کارکرد این موضوع در <a href="06_object.html#obj_methods">فصل 6</a> توضیح داده می شود.</p>

<p>به خاصیت‌هایی که حاوی تابع می‌باشند معمولا <em>متد</em> گفته می‌شود؛ متدهای مقداری که به آن تعلق دارند. همانطور که <code>toUpperCase</code> متدی از یک رشته محسوب می شود.</p>

<p id="array_methods">مثال پیش رو، دو متد را که می توانید از آن ها برای دستکاری آرایه‌ها استفاده کنید، شرح می دهد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_RiFZUNk6gr" href="#c_RiFZUNk6gr" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">sequence</span> <span class="cm-operator">=</span> [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>];
<span class="cm-variable">sequence</span>.<span class="cm-property">push</span>(<span class="cm-number">4</span>);
<span class="cm-variable">sequence</span>.<span class="cm-property">push</span>(<span class="cm-number">5</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sequence</span>);
<span class="cm-comment">// → [1, 2, 3, 4, 5]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sequence</span>.<span class="cm-property">pop</span>());
<span class="cm-comment">// → 5</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sequence</span>);
<span class="cm-comment">// → [1, 2, 3, 4]</span></pre>

<p>متد <code>push</code> را می‌توان برای افزودن مقدارها به انتهای یک آرایه استفاده کرد. متد <code>pop</code> عکس آن عمل می کند: آخرین مقداری که در انتهای یک آرایه وجود دارد را حذف کرده و برمی گرداند.</p>

<p>نام این دو متد در کارهای مرتبط با پشته‌ها از قدیم استفاده می شده است. یک <em>پشته‌</em>، در برنامه‌نویسی، ساختار داده‌ای است که این امکان را به شما می دهد تا مقادیر را به آن وارد کرده و به ترتیب عکس از آن خارج نمایید. بنابراین مقداری که آخر از همه وارد شده است، اول از همه خارج می شود. این کارها در برنامه‌نویسی رایج هستند – ممکن است پشته‌ی فراخوانی توابع که در <a href="03_functions.html#stack">فصل قبل</a> بحث شد را به خاطر بیاورید که نمونه ای از همین مفهوم است.</p>

<h2><a class="h_ident" id="h_0rblQKnqEa" href="#h_0rblQKnqEa" tabindex="-1" role="presentation"></a>آبجکت‌ها یا اشیاء</h2>

<p>برگردیم به مثال انسان‌سنجاب.  می توان مجموعه‌ای از گزارش‌های روزانه را به صورت یک آرایه نشان داد. اما گزارش‌ها فقط شامل رشته یا عدد نمی‌باشند – هر گزارش باید فهرستی از فعالیت‌ها به همراه یک مقدار بولی که نشان می دهد ژاک به سنجاب تبدیل شده است یا خیر را ذخیره کند. در حالت ایده‌آل، دوست داشتیم که این اطلاعات را با هم گروه‌بندی کرده و یک مقدار بسازیم و آن مقادیر گروه‌بندی شده را در یک آرایه‌ای از گزارش‌ها ذخیره کنیم.</p>

<p><a class="p_ident" id="p_FhUwfMRSPx" href="#p_FhUwfMRSPx" tabindex="-1" role="presentation"></a>مقادیری که از نوع <em>object</em> هستند دارای مجموعه‌ای از خاصیت‌های دلخواه می‌باشند . یکی از روش‌های ایجاد یک شیء استفاده از کروشه ها به عنوان یک عبارت است.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Y37a9WsXpl" href="#c_Y37a9WsXpl" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">day1</span> <span class="cm-operator">=</span> {
  <span class="cm-property">squirrel</span>: <span class="cm-atom">false</span>,
  <span class="cm-property">events</span>: [<span class="cm-string">&quot;work&quot;</span>, <span class="cm-string">&quot;touched tree&quot;</span>, <span class="cm-string">&quot;pizza&quot;</span>, <span class="cm-string">&quot;running&quot;</span>]
};
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">day1</span>.<span class="cm-property">squirrel</span>);
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">day1</span>.<span class="cm-property">wolf</span>);
<span class="cm-comment">// → undefined</span>
<span class="cm-variable">day1</span>.<span class="cm-property">wolf</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">day1</span>.<span class="cm-property">wolf</span>);
<span class="cm-comment">// → false</span></pre>

<p>درون کروشه ها، می توانیم لیستی از خاصیت‌ها را (که با ویرگول جدا می‌شوند)  تعریف کنیم. هر خاصیت به وسیله‌ی یک نام، یک کاراکتر دونقطه در جلوی‌ آن و یک عبارت که مقدار خاصیت را مشخص می کند تعریف می شود. زمانی که تعریف یک شیء به چند خط می کشد،‌ استفاده از تورفتگی در کد‌ها باعث افزایش خوانایی می شود. خاصیت‌هایی که نامشان نام معتبری برای یک متغیر محسوب نمی‌شوند یا اعداد، می بایست درون نقل قول قرار بگیرند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_n8ErtKNPW/" href="#c_n8ErtKNPW/" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">descriptions</span> <span class="cm-operator">=</span> {
  <span class="cm-property">work</span>: <span class="cm-string">&quot;Went to work&quot;</span>,
  <span class="cm-string cm-property">&quot;touched tree&quot;</span>: <span class="cm-string">&quot;Touched a tree&quot;</span>
};</pre>

<p>معنای آن این است که کروشه‌ها در جاوااسکریپت <em>دو</em> معنای متفاوت دارند. در شروع یک دستور، نشانگر شروع یک بلاک از دستورات، و در دیگر مکان‌ها، نمایانگر تعریف یک شیء می باشند. خوشبختانه، به ندرت کاربردی برای شروع یک دستور با یک شیء درون کروشه‌ها پیدا می شود، بنابراین ابهام بین این دو، مسئله‌ای ایجاد نمی کند.</p>

<p>اقدام به خواندن خاصیتی که وجود ندارد باعث تولید مقدار <code>undefined</code> می شود.</p>

<p>می توان مقداری را به یک خاصیت به وسیله‌ی عملگر <code>=</code> اختصاص داد. این کار باعث می شود که مقدار خاصیت مورد نظر – در صورت وجود – جایگزین شده یا در غیر این صورت یک خاصیت جدید در شیء به وجود بیاید.</p>

<p>استعاره‌ی بازوچه که برای متغیرها استفاده می‌شد در اینجا نیز کاربرد دارد. خاصیت‌ها به مقدارها <em>چنگ می زنند</em> و این مقدارها ممکن است توسط دیگر متغیرها و خاصیت ها نیز نگه داری شوند.  می توانید اشیاء را اختاپوسی در نظر بگیرید که بازوهای متعددی دارد که هر کدام از آن ها نامی دارد که روی آن نوشته شده است.</p>

<p>عملگر <code>delete</code> باعث قطع یک بازوچه از این اختاپوس می شود. این عملگر، یکانی است و اگر به خاصیتی اعمال شود، خاصیت نام‌برده را از شیء حذف می کند. استفاده از این عملگر زیاد رایج نیست، اما به هر حال قابل استفاده است.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_66M3B1wG98" href="#c_66M3B1wG98" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">anObject</span> <span class="cm-operator">=</span> {<span class="cm-property">left</span>: <span class="cm-number">1</span>, <span class="cm-property">right</span>: <span class="cm-number">2</span>};
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">anObject</span>.<span class="cm-property">left</span>);
<span class="cm-comment">// → 1</span>
<span class="cm-keyword">delete</span> <span class="cm-variable">anObject</span>.<span class="cm-property">left</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">anObject</span>.<span class="cm-property">left</span>);
<span class="cm-comment">// → undefined</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;left&quot;</span> <span class="cm-keyword">in</span> <span class="cm-variable">anObject</span>);
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;right&quot;</span> <span class="cm-keyword">in</span> <span class="cm-variable">anObject</span>);
<span class="cm-comment">// → true</span></pre>

<p>عملگر دودویی <code>in</code> اگر به یک رشته یا شیئی اعمال شود، مقداری از جنس بولی بر می گرداند که مشخص می کند که آن شیء دارای آن خاصیت می‌باشد یا خیر. تفاوت بین اختصاص <code>undefined</code> به یک خاصیت و حذف آن این است که در مورد اول، شیء مورد بحث همچنان آن خاصیت را دارد (اگرچه مقدار به درد بخوری ندارد) در حالیکه در مورد دوم خاصیت دیگر وجود ندارد و عملگر <code>in</code> مقدار <code>false</code> را بر می گرداند.</p>

<p>برای بدست آوردن خاصیت‌های یک شیء، می توانید از تابع <bdo><code>Object.keys</code></bdo> استفاده کنید. اگر شیءای را به آن بدهید، آرایه‌ای از نام خاصیت‌های شیء بر می گرداند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_0oaalmpqn6" href="#c_0oaalmpqn6" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Object</span>.<span class="cm-property">keys</span>({<span class="cm-property">x</span>: <span class="cm-number">0</span>, <span class="cm-property">y</span>: <span class="cm-number">0</span>, <span class="cm-property">z</span>: <span class="cm-number">2</span>}));
<span class="cm-comment">// → [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span></pre>

<p>تابع دیگری به نام <bdo><code>Object.assign</code></bdo> نیز وجوددارد که تمام خاصیت‌های یک شیء را در شیء دیگری کپی می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ngXKayzwiT" href="#c_ngXKayzwiT" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">objectA</span> <span class="cm-operator">=</span> {<span class="cm-property">a</span>: <span class="cm-number">1</span>, <span class="cm-property">b</span>: <span class="cm-number">2</span>};
<span class="cm-variable">Object</span>.<span class="cm-property">assign</span>(<span class="cm-variable">objectA</span>, {<span class="cm-property">b</span>: <span class="cm-number">3</span>, <span class="cm-property">c</span>: <span class="cm-number">4</span>});
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">objectA</span>);
<span class="cm-comment">// → {a: 1, b: 3, c: 4}</span></pre>

<p>آرایه‌ها نیز، در واقع شکل خاصی از اشیاء هستند که برای ذخیره‌ی دنباله‌ای از چیزها اختصاصی شده اند. اگر <bdo><code>typeof []</code></bdo>  را ارزیابی کنید، مقدار <code>&quot;object&quot;</code> تولید می شود. می توانید آن ها را به عنوان اختاپوس‌های درازی در نظر بگیرید که همه‌ی بازوهای آن‌ها به شکل ردیفی مرتب با اعداد برچسب گذاری شده اند.</p>

<p>بنابراین می توانیم دفترچه‌ی ژاک را به صورت آرایه ای از اشیاء نمایش دهیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_H7Np/tieSQ" href="#c_H7Np/tieSQ" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">journal</span> <span class="cm-operator">=</span> [
  {<span class="cm-property">events</span>: [<span class="cm-string">&quot;work&quot;</span>, <span class="cm-string">&quot;touched tree&quot;</span>, <span class="cm-string">&quot;pizza&quot;</span>,
            <span class="cm-string">&quot;running&quot;</span>, <span class="cm-string">&quot;television&quot;</span>],
   <span class="cm-property">squirrel</span>: <span class="cm-atom">false</span>},
  {<span class="cm-property">events</span>: [<span class="cm-string">&quot;work&quot;</span>, <span class="cm-string">&quot;ice cream&quot;</span>, <span class="cm-string">&quot;cauliflower&quot;</span>,
            <span class="cm-string">&quot;lasagna&quot;</span>, <span class="cm-string">&quot;touched tree&quot;</span>, <span class="cm-string">&quot;brushed teeth&quot;</span>],
   <span class="cm-property">squirrel</span>: <span class="cm-atom">false</span>},
  {<span class="cm-property">events</span>: [<span class="cm-string">&quot;weekend&quot;</span>, <span class="cm-string">&quot;cycling&quot;</span>, <span class="cm-string">&quot;break&quot;</span>, <span class="cm-string">&quot;peanuts&quot;</span>,
            <span class="cm-string">&quot;beer&quot;</span>],
   <span class="cm-property">squirrel</span>: <span class="cm-atom">true</span>},
  <span class="cm-comment">/* and so on... */</span>
];</pre>

<h2><a class="h_ident" id="h_Ne+ieRcX6g" href="#h_Ne+ieRcX6g" tabindex="-1" role="presentation"></a>تغییر پذیری</h2>

<p>به زودی به برنامه‌نویسی <em>واقعی</em> می رسیم. قبل از آن یک قسمت تئوری دیگر وجود دارد که باید درک شود.</p>

<p>تا حالا متوجه‌ شده‌ایم که مقدار اشیاء را می توان تغییر داد. انواع مقدارهایی که در فصل‌های پیشین بحث کردیم، مانند اعداد، رشته‌ها و مقادیر بولی،‌ همه <em>غیرقابل تغییر</em> بودند. تغییر مقداری از این انواع داده غیر ممکن است. می توانید آن‌ها را ترکیب کنید تا مقادیر جدیدی ایجاد کنید اما اگر مقدار رشته‌ای خاصی را بگیرید، مقدارش همیشه همان خواهد ماند. متن داخلش را نمی توان عوض کرد. اگر رشته‌ای داشته باشید که مقدار <code>&quot;cat&quot;</code> را دربردارد، برای کدهای برنامه امکان ندارد که بتوانند یک کاراکتر از آن را تغییر دهند و مثلا به <code>&quot;rat&quot;</code> تبدیلش کنند.</p>

<p>محتوای یک مقدار از نوع شیء را <em>می توان</em> به وسیله‌ی خاصیت‌هایش تغییر داد. این کار باعث می شود که یک شیء در زمان‌های مختلف محتوای متفاوتی داشته باشد.</p>

<p><a class="p_ident" id="p_hDh8dIMBFX" href="#p_hDh8dIMBFX" tabindex="-1" role="presentation"></a>زمانی که دو عدد مثلا 120 و 120 را داریم، می توانیم هر دو را دقیقا یک عدد مشابه در نظر بگیریم، فارغ از اینکه به بیت‌های فیزیکی یکسانی مربوط باشند یا خیر. اما در اشیاء، بین داشتن دو ارجاع به یک شیء یکسان و داشتن دو شیء متفاوت که خاصیت‌های مشابهی دارند، ‌تفاوت وجود دارد. به کدهای زیر رو توجه کنید:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_I1Dv6D46/p" href="#c_I1Dv6D46/p" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">object1</span> <span class="cm-operator">=</span> {<span class="cm-property">value</span>: <span class="cm-number">10</span>};
<span class="cm-keyword">let</span> <span class="cm-def">object2</span> <span class="cm-operator">=</span> <span class="cm-variable">object1</span>;
<span class="cm-keyword">let</span> <span class="cm-def">object3</span> <span class="cm-operator">=</span> {<span class="cm-property">value</span>: <span class="cm-number">10</span>};

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object1</span> <span class="cm-operator">==</span> <span class="cm-variable">object2</span>);
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object1</span> <span class="cm-operator">==</span> <span class="cm-variable">object3</span>);
<span class="cm-comment">// → false</span>

<span class="cm-variable">object1</span>.<span class="cm-property">value</span> <span class="cm-operator">=</span> <span class="cm-number">15</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object2</span>.<span class="cm-property">value</span>);
<span class="cm-comment">// → 15</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object3</span>.<span class="cm-property">value</span>);
<span class="cm-comment">// → 10</span></pre>

<p>متغیرهای <code>object1</code> و <code>object2</code> به شیء مشابهی اشاره می کنند که به همین دلیل تغییر <code>object1</code> منجر به تغییر مقدار <code>object2</code> هم می شود. گفته می شود این دو هویت یکسانی دارند. متغیر <code>object3</code> به شی دیگری اشاره می کند که دارای خاصیت هایی مشابه <code>object1</code> است اما در فضای متفاوتی قرار گرفته است.</p>

<p>متغیرها نیز می توانند از نوع ثابت و غیر ثابت باشند، اما این قضیه ارتباطی به رفتار مقدارهای آن ها ندارد. اگرچه مقداری از جنس عدد تغییر ناپذیر است، می توانید از متغیر که با <code>let</code> تعریف شده است استفاده کنید تا عددی که متغیر به آن اشاره می کند را عوض کنید. به طور مشابه، اگرچه یک ثابت که با <code>const</code> برای یک شیء تعریف شده است را نمی توان تغییر داد و همیشه به شیء مشابهی اشاره خواهد کرد، اما <em>محتوای</em> آن شیء قابل تغییر است.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_eOXMRndYxO" href="#c_eOXMRndYxO" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">score</span> <span class="cm-operator">=</span> {<span class="cm-property">visitors</span>: <span class="cm-number">0</span>, <span class="cm-property">home</span>: <span class="cm-number">0</span>};
<span class="cm-comment">// This is okay</span>
<span class="cm-variable">score</span>.<span class="cm-property">visitors</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
<span class="cm-comment">// This isn't allowed</span>
<span class="cm-variable">score</span> <span class="cm-operator">=</span> {<span class="cm-property">visitors</span>: <span class="cm-number">1</span>, <span class="cm-property">home</span>: <span class="cm-number">1</span>};</pre>

<p>عملگر <code>==</code> جاوااسکریپت، وقتی برای مقایسه‌ی اشیاء استفاده می شود، تنها زمانی مقدار <code>true</code> را برمی گرداند که هر دو شیء دقیقا مقدار یکسانی باشند. مقایسه‌ی اشیاء متفاوت حتی زمانی که محتوای آن ها یکسان باشد باعث برگرداندن <code>false</code> می شود. در جاوااسکریپت، عملگری برای مقایسه‌ی عمیق فراهم نشده است که بتواند محتوای اشیاء را بررسی و مقایسه کند. اما خودتان می توانید آن را بنویسید ( یکی از <a href="04_data.html#exercise_deep_compare">تمرین‌های</a> پایان این فصل همین مساله خواهد بود).</p>

<h2><a class="h_ident" id="h_cwzAZGK8pm" href="#h_cwzAZGK8pm" tabindex="-1" role="presentation"></a>برنامه‌ی گزارش مسخ</h2>

<p>خب ژاک برنامه‌ی مفسر جاوااسکریپت را اجرا می کند و محیطی که برای نوشتن گزارش روزانه نیاز دارد را فراهم می‌نماید.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_CI+dtzXW/x" href="#c_CI+dtzXW/x" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">journal</span> <span class="cm-operator">=</span> [];

<span class="cm-keyword">function</span> <span class="cm-def">addEntry</span>(<span class="cm-def">events</span>, <span class="cm-def">squirrel</span>) {
  <span class="cm-variable">journal</span>.<span class="cm-property">push</span>({<span class="cm-property">events</span>, <span class="cm-property">squirrel</span>});
}</pre>

<p>توجه کنید که شیئی که به ژورنال اضافه می شود کمی غیر عادی به نظر می رسد. به جای اینکه خاصیت را به شکل <code>events: events</code> بنویسیم، فقط نام خاصیت نوشته شده است. این دستور کوتاه معادل همان روش معمولی است – اگر در روش تعریف شیء به وسیله کروشه‌ها، نام خاصیتی بدون تعریف مقدارش نوشته شود، مقدار آن از متغیری با همان نام گرفته می شود.</p>

<p>بنابراین هر شب ساعت ده – یا گاهی اوقات صبح روز بعد، بعد از پایین آمدن از قفسه بالایی کتابخانه اش-  ژاک گزارش آن روز را ثبت می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_S+F+R2oIfR" href="#c_S+F+R2oIfR" tabindex="-1" role="presentation"></a><span class="cm-variable">addEntry</span>([<span class="cm-string">&quot;work&quot;</span>, <span class="cm-string">&quot;touched tree&quot;</span>, <span class="cm-string">&quot;pizza&quot;</span>, <span class="cm-string">&quot;running&quot;</span>,
          <span class="cm-string">&quot;television&quot;</span>], <span class="cm-atom">false</span>);
<span class="cm-variable">addEntry</span>([<span class="cm-string">&quot;work&quot;</span>, <span class="cm-string">&quot;ice cream&quot;</span>, <span class="cm-string">&quot;cauliflower&quot;</span>, <span class="cm-string">&quot;lasagna&quot;</span>,
          <span class="cm-string">&quot;touched tree&quot;</span>, <span class="cm-string">&quot;brushed teeth&quot;</span>], <span class="cm-atom">false</span>);
<span class="cm-variable">addEntry</span>([<span class="cm-string">&quot;weekend&quot;</span>, <span class="cm-string">&quot;cycling&quot;</span>, <span class="cm-string">&quot;break&quot;</span>, <span class="cm-string">&quot;peanuts&quot;</span>,
          <span class="cm-string">&quot;beer&quot;</span>], <span class="cm-atom">true</span>);</pre>

<p>زمانی که مقدار کافی اطلاعات در دست باشد، او قصد دارد تا به محاسبه‌ی ارتباط بین تبدیل شدنش به سنجاب و اتفاقاتی که در آن روز افتاده است بپردازد و امیدوار است چیزهای مفیدی از این همبستگی‌ها به دست بیاورد.</p>

<p><a class="p_ident" id="p_5vG+xEj1sc" href="#p_5vG+xEj1sc" tabindex="-1" role="presentation"></a><em>همبستگی</em> مقیاسی برای تعیین میزان <em>وابستگی</em> بین متغیرهای آماری است. یک متغیر آماری شبیه به متغیرها در زبان‌های برنامه‌نویسی نیست. در آمار، شما معمولا مجموعه‌ای از سنجش‌ها را در اختیار دارید و هر متغیر با همه‌ی سنجش‌ها اندازه‌گیری می شود. همبستگی بین متغیرها معمولا به شکل ضریبی بین <bdo>-1</bdo> تا <bdo>1</bdo> تولید می شود. ضریب همبستگی صفر به معنای این است که دو متغیر هیچ ارتباطی با هم ندارند و ضریب همبستگی یک به معنای ارتباط کامل دو متغیر است – اگر یکی از آن ها را بدانید، دیگری را نیز می توانید بدست بیاورید. منفی یک (<bdo>-1</bdo>) نیز به معنای ارتباط کامل دو متغیر اما به شکل معکوس و مخالف است- زمانی که یکی درست است دیگری نادرست خواهد بود.</p>

<p><a class="p_ident" id="p_pD/MhHwik3" href="#p_pD/MhHwik3" tabindex="-1" role="presentation"></a>برای محاسبه اندازه‌ی ضریب همبستگی بین دو متغیر بولی، می توانیم از <em>ضریب فی</em> (<em>ϕ</em>) استفاده کنیم. این ضریب فرمولی است که ورودی آن یک جدول فراوانی از تعداد دفعاتی است که ترکیب های مختلف دو متغیر مشاهده شده اند. خروجی فرمول،  عددی بین <bdo>-1</bdo> و 1 است که میزان همبستگی را مشخص می کند.</p>

<p>می توانیم رخداد خوردن پیتزا را در نظر بگیریم و آن را در جدول فراوانی به شکل زیر قرار دهیم، جایی که هر عدد نمایانگر تعداد دفعاتی است که ترکیب مورد نظر ما اتفاق افتاده است:</p><figure><img src="img/pizza-squirrel.svg" alt="Eating pizza versus turning into a squirrel"></figure>

<p><a class="p_ident" id="p_0YVMrokex7" href="#p_0YVMrokex7" tabindex="-1" role="presentation"></a>اگر جدول را <em>n</em> بنامیم، می توان <em>ϕ</em> را با فرمول زیر محاسبه کرد:</p><div>
<table style="border-collapse: collapse; margin-right: 1em;"><tr>
  <td style="vertical-align: middle"><em>ϕ</em> =</td>
  <td style="padding-right: .5em">
    <div style="border-bottom: 1px solid black; padding: 0 7px;"><em>n</em><sub>11</sub><em>n</em><sub>00</sub> −
      <em>n</em><sub>10</sub><em>n</em><sub>01</sub></div>
    <div style="padding: 0 7px;">√<span style="border-top: 1px solid black; position: relative; top: 2px;">
      <span style="position: relative; top: -4px"><em>n</em><sub>1•</sub><em>n</em><sub>0•</sub><em>n</em><sub>•1</sub><em>n</em><sub>•0</sub></span>
    </span></div>
  </td>
</tr></table>
</div>


<p>( اگر دارید کتاب را می بندید تا به سراغ خاطرات وحشتناک کتاب ریاضی دبیرستان بروید، صبر کنید! قرار نیست که در این کتاب شما را با فرمول‌های عجیب و غریب اذیت کنم – فعلا همین یک فرمول کافی است. برای همین یک مورد هم تمام کاری که قرار است بکنیم تبدیل آن به جاوااسکریپت است.)</p>

<p><a class="p_ident" id="p_lmQJ3jhajF" href="#p_lmQJ3jhajF" tabindex="-1" role="presentation"></a>نماد <bdo><em>n</em><sub>01</sub></bdo> نشان دهنده‌ی تعداد اندازه‌گیری‌هایی است که اولین متغیر (سنجاب شدن) برابر false یا 0 و دومین اندازه‌گیری (پیتزا خوردن) <bdo>true (1)</bdo> شده است. در این مثال <bdo><em>n</em><sub>01</sub></bdo> برابر 9 است.</p>

<p><a class="p_ident" id="p_xoO8Idh12k" href="#p_xoO8Idh12k" tabindex="-1" role="presentation"></a>مقدار <bdo><em>n</em><sub>1•</sub></bdo> برابر با جمع همه‌ی اندازه‌گیری‌هایی است که متغیر اول آن ها true ارزیابی شده است که در این مثال 5 است. به همین صورت <bdo><em>n</em><sub>•0</sub></bdo> به مجموع اندازه‌گیری‌هایی که متغیر دوم‌ آن‌ها false است اشاره می کند.</p>

<p><a class="p_ident" id="p_OFx+eKKJ8r" href="#p_OFx+eKKJ8r" tabindex="-1" role="presentation"></a>بنابراین برای جدول پیتزا، بالای کسر یا صورت کسر می شود <bdo> 1×76−4×9 = 40</bdo>  و مخرج کسر برابر است با ریشه‌ی دوم <bdo>5×85×10×80</bdo> یا <bdo>√340000</bdo>٫   که حاصل می شود <bdo><em>ϕ</em> ≈ 0.069</bdo>  که عدد خیلی کوچکی است. خوردن پیتزا به نظر می رسد تاثیری در تبدیل ژاک به سنجاب ندارد.</p>

<h2><a class="h_ident" id="h_H06tFX+hYY" href="#h_H06tFX+hYY" tabindex="-1" role="presentation"></a>محاسبه‌ی ضریب همبستگی</h2>

<p><a class="p_ident" id="p_2kuSN7rMzf" href="#p_2kuSN7rMzf" tabindex="-1" role="presentation"></a>در جاوااسکریپت می توانیم یک جدول دو-در-دو را با یک آرایه‌ی چهار-عنصری <bdo><code>[76, 9, 4, 1]</code></bdo> نشان دهیم.  البته می توان به شکل‌های دیگر نیز این کار را انجام داد مثل استفاده از آرایه‌ای که از دو آرایه‌ی دو خانه‌ای تشکیل شده است <bdo>(<code>[[76, 9], [4, 1]]</code>)</bdo>  یا شیءای با خاصیت هایی به شکل <code>&quot;11&quot;</code> و <code>&quot;01&quot;</code>، اما استفاده از یک آرایه‌ی تخت ساده تر است و باعث می شود که عبارت‌هایی که برای دسترسی به خانه‌های آرایه می نویسیم کوتاه تر شوند. خانه‌های آرایه را به عنوان دو بیت دودویی محسوب می کنیم که رقم چپ (با ارزش‌ترین عدد) نمایانگر متغیر سنجاب‌شدن و رقم راست (کم ارزش ترین) معرف متغیر رخداد است. به عنوان مثال عدد دودویی <code>10</code> به موردی اشاره می کند که ژاک به سنجاب تبدیل شده است اما رخداد مورد نظر (مثلا خوردن پیتزا) رخ نداده است . این کار چهار مرتبه اتفاق افتاده است و به علت اینکه عدد دودویی  <code>10</code> در سیستم دهدهی معادل <code>2</code> می‌باشد، ما این عدد را در خانه‌ی 2 آرایه ذخیره خواهیم کرد.</p>

<p id="phi_function">تابع زیر محاسبه‌ی مقدار <em>ϕ</em> را از آرایه‌ی مذکور انجام می دهد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_AnoNjFldkv" href="#c_AnoNjFldkv" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">phi</span>(<span class="cm-def">table</span>) {
  <span class="cm-keyword">return</span> (<span class="cm-variable-2">table</span>[<span class="cm-number">3</span>] <span class="cm-operator">*</span> <span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">-</span> <span class="cm-variable-2">table</span>[<span class="cm-number">2</span>] <span class="cm-operator">*</span> <span class="cm-variable-2">table</span>[<span class="cm-number">1</span>]) <span class="cm-operator">/</span>
    <span class="cm-variable">Math</span>.<span class="cm-property">sqrt</span>((<span class="cm-variable-2">table</span>[<span class="cm-number">2</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">3</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">1</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">1</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">3</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">2</span>]));
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">phi</span>([<span class="cm-number">76</span>, <span class="cm-number">9</span>, <span class="cm-number">4</span>, <span class="cm-number">1</span>]));
<span class="cm-comment">// → 0.068599434</span></pre>

<p><a class="p_ident" id="p_UMfg8HjUt8" href="#p_UMfg8HjUt8" tabindex="-1" role="presentation"></a>کد بالا در واقع ترجمه‌ی مستقیم فرمول محاسبه <em>ϕ</em> به زبان جاوااسکریپت است. تابع <bdo><code>Math.sqrt</code></bdo> ریشه‌ی دوم عدد را حساب می کند که توسط شیء <code>Math</code> در محیط استاندارد جاوااسکریپت فراهم شده است. برای دستیابی به فیلد‌هایی شبیه به <bdo>n<sub>1•</sub></bdo> بایستی دو فیلد از جدول را با هم جمع کنیم چرا که مجموع ردیف ها یا ستون‌ها به شکل مستقیم در ساختار داده‌ی ما ذخیره نمی‌شوند.</p>

<p><a class="p_ident" id="p_jmqrqfXZoe" href="#p_jmqrqfXZoe" tabindex="-1" role="presentation"></a>ژاک به ثبت روزانه‌ی خود تا سه ماه ادامه داد. مجموعه داده‌های بدست آمده را می توانید در قسمت <a href="https://eloquentjavascript.net/code#4">کدهای</a> این فصل  بدست بیاورید. این داده‌ها در متغیر <code>JOURNAL</code> ذخیره شده اند که <a href="https://eloquentjavascript.net/code/journal.js">فایل</a> آن قابل بارگیری است.</p>

<p>برای استخراج یک جدول دو-در-دو برای یک رخداد خاص از دفتر روزانه، بایستی تمامی رکوردها را پیمایش کنیم و تعداد دفعاتی که آن رخداد در ارتباط با سنجاب شدن اتفاق افتاده است را بشماریم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_rfea+FwMb5" href="#c_rfea+FwMb5" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">tableFor</span>(<span class="cm-def">event</span>, <span class="cm-def">journal</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">table</span> <span class="cm-operator">=</span> [<span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-number">0</span>];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">journal</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">entry</span> <span class="cm-operator">=</span> <span class="cm-variable-2">journal</span>[<span class="cm-variable-2">i</span>], <span class="cm-def">index</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">includes</span>(<span class="cm-variable-2">event</span>)) <span class="cm-variable-2">index</span> <span class="cm-operator">+=</span> <span class="cm-number">1</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">entry</span>.<span class="cm-property">squirrel</span>) <span class="cm-variable-2">index</span> <span class="cm-operator">+=</span> <span class="cm-number">2</span>;
    <span class="cm-variable-2">table</span>[<span class="cm-variable-2">index</span>] <span class="cm-operator">+=</span> <span class="cm-number">1</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">table</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">tableFor</span>(<span class="cm-string">&quot;pizza&quot;</span>, <span class="cm-variable">JOURNAL</span>));
<span class="cm-comment">// → [76, 9, 4, 1]</span></pre>

<p>آرایه‌ها متدی به نام <code>includes</code> دارند که وجود یک مقدار داده شده را در آرایه بررسی می کند. تابع بالا از این متد برای بررسی وجود نام رخداد مورد نظر در لیست رخدادها برای یک روز مشخص استفاده می کند.</p>

<p>بدنه‌ی حلقه‌ی تابع <code>tableFor</code> مشخص می کند که هر کدام از مدخل‌های دفتر روزانه در کدام قسمت از جدول قرار می گیرند .این‌کار با بررسی وجود رخداد مورد نظر در مدخل و اینکه رخداد همزمان با سنجاب شدن اتفاق می افتد یا خیر، صورت می گیرد. سپس حلقه یک واحد به خانه‌ی مورد نظر در جدول اضافه می کند.</p>

<p>هم اکنون ما ابزاری را در اختیار داریم که برای  محاسبه همبستگی ها نیاز داشتیم. تنها گامی که مانده این است که ضریب همبستگی را برای همه‌ی رخداد‌های ضبط شده پیدا کنیم و اینکه ببینیم کدام رخداد موثر بوده است.</p>

<h2 id="for_of_loop"><a class="h_ident" id="h_/vnWbeaDjX" href="#h_/vnWbeaDjX" tabindex="-1" role="presentation"></a>حلقه‌ها در آرایه</h2>

<p>در تابع <code>tableFor</code> حلقه‌ای وجود داشت که شبیه کد زیر بود:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_pE7VRrRQir" href="#c_pE7VRrRQir" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">JOURNAL</span>.<span class="cm-property">length</span>; <span class="cm-variable">i</span><span class="cm-operator">++</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">entry</span> <span class="cm-operator">=</span> <span class="cm-variable">JOURNAL</span>[<span class="cm-variable">i</span>];
  <span class="cm-comment">// Do something with entry</span>
}</pre>

<p>این شکل از حلقه در جاوااسکریپت کلاسیک رایج است – که در آن هر بار سراغ یک خانه‌ از آرایه می رویم که برای انجام آن از شمارنده‌ای متناسب با طول آرایه استفاده می کنیم تا بتوانیم به هر عنصر دسترسی داشته باشیم.</p>

<p>راه ساده‌تری در جاوااسکریپت مدرن برای این گونه حلقه ها وجود دارد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_OXsCQPvDE1" href="#c_OXsCQPvDE1" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">entry</span> <span class="cm-keyword">of</span> <span class="cm-variable">JOURNAL</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">length</span><span class="cm-string-2">}</span> <span class="cm-string-2">events.`</span>);
}</pre>

<p>زمانی که یک حلقه‌ی <code>for</code> به این شکل نوشته می شود که بعد از تعریف یک متغیر، کلمه‌ی کلیدی <code>of</code> نوشته می شود، مقداری که بعد از <code>of</code> می آید را پیمایش می کند. این حلقه نه تنها برای آرایه‌ها کاربرد دارد بلکه برای رشته‌ها و بعضی از دیگر ساختارهای داده نیز استفاده می شود. با نحوه‌ی عملکر آن در <a href="06_object.html">فصل 6</a> آشنا می شویم.</p>

<h2 id="analysis"><a class="h_ident" id="h_Dg98h+90By" href="#h_Dg98h+90By" tabindex="-1" role="presentation"></a>تحلیل نهایی</h2>

<p>لازم است تا محاسبه‌ی ضریب همبستگی را برای همه‌ی رخدادهایی که در مجموعه‌‌ی داده ها وجود دارد انجام دهیم. برای این کار، ابتدا باید همه‌ی انواع رخداد ها را <em>پیدا</em> کنیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_P6cqJZBL1M" href="#c_P6cqJZBL1M" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">journalEvents</span>(<span class="cm-def">journal</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">events</span> <span class="cm-operator">=</span> [];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">entry</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">journal</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">event</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">entry</span>.<span class="cm-property">events</span>) {
      <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">events</span>.<span class="cm-property">includes</span>(<span class="cm-variable-2">event</span>)) {
        <span class="cm-variable-2">events</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">event</span>);
      }
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">events</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">journalEvents</span>(<span class="cm-variable">JOURNAL</span>));
<span class="cm-comment">// → [&quot;carrot&quot;, &quot;exercise&quot;, &quot;weekend&quot;, &quot;bread&quot;, …]</span></pre>

<p>با پیمایش تک تک رخدادها و افزودن آن‌هایی که قبلا در آرایه‌ی <code>events</code> موجود نبودند، این تابع تمامی رخدادها را جمع‌آوری می کند.</p>

<p>با استفاده از آن می توانیم همه‌ی همبستگی ها را ببینیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_7ws9oWaneM" href="#c_7ws9oWaneM" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">event</span> <span class="cm-keyword">of</span> <span class="cm-variable">journalEvents</span>(<span class="cm-variable">JOURNAL</span>)) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">event</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;:&quot;</span>, <span class="cm-variable">phi</span>(<span class="cm-variable">tableFor</span>(<span class="cm-variable">event</span>, <span class="cm-variable">JOURNAL</span>)));
}
<span class="cm-comment">// → carrot:   0.0140970969</span>
<span class="cm-comment">// → exercise: 0.0685994341</span>
<span class="cm-comment">// → weekend:  0.1371988681</span>
<span class="cm-comment">// → bread:   -0.0757554019</span>
<span class="cm-comment">// → pudding: -0.0648203724</span>
<span class="cm-comment">// and so on...</span></pre>

<p><a class="p_ident" id="p_Srm6BE5exJ" href="#p_Srm6BE5exJ" tabindex="-1" role="presentation"></a>به نظر می‌رسد که بیشتر ضرایب همبستگی  به صفر نزدیک‌اند. خوردن هویج، نان، یا دسر، ظاهرا ارتباطی با سنجاب شدن ژاک ندارند. به نظر می رسد این تبدیل بیشتر در آخر هفته‌ها رخ می دهد. اجازه بدهید تا نتایج را کمی پالایش کنیم تا فقط نتایجی نشان داده شوند که ضریب همبستگی آن ها بیش از <bdo>0.1</bdo> یا کمتر از <bdo>-0.1</bdo>  باشد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_hBXzmb7hPU" href="#c_hBXzmb7hPU" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">event</span> <span class="cm-keyword">of</span> <span class="cm-variable">journalEvents</span>(<span class="cm-variable">JOURNAL</span>)) {
  <span class="cm-keyword">let</span> <span class="cm-def">correlation</span> <span class="cm-operator">=</span> <span class="cm-variable">phi</span>(<span class="cm-variable">tableFor</span>(<span class="cm-variable">event</span>, <span class="cm-variable">JOURNAL</span>));
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">correlation</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0.1</span> <span class="cm-operator">|</span><span class="cm-operator">|</span> <span class="cm-variable-2">correlation</span> <span class="cm-operator">&lt;</span> <span class="cm-operator">-</span><span class="cm-number">0.1</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">event</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;:&quot;</span>, <span class="cm-variable-2">correlation</span>);
  }
}
<span class="cm-comment">// → weekend:        0.1371988681</span>
<span class="cm-comment">// → brushed teeth: -0.3805211953</span>
<span class="cm-comment">// → candy:          0.1296407447</span>
<span class="cm-comment">// → work:          -0.1371988681</span>
<span class="cm-comment">// → spaghetti:      0.2425356250</span>
<span class="cm-comment">// → reading:        0.1106828054</span>
<span class="cm-comment">// → peanuts:        0.5902679812</span></pre>

<p>آها! دو فاکتور در بین نتایج وجود دارد که ضریب آن ها مشخصا قوی تر از دیگر موارد است. خوردن بادام‌ زمینی اثر مثبت زیادی در شانس تبدیل شدن به سنجاب دارد، در حالیکه مسواک زدن اثری قابل توجه اما در جهت معکوس ایجاد می کند.</p>

<p>جالب است. بیایید تا چیزی را آزمایش کنیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_x7WUJStSIp" href="#c_x7WUJStSIp" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">entry</span> <span class="cm-keyword">of</span> <span class="cm-variable">JOURNAL</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">includes</span>(<span class="cm-string">&quot;peanuts&quot;</span>) <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span>
     <span class="cm-operator">!</span><span class="cm-variable">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">includes</span>(<span class="cm-string">&quot;brushed teeth&quot;</span>)) {
    <span class="cm-variable">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">push</span>(<span class="cm-string">&quot;peanut teeth&quot;</span>);
  }
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">phi</span>(<span class="cm-variable">tableFor</span>(<span class="cm-string">&quot;peanut teeth&quot;</span>, <span class="cm-variable">JOURNAL</span>)));
<span class="cm-comment">// → 1</span></pre>

<p>نتیجه‌ی قابل توجه‌ای است. تبدیل دقیقا زمانی رخ می دهد که ژاک بادام‌ زمینی می خورد و فراموش می کند تا مسواک کند. اگر او آن قدر بی توجه به بهداشت دهان و دندان نبود ، هرگز به این رنج دچار نمی شد.</p>

<p>با دانستن این، ژاک دیگر بادام زمینی نمی خورد و متوجه می شود که تبدیل دیگر اتفاق نمی افتد.</p>

<p>تا چند سال، اوضاع برای ژاک خیلی خوب پیش می رود. تا این که روزی کارش را از دست می دهد. چون ژاک در کشوری زندگی می کند که نداشتن کار به معنای نداشتن خدمات بهداشت و سلامت است، مجبور می شود تا در یک سیرک مشغول به کار شود جایی که نقشش <em>مرد سنجابی شگفت‌انگیز</em> است. او قبل از هر نمایش دهانش را پر از کره‌ بادام‌ زمینی می کند.</p>

<p>یک روز، ژاک خسته از این زندگی رقت انگیز، وقتی نتوانست دیگر به شکل انسانی خودش برگردد، لابلای یکی از شکاف‌های چادر سیرک می پرد و در جنگل ناپدید می شود. بعد از آن ژاک هرگز دیده نشد.</p>

<h2><a class="h_ident" id="h_Vvx9NXXSIu" href="#h_Vvx9NXXSIu" tabindex="-1" role="presentation"></a>کمی آرایه‌شناسی بیشتر</h2>

<p>قبل از تمام کردن این فصل، قصد دارم تا شما را با چند مفهوم دیگر مرتبط با اشیاء آشنا کنم. ابتدا با چند متد عمومی و مفید از آرایه ها آشنا می شویم.</p>

<p><code>pop</code> و <code>push</code> را <a href="04_data.html#array_methods">پیش‌تر</a> در همین فصل دیدیم، که برای حذف و اضافه‌ی عناصر در انتهای آرایه استفاده می شدند. متدهای مرتبط دیگری که همین کار را در ابتدای آرایه انجام می دهند <code>shift</code> و <code>unshift</code> می باشند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Vq1IBpy+hP" href="#c_Vq1IBpy+hP" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">todoList</span> <span class="cm-operator">=</span> [];
<span class="cm-keyword">function</span> <span class="cm-def">remember</span>(<span class="cm-def">task</span>) {
  <span class="cm-variable">todoList</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">task</span>);
}
<span class="cm-keyword">function</span> <span class="cm-def">getTask</span>() {
  <span class="cm-keyword">return</span> <span class="cm-variable">todoList</span>.<span class="cm-property">shift</span>();
}
<span class="cm-keyword">function</span> <span class="cm-def">rememberUrgently</span>(<span class="cm-def">task</span>) {
  <span class="cm-variable">todoList</span>.<span class="cm-property">unshift</span>(<span class="cm-variable-2">task</span>);
}</pre>

<p>کار برنامه‌ی بالا مدیریت یک صف وظایف است. برای افزودن یک وظیفه به انتهای صف، تابع <bdo><code>remember(&quot;groceries&quot;)</code></bdo> را فراخوانی می کنید و زمانی که برای انجام یک وظیفه آماده هستید ، تابع <bdo><code>getTask()</code></bdo> را برای گرفتن (و حذف) یک وظیفه از جلوی صف فراخوانی می کنید. تابع <code>rememberUrgently</code> نیز برای افزودن یک وظیفه استفاده می شود اما آن را به جلوی صف اضافه می کند نه انتهای صف.</p>

<p><a class="p_ident" id="p_NWoZK3kTsE" href="#p_NWoZK3kTsE" tabindex="-1" role="presentation"></a>برای جستجوی یک مقدار خاص، آرایه‌ها متدی به نام <code>indexOf</code> را فراهم می کنند. این متد در طول آرایه از شروع تا پایان حرکت کرده و اندیسی که در آن، مقدار مورد درخواست پیدا شد – یا <bdo>-1</bdo> در صورت پیدا نکردن – را بر می گرداند. برای جستجو از آخر به اول، متدی مشابهی وجود دارد که  <code>lastIndexOf</code> نامیده می شود.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_N+G0EtTfto" href="#c_N+G0EtTfto" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">2</span>, <span class="cm-number">1</span>].<span class="cm-property">indexOf</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → 1</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">2</span>, <span class="cm-number">1</span>].<span class="cm-property">lastIndexOf</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → 3</span></pre>

<p>هر دوی <code>indexOf</code> و <code>lastIndexOf</code> آرگومان اختیاری دیگری قبول می کنند که برای مشخص کردن نقطه‌ی شروع جستجو استفاده می شود.</p>

<p>یکی دیگر از متدهای اساسی آرایه‌ها، متد <code>slice</code> است که شماره‌ی اندیس های شروع و پایان را گرفته و آرایه‌ای که شامل عناصر بین آن‌ها می شود را تولید می کند. این آرایه تولیدی شامل عنصر آغازین و فاقد عنصر پایانی خواهد بود.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_zCBzPnMpIk" href="#c_zCBzPnMpIk" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">0</span>, <span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>].<span class="cm-property">slice</span>(<span class="cm-number">2</span>, <span class="cm-number">4</span>));
<span class="cm-comment">// → [2, 3]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">0</span>, <span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>].<span class="cm-property">slice</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → [2, 3, 4]</span></pre>

<p>زمانی که اندیس پایانی به متد داده نشود، <code>slice</code> تمامی عناصری که بعد از اندیس آغازین قرار می گیرند را بر می گرداند. می توانید همچنین اندیس اول را هم مشخص نکنید که باعث می شود کل آرایه کپی شود.</p>

<p>متد <code>concat</code> برای چسباندن آرایه‌ها به هم و ساخت یک آرایه جدید استفاده می شود، شبیه کاری که عملگر <code>+</code> برای رشته‌ها انجام می دهد.</p>

<p>مثال پیش رو نحوه‌ی عملکرد هر دوی متدهای  <code>slice</code>  و <code>concat</code> را نشان می  دهد.  تابع مثال، یک آرایه و یک اندیس را به عنوان ورودی دریافت می کند و آرایه‌ی جدیدی را برمی گرداند که نسخه‌ای از آرایه‌ی دریافتی بدون عنصری که اندیسش داده شده است می‌باشد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_q+NBMNgFFy" href="#c_q+NBMNgFFy" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">remove</span>(<span class="cm-def">array</span>, <span class="cm-def">index</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">array</span>.<span class="cm-property">slice</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">index</span>)
    .<span class="cm-property">concat</span>(<span class="cm-variable-2">array</span>.<span class="cm-property">slice</span>(<span class="cm-variable-2">index</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>));
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">remove</span>([<span class="cm-string">&quot;a&quot;</span>, <span class="cm-string">&quot;b&quot;</span>, <span class="cm-string">&quot;c&quot;</span>, <span class="cm-string">&quot;d&quot;</span>, <span class="cm-string">&quot;e&quot;</span>], <span class="cm-number">2</span>));
<span class="cm-comment">// → [&quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;e&quot;]</span></pre>

<p>اگر به متد <code>concat</code> آرگومانی غیرآرایه‌ای بفرستید، این مقدار به عنوان یک آرایه‌ی تک عنصری محسوب می شود و به انتهای آرایه‌ی جدید اضافه خواهد شد.</p>

<h2><a class="h_ident" id="h_wzHzVx4rZJ" href="#h_wzHzVx4rZJ" tabindex="-1" role="presentation"></a>رشته‌ها و خاصیت‌هایشان</h2>

<p>می توانیم خاصیت‌هایی مثل <code>length</code> و <code>toUpperCase</code> را از مقدارهای رشته‌ای فراخوانی کنیم. اما اگر سعی کنید خاصیت جدید به آن‌ها اضافه کنید، نتیجه‌ای نخواهد داشت.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_xvzL9wErq7" href="#c_xvzL9wErq7" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">kim</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;Kim&quot;</span>;
<span class="cm-variable">kim</span>.<span class="cm-property">age</span> <span class="cm-operator">=</span> <span class="cm-number">88</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">kim</span>.<span class="cm-property">age</span>);
<span class="cm-comment">// → undefined</span></pre>

<p>مقادیر نوع رشته، عدد و بولی، شیء محسوب نمی‌شوند. درست است که اگر سعی کنید خاصیت جدیدی روی آن تعریف کنید، مفسر جاوااسکریپت خطایی تولید نمی کند، اما این خاصیت ها را هم ایجاد و ذخیره نمی کند. همانطور که پیش‌تر گفته شد، این گونه مقادیر قابل تغییر نیستند.</p>

<p>اما این انواع داده، دارای خاصیت‌هایی از پیش تعریف شده می باشند.  هر مقدار رشته‌ای حاوی چند متد است. <code>slice</code> و <code>indexOf</code> از متدهای بسیار کاربردی رشته‌ها می‌باشند که به  متدهایی با همین نام‌ها در آرایه‌ها، شباهت دارند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_/Tmq1doYeG" href="#c_/Tmq1doYeG" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;coconuts&quot;</span>.<span class="cm-property">slice</span>(<span class="cm-number">4</span>, <span class="cm-number">7</span>));
<span class="cm-comment">// → nut</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;coconut&quot;</span>.<span class="cm-property">indexOf</span>(<span class="cm-string">&quot;u&quot;</span>));
<span class="cm-comment">// → 5</span></pre>

<p>یک تفاوت <code>indexOf</code> رشته نسبت به آرایه، توانایی جستجوی رشته‌ای است که شامل بیش از یک کاراکتر می‌باشد در حالی که در متد مربوط به آرایه، فقط جستجو را روی عناصر تکی انجام می دهد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_xM5/GBnZVG" href="#c_xM5/GBnZVG" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;one two three&quot;</span>.<span class="cm-property">indexOf</span>(<span class="cm-string">&quot;ee&quot;</span>));
<span class="cm-comment">// → 11</span></pre>

<p>متد <code>trim</code> فضای خالی  ( شامل فضای خالی، کاراکتر خط جدید، کاراکتر تب، و کاراکترهای مشابه) را از آغاز و پایان رشته حذف می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_0AfLRWyjq0" href="#c_0AfLRWyjq0" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;  okay \n &quot;</span>.<span class="cm-property">trim</span>());
<span class="cm-comment">// → okay</span></pre>

<p>تابع <code>zeroPad</code> که در <a href="03_functions.html">فصل قبل</a> نوشتیم نیز به عنوان یک متد وجود دارد. اسم این متد <code>padStart</code> است و طول دلخواه و کاراکتر ترازبندی را به عنوان آرگومان می گیرد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_SJbD9MiYu+" href="#c_SJbD9MiYu+" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">String</span>(<span class="cm-number">6</span>).<span class="cm-property">padStart</span>(<span class="cm-number">3</span>, <span class="cm-string">&quot;0&quot;</span>));
<span class="cm-comment">// → 006</span></pre>

<p id="split">می توانید با استفاده از متد <code>split</code> یک رشته را بر اساس تکرار رشته‌ای دیگر تقسیم و جدا کنید و با استفاده از متد <code>join</code> دوباره به هم بچسبانید.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_/rV2Ed5e8V" href="#c_/rV2Ed5e8V" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">sentence</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;Secretarybirds specialize in stomping&quot;</span>;
<span class="cm-keyword">let</span> <span class="cm-def">words</span> <span class="cm-operator">=</span> <span class="cm-variable">sentence</span>.<span class="cm-property">split</span>(<span class="cm-string">&quot; &quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">words</span>);
<span class="cm-comment">// → [&quot;Secretarybirds&quot;, &quot;specialize&quot;, &quot;in&quot;, &quot;stomping&quot;]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">words</span>.<span class="cm-property">join</span>(<span class="cm-string">&quot;. &quot;</span>));
<span class="cm-comment">// → Secretarybirds. specialize. in. stomping</span></pre>

<p>یک رشته را می توان با استفاده از متد <code>repeat</code> تکرار کرد که در این صورت رشته‌ای جدید تولید می شود که حاوی کپی های متعدد از رشته‌ی اصلی می‌باشد که به هم چسبیده اند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_70WotkNADb" href="#c_70WotkNADb" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;LA&quot;</span>.<span class="cm-property">repeat</span>(<span class="cm-number">3</span>));
<span class="cm-comment">// → LALALA</span></pre>

<p>پیش از این، با خاصیت <code>length</code> برای نوع رشته آشنا شدیم. دستیابی به کاراکترهای یک رشته شبیه دستیابی به عناصر یک آرایه است ( با در نظر گرفتن یک نکته که در <a href="05_higher_order.html#code_units">فصل 5</a> به آن می پردازیم).</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Aeop9AuKAb" href="#c_Aeop9AuKAb" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">string</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;abc&quot;</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">string</span>.<span class="cm-property">length</span>);
<span class="cm-comment">// → 3</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">string</span>[<span class="cm-number">1</span>]);
<span class="cm-comment">// → b</span></pre>

<h2 id="rest_parameters"><a class="h_ident" id="h_esgs3w7wfA" href="#h_esgs3w7wfA" tabindex="-1" role="presentation"></a>سایر پارامتر‌ها</h2>

<p>امکان مفیدی است اگر یک تابع می‌توانست به تعداد دلخواه آرگومان دریافت کند. به عنوان مثال، <code>Math.max</code> بیشینه‌ی <em>همه</em> آرگومان‌هایی که به آن داده می شود را بر می گرداند.</p>

<p>برای نوشتن این گونه توابع، بایستی سه علامت نقطه قبل از آخرین پارامتر تابع قرار دهید، شبیه مثال زیر:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_UXPbyGFVIB" href="#c_UXPbyGFVIB" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">max</span>(<span class="cm-meta">...</span><span class="cm-def">numbers</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-operator">-</span><span class="cm-atom">Infinity</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">number</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">numbers</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">number</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">result</span>) <span class="cm-variable-2">result</span> <span class="cm-operator">=</span> <span class="cm-variable-2">number</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">max</span>(<span class="cm-number">4</span>, <span class="cm-number">1</span>, <span class="cm-number">9</span>, <span class="cm-operator">-</span><span class="cm-number">2</span>));
<span class="cm-comment">// → 9</span></pre>

<p>زمانی که تابعی با این تعریف فراخوانی می‌شود، <em>پارامتر &quot;سایر&quot;</em> به آرایه‌ای که حاوی تمامی دیگر آرگومان‌ها می‌باشد اشاره می کند. اگر پارامترهای دیگری قبل از آن وجود داشته باشند، مقدار‌ آن ها در آن آرایه قرار نمی گیرد. در حالتی که، مانند متد <code>max</code>، اولین پارامتر به این صورت تعریف شود، تمامی آرگومان ها را در بر خواهد گرفت.</p>

<p>با استفاده از این نماد سه نقطه‌ای، می توانید یک تابع را با آرایه‌ای از آرگومان‌ها <em>فراخوانی</em> کنید.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_h9hmTe3vix" href="#c_h9hmTe3vix" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">numbers</span> <span class="cm-operator">=</span> [<span class="cm-number">5</span>, <span class="cm-number">1</span>, <span class="cm-number">7</span>];
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">max</span>(<span class="cm-meta">...</span><span class="cm-variable">numbers</span>));
<span class="cm-comment">// → 7</span></pre>

<p>این کار باعث می شود که آرایه‌ی مورد نظر در فراخوانی تابع پخش بشود، به طوری که عناصرش به عنوان آرگومان‌های جدا محسوب شوند.  همچنین می توان آرایه‌ی مشابهی را لابه‌لای دیگر آرگومان ها ارسال کرد مثل :‌ <bdo><code>max(9, .<wbr>.<wbr>.<wbr>numbers, 2)</code></bdo>.</p>

<p>به  طور مشابه ، براکت‌های آرایه این امکان را به شما می دهند که از عملگر سه‌نقطه برای پخش آرایه‌ای دیگر در یک آرایه‌ی جدید استفاده کنید:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_4t+LJt3Kyo" href="#c_4t+LJt3Kyo" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">words</span> <span class="cm-operator">=</span> [<span class="cm-string">&quot;never&quot;</span>, <span class="cm-string">&quot;fully&quot;</span>];
<span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-string">&quot;will&quot;</span>, <span class="cm-meta">...</span><span class="cm-variable">words</span>, <span class="cm-string">&quot;understand&quot;</span>]);
<span class="cm-comment">// → [&quot;will&quot;, &quot;never&quot;, &quot;fully&quot;, &quot;understand&quot;]</span></pre>

<h2><a class="h_ident" id="h_2vTq8gdL1s" href="#h_2vTq8gdL1s" tabindex="-1" role="presentation"></a>شیء Math</h2>

<p>همانطور که دیده‌ایم، <code>Math</code> حاوی تعدادی تابع کاربردی مرتبط با اعداد است، مثل <bdo><code>Math.max</code></bdo>  (بیشینه)، <bdo> <code>Math.min</code></bdo> (کمینه)، و <bdo><code>Math.sqrt</code></bdo> (ریشه دوم عدد).</p>

<p id="namespace_pollution"><a class="p_ident" id="p_GWPrxhFzqI" href="#p_GWPrxhFzqI" tabindex="-1" role="presentation"></a>شیء <code>Math</code> به عنوان یک ظرف برای گروه‌بندی قابلیت‌های مرتبط استفاده می شود. تنها یک شیء <code>Math</code> وجود دارد، و تقریبا هرگز کاربردی به عنوان یک مقدار ندارد. در عوض، فضای نامی (<em>namespace</em>) را فراهم می کند که باعث می شود نیازی نباشد این متدها و مقدارها در فضای سراسری تعریف شوند.</p>

<p>داشتن متغیرهای سراسری زیاد، به نوعی موجب آلودگی فضای نام (namespace)می شود. هرچه نام‌های بیشتری اشغال شوند ، احتمال بیشتری برای جایگزینی ناخواسته و تصادفی مقدار متغیرها وجود دارد. به عنوان مثال، بعید نیست که بخواهید چیزی را به نام  <code>max</code> در یکی از برنامه‌هایتان تعریف کنید. اما به دلیل اینکه تابع از پیش تعریف شده‌ی  <code>max</code> در جاوااسکریپت  به شکل امنی درون شیء <code>Math</code> نگه داری می شود، نیازی نیست نگران تغییر تصادفی آن باشیم.</p>

<p>خیلی از زبان‌های برنامه‌نویسی، مانع از تعریف متغیری می‌شوند که قبلا تعریف شده است یا حداقل به شما در این باره اخطار می دهند. جاوااسکریپت این کار را برای متغیرهایی که با <code>let</code> یا <code>const</code> تعریف شده اند انجام می دهد اما عجیب اینکه برای متغیرهایی که با <code>var</code>، توابعی که با <code>function</code> تعریف شده اند و متغیرهای استاندارد زبان، حرکتی بروز نمی دهد.</p>

<p>برگردیم به شیء <code>Math</code>. اگر نیاز به محاسبات مثلثاتی دارید ، <code>Math</code> می تواند به شما کمک کند. مانند متدهای  <code>cos</code> (کسینوس)، <code>sin</code> (سینوس)، و <code>tan</code> (تانژانت) به همراه توابع معکوس آن‌ها، <code>acos</code> <code>asin</code> و <code>atan</code>. عدد π (پی) – در واقع نزدیک ترین تقریبی که برای آن در جاوااسکریپت وجود دارد – نیز به صورت <bdo><code>Math.PI</code></bdo> در دسترس است. یک سنت قدیمی در برنامه‌نویسی وجود دارد که نام ثابت ها را با حروف بزرگ می نویسند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_54zxf+2nsU" href="#c_54zxf+2nsU" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">randomPointOnCircle</span>(<span class="cm-def">radius</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">angle</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">2</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
  <span class="cm-keyword">return</span> {<span class="cm-property">x</span>: <span class="cm-variable-2">radius</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">cos</span>(<span class="cm-variable-2">angle</span>),
          <span class="cm-property">y</span>: <span class="cm-variable-2">radius</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">sin</span>(<span class="cm-variable-2">angle</span>)};
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">randomPointOnCircle</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → {x: 0.3667, y: 1.966}</span></pre>

<p>اگر با سینوس و کسینوس آشنا نیستنید، نگران نباشید. زمانی که به سراغ استفاده از آن ها خواهیم رفت،‌ <a href="14_dom.html#sin_cos">در فصل 14</a>، آن ها را توضیح خواهم داد.</p>

<p>در مثال قبل، از<code>Math.random</code> استفاده شد. این تابع عددی تصادفی بین صفر (شامل خود صفر) و یک (غیر از خود یک) با هر بار فراخوانی، تولید می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_+gqW4B1qk1" href="#c_+gqW4B1qk1" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>());
<span class="cm-comment">// → 0.36993729369714856</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>());
<span class="cm-comment">// → 0.727367032552138</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>());
<span class="cm-comment">// → 0.40180766698904335</span></pre>

<p>اگرچه کامپیوتر ها ماشین‌هایی قطعی محسوب می‌شوند- همیشه به ورودی یکسان، واکنش یکسانی بروز می دهند –  اما می توان از آن ها خواست تا اعدادی که ظاهرا تصادفی هستند را تولید کنند. برای این کار، کامپیوتر بعضی مقادیر مخفی را در نظر می گیرد، و هر وقت که شما درخواست عدد تصادفی می کنید، محاسبات پیچیده‌ای را روی آن مقدارهای مخفی انجام می دهد تا مقدار جدیدی بسازد.  مقدار جدید را ذخیره کرده و عددی که از آن گرفته شده را به عنوان پاسخ برمی گرداند. با این روش، قادر است که اعداد جدیدی تولید کند که به سختی قابل پیش بینی اند طوری که <em>به نظر</em> تصادفی می آیند.</p>

<p>اگر به جای اعداد اعشاری، به یک عدد تصادفی کامل(صحیح) نیاز داریم،‌می توانیم از متد <bdo><code>Math.floor</code></bdo> (که عدد ورودی‌اش را به نزدیک ترین عدد کوچکتر کامل گرد می کند ) برای نتیجه <bdo><code>Math.random</code></bdo> استفاده کنیم.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_LlfOX4tbSH" href="#c_LlfOX4tbSH" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">10</span>));
<span class="cm-comment">// → 2</span></pre>

<p><a class="p_ident" id="p_qeS+PbyE0t" href="#p_qeS+PbyE0t" tabindex="-1" role="presentation"></a>ضرب عدد تصادفی در عدد 10 باعث می شود که عددی بزرگتر مساوی 0 و کوچکتر از 10 را تولید کنیم. به علت اینکه <bdo><code>Math.floor</code></bdo> به سمت پایین عدد را گرد می کند،  این عبارت، عددی تصادفی بین 0 تا 9 را تولید می کند.</p>

<p>همچنین توابع دیگری وجود دارد مثل <bdo><code>Math.ceil</code></bdo>  برای گرد کردن به سمت بالا (سقف)، <bdo><code>Math.round</code></bdo> تولید نزدیک ترین عدد صحیح و <bdo><code>Math.abs</code></bdo> برای بدست آوردن قدرمطلق عدد (اندازه مطلق عدد فارغ از علامت آن، اعداد منفی را منفی کرده و به اعداد مثبت کاری ندارد).</p>

<h2><a class="h_ident" id="h_FM848ofYuz" href="#h_FM848ofYuz" tabindex="-1" role="presentation"></a>تجزیه کردن (destructring)</h2>

<p>اجازه بدهید به تابع محاسبه <code>phi</code> (فی) برگردیم:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_8p90ivE8ZI" href="#c_8p90ivE8ZI" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">phi</span>(<span class="cm-def">table</span>) {
  <span class="cm-keyword">return</span> (<span class="cm-variable-2">table</span>[<span class="cm-number">3</span>] <span class="cm-operator">*</span> <span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">-</span> <span class="cm-variable-2">table</span>[<span class="cm-number">2</span>] <span class="cm-operator">*</span> <span class="cm-variable-2">table</span>[<span class="cm-number">1</span>]) <span class="cm-operator">/</span>
    <span class="cm-variable">Math</span>.<span class="cm-property">sqrt</span>((<span class="cm-variable-2">table</span>[<span class="cm-number">2</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">3</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">1</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">1</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">3</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">2</span>]));
}</pre>

<p>یکی از دلایلی که این تابع خوانایی سختی دارد این است که متغیری داریم که به آرایه‌ی ما ارجاع می دهد، در حالیکه بهتر این بود که متغیرهایی برای اشاره به <em>عناصر</em> آرایه داشتیم، مثل، <bdo><code>let n00 = table[0]</code></bdo> و از این قبیل. خوشبختانه راه مختصری برای این کار در جاوااسکریپت تعبیه شده است.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_z2cboTL/zX" href="#c_z2cboTL/zX" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">phi</span>([<span class="cm-def">n00</span>, <span class="cm-def">n01</span>, <span class="cm-def">n10</span>, <span class="cm-def">n11</span>]) {
  <span class="cm-keyword">return</span> (<span class="cm-variable-2">n11</span> <span class="cm-operator">*</span> <span class="cm-variable-2">n00</span> <span class="cm-operator">-</span> <span class="cm-variable-2">n10</span> <span class="cm-operator">*</span> <span class="cm-variable-2">n01</span>) <span class="cm-operator">/</span>
    <span class="cm-variable">Math</span>.<span class="cm-property">sqrt</span>((<span class="cm-variable-2">n10</span> <span class="cm-operator">+</span> <span class="cm-variable-2">n11</span>) <span class="cm-operator">*</span> (<span class="cm-variable-2">n00</span> <span class="cm-operator">+</span> <span class="cm-variable-2">n01</span>) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">n01</span> <span class="cm-operator">+</span> <span class="cm-variable-2">n11</span>) <span class="cm-operator">*</span> (<span class="cm-variable-2">n00</span> <span class="cm-operator">+</span> <span class="cm-variable-2">n10</span>));
}</pre>

<p>این روش برای متغیرهایی که با <code>let</code>، <code>var</code> یا <code>const</code> تعریف شده اند نیز کار می کند. اگر می دانید که مقدار مورد نظر، یک آرایه است، می توانید از براکت‌ها برای دسترسی به درون آن مقدار استفاده کرده و محتوایش را مورد ارجاع قرار دهید.</p>

<p>روش مشابهی برای اشیاء نیز وجود دارد، استفاده از کروشه به جای براکت‌.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ZXEdn9Xbfc" href="#c_ZXEdn9Xbfc" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> {<span class="cm-def">name</span>} <span class="cm-operator">=</span> {<span class="cm-property">name</span>: <span class="cm-string">&quot;Faraji&quot;</span>, <span class="cm-property">age</span>: <span class="cm-number">23</span>};
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">name</span>);
<span class="cm-comment">// → Faraji</span></pre>

<p>توجه داشته باشید، اگر سعی کنید <code>null</code> یا <code>undefined</code> را تجزیه کنید، با خطا مواجه خواهید شد، درست شبیه اینکه بخواهید مستقیما به خاصیتی از این دو مقدار اشاره کنید.</p>

<h2><a class="h_ident" id="h_AxpOdvCznQ" href="#h_AxpOdvCznQ" tabindex="-1" role="presentation"></a>JSON</h2>

<p><a class="p_ident" id="p_0ESehgd0SY" href="#p_0ESehgd0SY" tabindex="-1" role="presentation"></a>به دلیل این واقعیت که خاصیت‌ها (properties)، به مقدارهای متناظرشان فقط دسترسی دارند نه اینکه واقعا آن‌ها را نگه‌داری کنند، آرایه‌ها و اشیاء به صورت دنباله‌ای از بیت‌ها در حافظه‌ی کامپیوتر ذخیره می‌شوند که آدرس‌های محتوای مرتبطشان را نگه داری می کنند (مکان‌های حافظه). بنابراین یک آرایه که آرایه‌ای دیگر درون آن قرار گرفته حداقل از یک ناحیه‌ی حافظه برای آرایه‌ی درونی، و ناحیه‌ای دیگر برای آرایه‌ی بیرونی تشکیل شده است، که حاوی (علاوه بر چیزهای دیگر) یک عدد دودویی است که نمایانگر موقعیت آرایه‌ی درونی می‌باشد.</p>

<p>اگر لازم است که داده‌ها را برای استفاده در آینده، در یک فایل ذخیره کنید ، یا به کامپیوتر دیگری در شبکه ارسال کنید، باید به شکلی این آدرس‌های حافظه را تبدیل به توصیفاتی کنید که بتوان آن را ذخیره یا ارسال کرد.  می توانستید تمام حافظه‌ی کامپیوتر را همراه با آدرس مقدار مورد نظر ارسال کنید، ظاهرا شدنی است، اما به نظر می رسد روش خیلی خوبی محسوب نمی شود.</p>

<p><a class="p_ident" id="p_Jmb/Tnmis5" href="#p_Jmb/Tnmis5" tabindex="-1" role="presentation"></a>کاری که می توانیم در این موقعیت بکنیم این است که داده ها را پشت سرهم ردیف کنیم( serialize). به این معنا که آن را  به متنی تخت تبدیل کنیم. یکی از فرمت‌های محبوب سریال کردن داده ها <em>JSON</em> نامیده می شود ( که جی سن تلفظ می شود)، که مخفف نشانه‌گذاری شیء جاوااسکریپت است (javascript object notation). این روش به طور گسترده به عنوان روشی برای ذخیره داده‌ها و ارسال/دریافت آن ها در وب استفاده می شود، حتی در دیگر زبان‌های برنامه‌نویسی غیر ازجاوااسکریپت نیز معمول است.</p>

<p><a class="p_ident" id="p_mOPfDLWRIN" href="#p_mOPfDLWRIN" tabindex="-1" role="presentation"></a>JSON با کمی محدودیت، بسیار شبیه به روش جاوااسکریپت در نوشتن آرایه‌ها و اشیاء به نظر می رسد. نام خاصیت ها باید حتما با نقل قول جفتی احاطه شوند، و فقط عبارت‌های داده‌ای ساده قابل قبول هستند – متغیرها، فراخوانی توابع، یا هرچیزی که شامل محاسبه‌ی عملی می‌باشد مجاز نیستند. توضیحات هم در JSON مجاز نیستند.</p>

<p><a class="p_ident" id="p_AxpOdvCznQ" href="#p_AxpOdvCznQ" tabindex="-1" role="presentation"></a>یک مدخل گزارش روزانه ممکن است شبیه به کد زیر باشد اگر به فرمت JSON  نوشته شود:</p>

<pre class="snippet cm-s-default" data-language="application/json" ><a class="c_ident" id="c_A3jdCqz1Q6" href="#c_A3jdCqz1Q6" tabindex="-1" role="presentation"></a>{
  <span class="cm-string cm-property">&quot;squirrel&quot;</span>: <span class="cm-atom">false</span>,
  <span class="cm-string cm-property">&quot;events&quot;</span>: [<span class="cm-string">&quot;work&quot;</span>, <span class="cm-string">&quot;touched tree&quot;</span>, <span class="cm-string">&quot;pizza&quot;</span>, <span class="cm-string">&quot;running&quot;</span>]
}</pre>

<p><a class="p_ident" id="p_JnOVm6g13o" href="#p_JnOVm6g13o" tabindex="-1" role="presentation"></a>جاوااسکریپت دو متد <bdo><code>JSON.stringify</code></bdo>  و <bdo><code>JSON.parse</code></bdo> را در اختیار ما قرار داده است تا بتوانیم داده‌ها را به JSON تبدیل یا‌ از آن استخراج کنیم. تابع اول یک مقدار جاوااسکریپتی را گرفته و به رشته‌ای با فرمت JSON تبدیل می کند. تابع دوم رشته‌ای با فرمت JSON را گرفته و آن را به مقداری که درون رشته تعبیه شده است تبدیل می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_HYCgCsK7z1" href="#c_HYCgCsK7z1" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">string</span> <span class="cm-operator">=</span> <span class="cm-variable">JSON</span>.<span class="cm-property">stringify</span>({<span class="cm-property">squirrel</span>: <span class="cm-atom">false</span>,
                             <span class="cm-property">events</span>: [<span class="cm-string">&quot;weekend&quot;</span>]});
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">string</span>);
<span class="cm-comment">// → {&quot;squirrel&quot;:false,&quot;events&quot;:[&quot;weekend&quot;]}</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">JSON</span>.<span class="cm-property">parse</span>(<span class="cm-variable">string</span>).<span class="cm-property">events</span>);
<span class="cm-comment">// → [&quot;weekend&quot;]</span></pre>

<h2><a class="h_ident" id="h_EzvDUHyjs2" href="#h_EzvDUHyjs2" tabindex="-1" role="presentation"></a>خلاصه</h2>

<p>آشیاء و آرایه ها ( آرایه‌ها هم شکلی خاصی از آشیاء هستند) روش‌هایی  فراهم می کنند که به وسیله‌ی آن‌ها، مقادیر متعددی را گروه‌بندی کرده و به عنوان یک مقدار در اختیار داشته باشیم. به لحاظ مفهومی، این کار ما را قادر می سازد به جای نگه‌داری چیزهای متعدد با دست، آن‌ها را در سبدی قرار داده و با خودمان جابجا کنیم.</p>

<p>اکثر مقادیر در جاواسکریپت داری مجموعه‌ای از خاصیت‌ها می باشند، مورد استثنا <code>null</code> و <code>undefined</code> است. می توان به خاصیت ها به صورت <bdo><code>value.prop</code></bdo> یا <bdo><code>value[&quot;prop&quot;]</code></bdo> دسترسی داشت. در اشیاء، خاصیت ها نام گذاری می‌شوند و معمولا مجموعه‌ی ثابتی از آن ها را نگه داری می کنند. آرایه‌ها، از سویی دیگر، حاوی تعداد متنوعی از مقدارهای معمولا یک جنس می باشند و از اعداد ( با شروع از صفر) به عنوان نام خاصیت‌هایشان استفاده می کنند.</p>

<p>البته بعضی خاصیت‌ها در آرایه‌ها وجود دارند که نام‌گذاری شده اند؛ مانند <code>length</code> و بعضی دیگر. متدها توابعی هستند که در خاصیت‌ها قرار دارند و (معمولا) روی مقداری که خاصیتی از آن محسوب می‌شوند عمل می کنند.</p>

<p><a class="p_ident" id="p_8WGwzmic/b" href="#p_8WGwzmic/b" tabindex="-1" role="presentation"></a>می توانید عناصر یک آرایه را به وسیله نوع خاصی از حلقه‌ی  <code>for</code> پیمایش کنید. <br> <bdo>for (let element of array)</bdo></p>

<h2><a class="h_ident" id="h_ggOFdVwDCk" href="#h_ggOFdVwDCk" tabindex="-1" role="presentation"></a>تمرین‌ها</h2>

<h3><a class="i_ident" id="i_WHIVprwt1h" href="#i_WHIVprwt1h" tabindex="-1" role="presentation"></a>مجموع یک بازه</h3>

<p>در <a href="00_intro.html">مقدمه‌ی</a> این کتاب، به مثال زیر به عنوان یک راه خوب برای محاسبه‌ی مجموع بازه‌ای از اعداد اشاره شد:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_KTbQMmMCli" href="#c_KTbQMmMCli" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sum</span>(<span class="cm-variable">range</span>(<span class="cm-number">1</span>, <span class="cm-number">10</span>)));</pre>

<p>تابعی به نام <code>range</code> بنویسید که دو آرگومان را دریافت می کند، <code>start</code> و <code>end</code> و آرایه‌ای بر می گرداند که حاوی تمامی اعدادی است که از <code>start</code> شروع شده و با عدد <code>end</code> پایان می یابد.</p>

<p><a class="p_ident" id="p_jv/uQJxiXh" href="#p_jv/uQJxiXh" tabindex="-1" role="presentation"></a>سپس، تابعی به نام <code>sum</code> بنویسید که آرایه‌ای از اعداد را گرفته و مجموع این اعداد را بر می گرداند. برنامه‌ ای که در مثال آمده را اجرا کرده و بررسی کنید که آیا 55 را به عنوان پاسخ بر می گرداند؟</p>

<p><a class="p_ident" id="p_vTcNG2+bNY" href="#p_vTcNG2+bNY" tabindex="-1" role="presentation"></a>به عنوان یک ماموریت تشویقی، تابع <code>range</code> خود را تغییر دهید تا آرگومان اختیاری سومی هم قبول کند. این آرگومان گام (step) را برای ساختن آرایه مشخص می کند. اگر گامی مشخص نشود، عناصر آرایه، مثل حالت پیش‌فرض، با یک واحد افزایش می یابند. فراخوانی تابع به شکل <bdo><code>range(1, 10, 2)</code></bdo> بایستی خروجی <bdo><code>[1, 3, 5, 7, 9]</code></bdo> را تولید کند. مطمئن شوید که تابع با گام منفی هم کار خواهد کرد پس  <bdo><code>range(5, 2, -1)</code></bdo> بایستی <bdo><code>[5, 4, 3, 2]</code></bdo> را تولید کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_gV3XCKJAqj" href="#c_gV3XCKJAqj" tabindex="-1" role="presentation"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">range</span>(<span class="cm-number">1</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">range</span>(<span class="cm-number">5</span>, <span class="cm-number">2</span>, <span class="cm-operator">-</span><span class="cm-number">1</span>));
<span class="cm-comment">// → [5, 4, 3, 2]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sum</span>(<span class="cm-variable">range</span>(<span class="cm-number">1</span>, <span class="cm-number">10</span>)));
<span class="cm-comment">// → 55</span></pre>

<div class="solution"><div class="solution-text">

<p>ساختن یک آرایه، در ساده ترین شکل با تعریف یک متغیر و انتساب <code>[]</code> (یک آرایه‌ی تازه و خالی) و فراخوانی مکرر متد <code>push</code> برای افزودن مقدار، صورت می گیرد. فراموش نکنید که در انتهای تابع، آرایه را برگردانید.</p>

<p>به دلیل اینکه مرز انتهایی بازه باید شامل شود، لازم است تا از عملگر  <bdo><code>&lt;=</code></bdo> به جای عملگر <bdo><code>&lt;</code></bdo> برای بررسی انتهای حلقه استفاده کنید.</p>

<p><a class="p_ident" id="p_tDbwY2goFd" href="#p_tDbwY2goFd" tabindex="-1" role="presentation"></a>پارامتر step را می توان به صورت یک پارامتر پیش‌فرض تعریف کرد (استفاده از عملگر <code>=</code>) و مقدار آن را 1 قرار داد.</p>

<p>برای اینکه <code>range</code> بتواند گام منفی را پیاده سازی کنید، احتمالا بهترین روش نوشتن دو حلقه است. یکی برای شمارش به بالا و دیگری برای شمارش به پایین. چراکه عمل مقایسه‌ای که به پایان رسیدن حلقه را بررسی می کند در حالت شمارش به پایین لازم است تا از <bdo><code>&gt;=</code></bdo> به جای <bdo><code>&lt;=</code></bdo> استفاده کند.</p>

<p>خوب است در مواقعی که پایان بازه از ابتدای آن کوچکتر است، از گام پیش‌فرض دیگری استفاده شود، مثلا <bdo>-1</bdo>. با این کار، <bdo><code>range(5, 2)</code></bdo> خروجی معقولی خواهد داشت و در حلقه‌ی بینهایت گیر نخواد افتاد. می توان در مقدار پیش‌فرض یک پارامتر به پارامترهای قبل ارجاع داد.</p>

</div></div>

<h3><a class="i_ident" id="i_MkGLDJw2/V" href="#i_MkGLDJw2/V" tabindex="-1" role="presentation"></a>معکوس کردن یک آرایه</h3>

<p>آرایه‌ها متدی به نام <code>reverse</code> دارند که ترتیب عناصر آرایه را معکوس می نماید. برای این تمرین، دو تابع بنویسید:<code>reverseArray</code> و <code>reverseArrayInPlace</code>. تابع اول ، <code>reverseArray</code> آرایه ای را به عنوان ورودی می گیرد و آرایه‌ی <em>جدیدی</em> را تولید می کند که همان عناصر را دارد اما با ترتیب وارونه. تابع دوم، <code>reverseArrayInPlace</code> مشابه‌ متد <code>reverse</code> عمل می کند؛ با این تفاوت که همان آرایه‌ای را که به عنوان آرگومان دریافت می کند  <em>تغییر می دهد</em> و ترتیب عناصرش را عکس می کند. در این تمرین نمی توانید از متد استاندارد <code>reverse</code> استفاده کنید.</p>

<p>به بحث اثرات جانبی و توابع ناب فکر کنید که در <a href="03_functions.html#pure">فصل قبل</a> صحبت شد، به نظر شما کدام تابع از موارد بالا در موقعیت های بیشتری کاربرد خواهد داشد؟ کدام سریع‌تر عمل می کند؟</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_sghv5avX0H" href="#c_sghv5avX0H" tabindex="-1" role="presentation"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">reverseArray</span>([<span class="cm-string">&quot;A&quot;</span>, <span class="cm-string">&quot;B&quot;</span>, <span class="cm-string">&quot;C&quot;</span>]));
<span class="cm-comment">// → [&quot;C&quot;, &quot;B&quot;, &quot;A&quot;];</span>
<span class="cm-keyword">let</span> <span class="cm-def">arrayValue</span> <span class="cm-operator">=</span> [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>, <span class="cm-number">5</span>];
<span class="cm-variable">reverseArrayInPlace</span>(<span class="cm-variable">arrayValue</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">arrayValue</span>);
<span class="cm-comment">// → [5, 4, 3, 2, 1]</span></pre>

<div class="solution"><div class="solution-text">

<p>دو روش روشن برای پیاده‌سازی تابع <code>reverseArray</code> وجود دارد. اولین روش این است که خیلی ساده به سراغ آرایه‌ی ورودی رفته و از ابتدا تا پایان آن، از متد <code>unshift</code> برای قرار دادن تک تک عناصر درون آرایه‌ی جدید استفاده کنید. روش دوم این است که آرایه‌ی ورودی را به صورت وارونه پیمایش کنید و از متد ‍<code>push</code> استفاده نمایید. پیمایش معکوس یک آرایه نیاز به یک حلقه‌ی <code>for</code> خاص (کمی غیرمتعارف) دارد. چیزی شبیه <bdo><code>(let i = array.<wbr>length - 1; i &gt;= 0; i--)</code></bdo>.</p>

<p>وارونه کردن آرایه به صورت درجا، مشکل تر است. باید مراقب باشین عناصری که که در ادامه لازم دارید را رونویسی نکنید. استفاده از <code>reverseArray</code> یا کپی کردن کل آرایه (<bdo><code>array.slice(0)</code></bdo> روش خوبی برای کپی کردن یک آرایه است) کمک می کند اما تقلب محسوب می شود.</p>

<p>ترفند این است که عنصر‌های اول و پایانی را با هم عوض کنید، سپس عنصر دوم را با عنصر یکی مانده به پایانی و الی آخر. می توانید این کار را پیمایش نیمی از طول آرایه انجام دهید (از <bdo><code>Math.floor</code></bdo> برای گرد کردن استفاده کنید. نیازی نیست در آرایه‌ای با طول فرد، عنصر وسط آرایه را پیمایش کنید) و عنصر موقعیت <code>i</code> را با عنصر موقعیت <bdo><code>array.<wbr>length - 1 - i</code></bdo> عوض کنید. می توانید از یک متغیر محلی استفاده کنید تا یک عنصر را نگه‌داری کنید، آن را با قرینه‌اش رونویسی کنید و سپس مقدار متغیر محلی را جایی قرار دهید که قرینه قبلا قرار داشت.</p>

</div></div>

<h3 id="list"><a class="i_ident" id="i_Ef6SfP47kD" href="#i_Ef6SfP47kD" tabindex="-1" role="presentation"></a>لیست</h3>

<p>اشیاء به عنوان مقادیری بدون چارچوب خاص، می توانند برای ساختن هر نوع ساختار داده استفاده شوند. یکی از انواع رایج ساختار داده، <em>لیست</em> است ( نباید لیست را با آرایه اشتباه گرفت). یک لیست مجموعه‌ای تودرتو از اشیاء است که در آن اولین شیء ارجاعی به دومین، دومین به سومین و الی آخر را نگه داری می کند.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_kYAco70aHD" href="#c_kYAco70aHD" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">list</span> <span class="cm-operator">=</span> {
  <span class="cm-property">value</span>: <span class="cm-number">1</span>,
  <span class="cm-property">rest</span>: {
    <span class="cm-property">value</span>: <span class="cm-number">2</span>,
    <span class="cm-property">rest</span>: {
      <span class="cm-property">value</span>: <span class="cm-number">3</span>,
      <span class="cm-property">rest</span>: <span class="cm-atom">null</span>
    }
  }
};</pre>

<p>اشیائی که در یک زنجیره وجود دارند به این شکل خواهند بود:</p><figure><img src="img/linked-list.svg" alt="A linked list"></figure>

<p><a class="p_ident" id="p_OLYr5L3apW" href="#p_OLYr5L3apW" tabindex="-1" role="presentation"></a>یکی از نکات خوب لیست ها این است که آن ها بخشی از ساختارشان را به اشتراک می گذارند. به عنوان مثال، اگر من دو مقدار جدید ایجاد کنم <bdo><code>{value: 0, rest: list}</code></bdo> و <bdo><code>{value: -1, rest: list}</code></bdo> (که list در اینجا به متغیری است که پیش‌تر تعریف شده است)، هر دوی آن ها لیست‌های مستقلی هستند، اما ساختاری را به اشتراک می گذارند که سه عنصر آخرشان را می سازد. لیست اصلی همچنین هنوز یک لیست سه عنصره‌ی معتبر است.</p>

<p>تابعی به نام <code>arrayToList</code> بنویسید که یک ساختار لیست شبیه لیستی که نشان داده شد بسازد و مقدار <bdo><code>[1, 2, 3]</code></bdo> را به عنوان آرگومان دریافت کند. همچنین تابعی به نام <code>listToArray</code> بنویسید که آرایه‌ای از لیست داده شده تولید کند. بعد تابع‌ کمکی <code>prepend</code> را تعریف کنید که یک عنصر به همراه یک لیست را گرفته و لیست جدیدی تولید می کند که عنصر مورد نظر در ابتدای آن اضافه شده است و تابع <code>nth</code> که یک لیست و یک عدد را گرفته و عنصری که در موقعیت خواسته شده قرار دارد را از لیست بر می گرداند ( صفر به عنصر اول اشاره می کند) یا اینکه در صورت نبودن عنصر، مقدار <code>undefined</code> برگردانده می شود.</p>

<p>اگر به روش بازگشتی این مسئله را حل نکرده‌اید، اکنون نسخه‌ی بازگشتی تابع <code>nth</code> را هم بنویسید.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_rufmukl+AQ" href="#c_rufmukl+AQ" tabindex="-1" role="presentation"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">arrayToList</span>([<span class="cm-number">10</span>, <span class="cm-number">20</span>]));
<span class="cm-comment">// → {value: 10, rest: {value: 20, rest: null}}</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">listToArray</span>(<span class="cm-variable">arrayToList</span>([<span class="cm-number">10</span>, <span class="cm-number">20</span>, <span class="cm-number">30</span>])));
<span class="cm-comment">// → [10, 20, 30]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">prepend</span>(<span class="cm-number">10</span>, <span class="cm-variable">prepend</span>(<span class="cm-number">20</span>, <span class="cm-atom">null</span>)));
<span class="cm-comment">// → {value: 10, rest: {value: 20, rest: null}}</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">nth</span>(<span class="cm-variable">arrayToList</span>([<span class="cm-number">10</span>, <span class="cm-number">20</span>, <span class="cm-number">30</span>]), <span class="cm-number">1</span>));
<span class="cm-comment">// → 20</span></pre>

<div class="solution"><div class="solution-text">

<p>ساختن یک لیست از انتها به ابتدا، ساده تر خواهد بود. بنابراین <code>arrayToList</code> می تواند آرایه را به صورت معکوس پیمایش کند (مانند تمرین قبل) و برای هر عنصر، یک شیء به لیست اضافه کند. می توانید از یک متغیر محلی برای نگه‌داری بخشی از لیست که تاکنون ساخته شده استفاده کنید و از انتسابی مثل <bdo> <code>list = {value: X, rest: list}</code></bdo> برای افزودن یک عنصر بهره ببرید.</p>

<p>برای پیمایش یک لیست ( در <code>listToArray</code> و <code>nth</code> )، یک حلقه‌ی <code>for</code> با مشخصاتی شبیه زیر، می تواند استفاده شود:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_HLrOQGihFR" href="#c_HLrOQGihFR" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">node</span> <span class="cm-operator">=</span> <span class="cm-variable">list</span>; <span class="cm-variable">node</span>; <span class="cm-variable">node</span> <span class="cm-operator">=</span> <span class="cm-variable">node</span>.<span class="cm-property">rest</span>) {}</pre>

<p><a class="p_ident" id="p_K+iMpCQsdu" href="#p_K+iMpCQsdu" tabindex="-1" role="presentation"></a>می توانید کارکرد آن را توضیح دهید؟ در هر تکرار حلقه، <code>node</code> به زیرلیست فعلی اشاره می کند و بدنه می تواند خاصیت <code>value</code> آن را بخواند تا عنصر فعلی را به دست بیاورد. در انتهای یک تکرار، <code>node</code> به سراغ زیرلیست بعد می رود. زمانی که برابر null شد، ما به انتهای لیست رسیده ایم و حلقه پایان می یابد.</p>

<p><a class="p_ident" id="p_U2JSxd0Dr1" href="#p_U2JSxd0Dr1" tabindex="-1" role="presentation"></a>نسخه‌ی بازگشتی <code>nth</code>، به طور مشابه، در هر فراخوانی بازگشتی، بخش کوچک‌تری از دنباله‌ی لیست می پردازد و همزمان عدد اندیس را کاهش می دهد تا زمانی که به صفر برسد، در نقطه‌ای که می تواند خاصیت <code>value</code> مربوط به node مورد جستجو را برگرداند. برای گرفتن عنصر صفرم یک لیست، به سادگی می توانید خاصیت <code>value</code> سرگره (head node) را بگیرید. برای گرفتن عنصر <bdo><em>N</em> + 1</bdo>، عنصر Nام لیست را که در خاصیت <code>rest</code> این لیست قرار دارد، می گیرید.</p>

</div></div>

<h3 id="exercise_deep_compare"><a class="i_ident" id="i_L+soasFN5H" href="#i_L+soasFN5H" tabindex="-1" role="presentation"></a>مقایسه عمیق</h3>

<p>عملگر <code>==</code> اشیاء را بر اساس همسانی مقایسه می کند  .  اما گاهی ممکن است بخواهید مقدارهای خاصیت‌های واقعی آن ها را مقایسه کنید.</p>

<p><a class="p_ident" id="p_X/5TO4MPCK" href="#p_X/5TO4MPCK" tabindex="-1" role="presentation"></a>تابعی به نام <code>deepEqual</code> بنویسید که دو مقدار را دریافت می کند و زمانی مقدار true‌ را بر می گرداند که هر دوی مقدار ها مشابه باشند یا اگر شیء هستند خاصیت‌های یکسانی داشته باشند، به طوریکه مقدارهای خاصیت‌های آن ها نیز در صورت مقایسه با یک فراخوانی بازگشتی تابع <code>deepEqual</code>، برابر باشند.</p>

<p>برای اینکه بدانیم آیا مقدارها باید مستقیما باهم مقایسه شوند ( از عملگر <code>===</code> برای آن استفاده کنید) یا اینکه خاصیت‌هایشان را باید مقایسه‌ کنیم، می توان از عملگر <code>typeof</code> استفاده کرد. اگر این عملگر <code>“object”</code> برای هر دو مقدار تولید کرد، بایستی عمل مقایسه‌ی عمیق انجام شود. راستی باید یک استثناء احمقانه را هم نیز در نظر بگیرید:  به دلیل اتفاقی قدیمی، <bdo><code>typeof null</code></bdo> نیز <code>“object”</code> را تولید می کند.</p>

<p>وقتی برای مقایسه‌ی خاصیت‌های اشیاء لازم است که به خاصیت‌ها دسترسی پیدا کنید، تابع <bdo><code>Object.keys</code></bdo> به شما کمک خواهد کرد.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_kWPN5i/Y3x" href="#c_kWPN5i/Y3x" tabindex="-1" role="presentation"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-keyword">let</span> <span class="cm-def">obj</span> <span class="cm-operator">=</span> {<span class="cm-property">here</span>: {<span class="cm-property">is</span>: <span class="cm-string">&quot;an&quot;</span>}, <span class="cm-property">object</span>: <span class="cm-number">2</span>};
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">deepEqual</span>(<span class="cm-variable">obj</span>, <span class="cm-variable">obj</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">deepEqual</span>(<span class="cm-variable">obj</span>, {<span class="cm-property">here</span>: <span class="cm-number">1</span>, <span class="cm-property">object</span>: <span class="cm-number">2</span>}));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">deepEqual</span>(<span class="cm-variable">obj</span>, {<span class="cm-property">here</span>: {<span class="cm-property">is</span>: <span class="cm-string">&quot;an&quot;</span>}, <span class="cm-property">object</span>: <span class="cm-number">2</span>}));
<span class="cm-comment">// → true</span></pre>

<div class="solution"><div class="solution-text">

<p>آزمایش تشخیص شیء چیزی شبیه به <bdo><code>typeof x == &quot;object&quot; &amp;&amp; x != null</code></bdo> خواهد بود. دقت داشته باشید فقط زمانی خاصیت‌ها را مقایسه کنید که هر دو آرگومان object (شیء) باشند. در همه‌ی موارد دیگر، می توانید نتیجه‌ی <code>===</code> را برگردانید.</p>

<p>برای گرفتن خاصیت‌ها از <bdo><code>Object.keys</code></bdo> استفاده کنید. لازم است ببینید که هر دوی اشیاء خاصیت‌های مشابهی داشته باشند و مقادیر آن‌ها نیز یکسان باشد. یک روش این است که مطمئن شوید هر دو، تعداد خاصیت‌های یکسانی دارند (طول لیست خاصیت‌ها مشابه باشد). و سپس، هنگام پیمایش خاصیت‌های یک شیء برای مقایسه، همیشه اول اطمینان حاصل کنید که شیء دیگر خاصیتی با همان نام داشته باشد. اگر هر دو شیء تعداد خاصیت‌ یکسانی داشته باشند و همه‌ی خاصیت‌های موجود در یکی، در دیگر نیز باشد، هر دو، مجموعه‌ی یکسانی از خاصیت‌ها را دارند.</p>

<p><a class="p_ident" id="p_iYkMFxHxnk" href="#p_iYkMFxHxnk" tabindex="-1" role="presentation"></a>بهترین روش بازگرداندن مقدار درست از یک تابع این است که هر زمان یک عدم تطبیق پیدا شد، بلافاصله false برگردانده شود و در انتهای تابع مقدار true را برگردانیم.</p>

</div></div><nav><a href="03_functions.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="05_higher_order.html" title="next chapter">▶</a></nav>
</article>
